<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember Blog</title>
  <subtitle>Ember News and Updates</subtitle>
  <id>http://emberjs.com/blog</id>
  <link href="http://emberjs.com/blog"/>
  <link href="http://emberjs.com/blog/feed.xml" rel="self"/>
  <updated>2015-05-23T19:00:00-05:00</updated>
  <author>
    <name>Ember</name>
  </author>
  <entry>
    <title>Another Ember 2.x Status Update</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/24/another-two-oh-status-update.html"/>
    <id>http://emberjs.com/blog/2015/05/24/another-two-oh-status-update.html</id>
    <published>2015-05-23T19:00:00-05:00</published>
    <updated>2015-05-23T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We're just a few weeks away from the release of Ember 1.13 and Ember 2.0 beta, and while there's been a lot of focus on those releases, the trains will keep rolling on June 12. There will be a 2.1 release 6 weeks hence, and a 2.2 release 6 weeks later...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We&amp;#39;re just a few weeks away from the release of Ember 1.13 and Ember 2.0 beta, and while there&amp;#39;s been a lot of focus on those releases, the trains will keep rolling on June 12. There will be a 2.1 release 6 weeks hence, and a 2.2 release 6 weeks later.&lt;/p&gt;

&lt;p&gt;With all of the focus on Ember 2.0, it&amp;#39;s easy to forget that 2.0 is just a six-week release, with the added ability to remove some built-up cruft. Because of the symbolic nature of 2.0, discussions about the future have had an artificial end date of June 12, which is now just three weeks away.&lt;/p&gt;

&lt;p&gt;This post gives some more details about what cruft will be removed in Ember 2.0, but, since the first features in Ember 2.1 will land in Canary just three weeks hence, what we plan to do in the early releases of Ember 2.x.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s important to note that we&amp;#39;ve talked a lot about an improved &amp;quot;Ember 2 programming model&amp;quot; over the past several months, significantly inspired by React. While much of the model will be in place in Ember 2.0, the early releases of Ember 2.x (especially 2.1 and 2.2), will finish up some important features. This blog post details the expected timeline.&lt;/p&gt;

&lt;p&gt;Of course, the six-week release cycle means that we ship on a train cycle, so the precise versions of specific features may change before they land in a final release.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_removals'&gt;Removals&lt;/h2&gt;
&lt;p&gt;While we&amp;#39;ve spent a lot of time talking about the new features that Ember is getting over the next few months, the 2.0 release itself is more about removals and de-cruft-ification.&lt;/p&gt;

&lt;p&gt;Some notable examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Context-shifting helpers (&lt;code&gt;#with item&lt;/code&gt; becomes &lt;code&gt;#with item as |i|&lt;/code&gt;,
&lt;code&gt;#each list&lt;/code&gt; becomes &lt;code&gt;#each list as |item|&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Fake block params versions of helpers (&lt;code&gt;#with foo as bar&lt;/code&gt; becomes
&lt;code&gt;#with foo as |bar|&lt;/code&gt;, &lt;code&gt;#each item in list&lt;/code&gt; becomes
&lt;code&gt;#each list as |item|&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ArrayPolyfills&lt;/code&gt; and &lt;code&gt;EnumerableUtils&lt;/code&gt; libraries are being
pulled out into a library; most apps should prefer lodash or other
utility libs.&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;#each&lt;/code&gt;, the options &lt;code&gt;itemController&lt;/code&gt;, &lt;code&gt;itemViewClass&lt;/code&gt;,
&lt;code&gt;itemView&lt;/code&gt;; superseded by using a component inside the loop&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;#with&lt;/code&gt;, the &lt;code&gt;controller&lt;/code&gt; option&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Ember.Handlebars&lt;/code&gt; namespace and all of its properties&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind-attr&lt;/code&gt;, superseded by just using attributes&lt;/li&gt;
&lt;li&gt;The legacy names &lt;code&gt;bindAttr&lt;/code&gt; and &lt;code&gt;linkTo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{collection}}&lt;/code&gt; helper&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{template}}&lt;/code&gt; helper; superseded by &lt;code&gt;{{partial}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{render}}&lt;/code&gt; helper; superseded in most cases by components&lt;/li&gt;
&lt;li&gt;Manually rendering a string into the buffer in a view&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Deferred&lt;/code&gt;; superseded by normal promises&lt;/li&gt;
&lt;li&gt;The globals resolver, which will be moved into an external library;
superseded in normal use by the ES6 module resolver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While top-level controllers will not be removed in 2.0 (see more below), we will remove all of the other uses of controllers from templates (such as &lt;code&gt;#with controller=&lt;/code&gt;, &lt;code&gt;{{render}}&lt;/code&gt;, &lt;code&gt;itemController&lt;/code&gt; and others).&lt;/p&gt;

&lt;p&gt;In all of these cases, we did significant work in the 1.x series, especially in 1.12 and 1.13, to make sure that the dominant use-cases for these features were addressed by existing or new features.&lt;/p&gt;

&lt;p&gt;You can learn about all of the deprecations added in the 1.x era, along with the expected transition to the features that superseded them, in the &lt;a href="http://emberjs.com/deprecations/v1.x/"&gt;1.x deprecations guide&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_the-glimmer-engine'&gt;The Glimmer Engine&lt;/h2&gt;
&lt;p&gt;The Glimmer engine, with its improved performance and improved support for the &amp;quot;data down, actions up&amp;quot; model, landed in Ember 1.13 beta.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_fast-re-render'&gt;Fast Re-Render&lt;/h2&gt;
&lt;p&gt;In Ember 1.12, calling rerender() on a component is an extremely expensive operation, and blows away all of the existing DOM (together with its internal state, such as selection, cursor, focus, scroll position and more).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In Ember 1.13&lt;/strong&gt;, thanks to the Glimmer engine, you can safely invoke rerender() and it will only update the parts of the template that have actually changed.&lt;/p&gt;

&lt;p&gt;This allows you to replace an entire data structure with a totally new POJO, rerender the component, and get highly performant updates that preserve the DOM.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-lifecycle-hooks'&gt;New Lifecycle Hooks&lt;/h2&gt;
&lt;p&gt;Because &lt;code&gt;rerender()&lt;/code&gt; is now fast and reliable, any call to &lt;code&gt;component.set()&lt;/code&gt; will trigger a re-render on the component. When a component re-renders, that may change the attributes of child components, which likewise are re-rendered.&lt;/p&gt;

&lt;p&gt;As a result of the fact that &lt;code&gt;rerender()&lt;/code&gt; is now such an important part of the programming model, &lt;strong&gt;Ember 1.13 beta&lt;/strong&gt; got a bunch of new React-inspired lifecycle hooks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didUpdateAttrs&lt;/code&gt;, invoked when a component&amp;#39;s attributes have changed
but before the component is rendered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willUpdate&lt;/code&gt;, invoked before a component will rerender, whether
the update was triggered by new attributes or by rerender.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didUpdate&lt;/code&gt;, invoked after a component has been rerendered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt;, invoked when a component gets attributes, either
initially or due to an update.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt;, invoked before a component will render, either
initially or due to an update, and regardless of how the rerender
was triggered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt;, invoked after a component has been rendered, either
initially or due to an update.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These lifecycle hooks will fire on all components (but not views), regardless of invocation style (both curlies and angle bracket style).&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_angle-bracket-components'&gt;Angle Bracket Components&lt;/h2&gt;
&lt;p&gt;Angle bracket components (&lt;code&gt;&amp;lt;my-component&amp;gt;&lt;/code&gt;) are a very important part of the Ember 2.x programming model. In addition to nicer syntax, they serve as an opt-in for component changes that we could not easily make compatibly, such as default one-way bindings.&lt;/p&gt;

&lt;p&gt;We originally thought that angle-bracket components would land in time for Ember 1.13, and they have already landed on Canary, and were included in the first 1.13 beta release.&lt;/p&gt;

&lt;p&gt;However, there were some late-breaking concerns, and we have decided to defer this feature so we can write an RFC and go through the regular process. We have already written an implementation of the RFC, which we will land on Canary and keep up to date with the RFC discussions.&lt;/p&gt;

&lt;p&gt;Because we are so close to the Ember 2.0 branch point, &lt;strong&gt;this feature is likely to land in Ember 2.1.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_routeable-components'&gt;Routeable Components&lt;/h2&gt;
&lt;p&gt;The routeable components RFC was first published several months ago, and has been the subject of vigorous discussion. It is one of the most anticipated features of the Ember 2.x programming model.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;(the following two paragraphs are a bit of insider baseball)&lt;/p&gt;

&lt;p&gt;The primary reason to attempt to land this feature in Ember 2.0, despite the fact that its development is at a relatively early stage, was a desire to deprecate controllers for 2.0. In Ember, in order to deprecate a public API, we require an alternate path for all of the use-cases of the old feature. In order to remove a feature in 2.0, it would have needed to be deprecated in 1.13.&lt;/p&gt;

&lt;p&gt;Together, that means that in order to remove controllers in 2.0, we needed to land routeable components, the transition from controllers, in 1.13. During the 1.13 canary cycle, it became obvious that removing controllers in 2.0 would be too aggressive, so the pressure to ship Routeable Components exactly in 2.0.0 is less.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;The work on Routeable Components, as well as work to make it possible to move query parameters fully to routes, is ongoing.&lt;/p&gt;

&lt;p&gt;There are less than three weeks left until the 2.0-beta branch point, and given that the feature has not yet landed in Canary (and the importance and magnitude of the feature), it will probably land in 2.1 at the earliest.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It is extremely likely to land in 2.1, or 2.2 at the latest.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Routeable Component feature also includes a change that makes it possible to provide multiple asynchronous attributes to the component you are routing to, rather than just the &lt;code&gt;model&lt;/code&gt; attribute. The &lt;code&gt;attrs&lt;/code&gt; hook will run on every transition into the route, in contrast to the &lt;code&gt;model&lt;/code&gt; hook, which doesn&amp;#39;t run again in some cases.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_fastboot'&gt;FastBoot&lt;/h2&gt;
&lt;p&gt;An early version of the FastBoot feature, suitable for SEO, is already available as an Ember addon that works with Ember 1.12. We expect the addon to work with the final release of 1.13.&lt;/p&gt;

&lt;p&gt;Work on rehydrating FastBoot will begin very soon, and we hope to land it in Canary early in the 2.x release cycle.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_engines'&gt;Engines&lt;/h2&gt;
&lt;p&gt;The Engines feature was first proposed as an &lt;a href="https://github.com/tomdale/rfcs/blob/master/active/0000-engines.md"&gt;RFC&lt;/a&gt; last year, and work on the feature itself will likely begin very soon.&lt;/p&gt;

&lt;p&gt;We expect the Engines feature to land in Canary early in the 2.x release cycle.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.17/18 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/21/ember-data-1-0-beta-18-released.html"/>
    <id>http://emberjs.com/blog/2015/05/21/ember-data-1-0-beta-18-released.html</id>
    <published>2015-05-20T19:00:00-05:00</published>
    <updated>2015-05-20T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Beta.17 and Beta.18 contained many bugfixes from the community! Please check
them out in the &lt;a href="https://github.com/emberjs/data/blob/master/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt;. Thank you to everyone who submitted
patches!&lt;/p&gt;

&lt;p&gt;While many bugs were stomped, some important changes are worth calling out:&lt;/p&gt;
&lt;h1 class="anchorable-toc" id="toc_possibly-breaking-deprecations"&gt;(Possibly) Breaking Deprecations&lt;/h1&gt;</summary>
    <content type="html">&lt;p&gt;Beta.17 and Beta.18 contained many bugfixes from the community! Please check
them out in the &lt;a href="https://github.com/emberjs/data/blob/master/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt;. Thank you to everyone who submitted
patches!&lt;/p&gt;

&lt;p&gt;While many bugs were stomped, some important changes are worth calling out:&lt;/p&gt;
&lt;h1 class='anchorable-toc' id='toc_possibly-breaking-deprecations'&gt;(Possibly) Breaking Deprecations&lt;/h1&gt;&lt;h2 class='anchorable-toc' id='toc_record-constructor-typekey-is-now-record-constructor-modelname'&gt;record.constructor.typeKey is now record.constructor.modelName&lt;/h2&gt;
&lt;p&gt;In Ember Data, when you ask for a model, Ember Data looks its class up using
Ember&amp;#39;s &lt;a href="http://guides.emberjs.com/v1.10.0/understanding-ember/dependency-injection-and-service-lookup/"&gt;Dependency Injection&lt;/a&gt; API.  When the model class is looked
up, Ember Data stores the type on the model class.&lt;/p&gt;

&lt;p&gt;For example, when the following code runs in your application:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; post = &lt;span class="local-variable"&gt;this&lt;/span&gt;.store.getById(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and Ember Data will store the string &amp;quot;post&amp;quot; on the model class:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;console.log(post.constructor.typeKey); &lt;span class="comment"&gt;// 'post'&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Ember Data uses this &lt;code&gt;typeKey&lt;/code&gt; property internally when creating and extracting
payloads in Serializers, and when locating models in Adapters. The &lt;code&gt;typeKey&lt;/code&gt; is
also currently available on Snapshots, which are passed to adapter and
serializer methods. &lt;code&gt;typeKey&lt;/code&gt; was previously always normalized to be a
camelCased string.&lt;/p&gt;

&lt;p&gt;In Ember Data 1.0.0-beta.18, this property is now called &lt;code&gt;modelName&lt;/code&gt;. In
addition, the &lt;code&gt;modelName&lt;/code&gt; is a dasherized string. For example, if you had a
model called &lt;code&gt;TacoShop&lt;/code&gt;, it would be stored on the model&amp;#39;s constructor&amp;#39;s
&lt;code&gt;modelName&lt;/code&gt; property as &lt;code&gt;taco-shop&lt;/code&gt;, whereas previously it would be stored as
&lt;code&gt;tacoShop&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Accessing the &lt;code&gt;typeKey&lt;/code&gt; property should still work, but will trigger
deprecation warnings.&lt;/p&gt;

&lt;p&gt;If you don&amp;#39;t have any custom serializers or adapters, you are good to go;
outgoing payloads and URLs shouldn&amp;#39;t change. If you&amp;#39;ve overridden a method in
your subclass, remember to call &lt;code&gt;this._super&lt;/code&gt;, or to normalize modelName in
your code. If you need to transform this string, you can use Ember.String&amp;#39;s
&lt;a href="http://emberjs.com/api/classes/Ember.String.html#method_camelize"&gt;camelize&lt;/a&gt; and &lt;a href="http://emberjs.com/api/classes/Ember.String.html#method_underscore"&gt;underscore&lt;/a&gt; functions. Keep in mind you
can&amp;#39;t change &lt;code&gt;modelName&lt;/code&gt; on the model&amp;#39;s constructor; it is &lt;strong&gt;read-only&lt;/strong&gt; and
will trigger an assertion error if you try to override it.&lt;/p&gt;

&lt;p&gt;We changed &lt;code&gt;typeKey&lt;/code&gt; to &lt;code&gt;modelName&lt;/code&gt; to allow us to align to dasherized strings
as Ember and Ember CLI also align with dasherized strings. Changing the name
allows us to make this change with a deprecation phase.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ds-restserializer-typeforroot-is-now-ds-restserializer-modelnamefrompayloadkey'&gt;DS.RESTSerializer.typeForRoot is now DS.RESTSerializer.modelNameFromPayloadKey&lt;/h2&gt;
&lt;p&gt;To gain more consistency in the naming change of  &lt;code&gt;typeKey&lt;/code&gt; to &lt;code&gt;modelName&lt;/code&gt;,
&lt;code&gt;typeForRoot&lt;/code&gt; has been renamed to &lt;code&gt;modelNameFromPayloadKey&lt;/code&gt;. The function
serves the same purpose, so this should be a quick refactor you can achieve via
search and replace in your project. While &lt;em&gt;calling&lt;/em&gt; typeForRoot will trigger a
deprecation warning, overriding in a subclass won&amp;#39;t.&lt;/p&gt;
&lt;h1 class='anchorable-toc' id='toc_new-features'&gt;New Features&lt;/h1&gt;&lt;h2 class='anchorable-toc' id='toc_ds-restserializer-payloadkeyfrommodelname'&gt;DS.RESTSerializer.payloadKeyFromModelName&lt;/h2&gt;
&lt;p&gt;While &lt;code&gt;modelNameFromPayloadKey&lt;/code&gt; returns a &lt;em&gt;model&lt;/em&gt; for a JSON payload key,
&lt;code&gt;payloadKeyFromModelName&lt;/code&gt; can be used to override the serialization of a model
&lt;em&gt;to the server.&lt;/em&gt; For instance, you may have a Post model, but your server
expects a &lt;code&gt;message&lt;/code&gt; as the root. You can override it like so:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/serializers/application.js&lt;/span&gt;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; DS.RESTSerializer.extend({
  &lt;span class="key"&gt;payloadKeyFromModelName&lt;/span&gt;: (modelName) {
    &lt;span class="keyword"&gt;if&lt;/span&gt; (modelName === &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) {
      &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;message&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;
    }
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;._super(modelName);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This would produce the following payload:&lt;/p&gt;
&lt;div class="highlight json "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;message&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: {
    &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;title&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Action Cable comes with 3 Months of Free HBO&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Another example is that ActiveModelSerializer uses this hook to convert a
dasherized &lt;code&gt;modelName&lt;/code&gt; to an &lt;code&gt;under_scored&lt;/code&gt; string.&lt;/p&gt;

&lt;p&gt;While this was possible previously in Ember Data, we noticed that users used
several different hooks to achieve this goal, so it made sense to make one
unifying place for this kind of serialization.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_store-unloadall-can-now-unload-all-models-when-not-passed-a-modelname'&gt;store.unloadAll() can now unload all models when not passed a modelName&lt;/h2&gt;
&lt;p&gt;Previously, &lt;code&gt;store.unloadAll&lt;/code&gt; required a &lt;code&gt;modelName&lt;/code&gt; argument to unload records
of a type.  Now, you can unload all records without calling &lt;code&gt;store.destroy&lt;/code&gt;.
Thanks to &lt;a href="https://github.com/emberjs/data/pull/2999"&gt;svox1&lt;/a&gt; for this pull
request!&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ds-restadapter-buildurl-refactored-into-different-hooks'&gt;DS.RESTAdapter.buildURL refactored into different hooks&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;buildURL&lt;/code&gt; has been refactored into several hooks like &lt;code&gt;urlForFindQuery&lt;/code&gt;. This
makes overriding methods like &lt;code&gt;buildURL&lt;/code&gt; easier to reason about and easier to
change without breaking other request types. Thanks to
&lt;a href="https://github.com/emberjs/data/pull/2966"&gt;thejameskyle&lt;/a&gt; for taking on this
refactor!&lt;/p&gt;

&lt;p&gt;While beta.17 did introduce a regression, this has been fixed in beta.18.&lt;/p&gt;

&lt;!-- Links --&gt;
</content>
  </entry>
  <entry>
    <title>Ember.js 1.12 and 1.13 Beta (Glimmer!) Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/13/ember-1-12-released.html"/>
    <id>http://emberjs.com/blog/2015/05/13/ember-1-12-released.html</id>
    <published>2015-05-12T19:00:00-05:00</published>
    <updated>2015-05-12T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We are please to announce the release of Ember.js 1.12 and the first beta in the 1.13 series.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.13 beta is the first Ember.js release that includes Glimmer, the new Ember
rendering engine, as well as the final batch of Ember 2.0 features.&lt;/strong&gt; We will...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We are please to announce the release of Ember.js 1.12 and the first beta in the 1.13 series.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.13 beta is the first Ember.js release that includes Glimmer, the new Ember
rendering engine, as well as the final batch of Ember 2.0 features.&lt;/strong&gt; We will
discuss those details more below.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features-in-ember-1-12'&gt;New Features in Ember 1.12&lt;/h2&gt;
&lt;p&gt;Ember 1.12 is a relatively light release, and includes features that move Ember
closer to ES6 class syntax and the first parts of the internal implementation
needed for a stable release of the FastBoot addon.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_new-computed-syntax'&gt;New Computed Syntax&lt;/h4&gt;
&lt;p&gt;Per &lt;a href="https://github.com/emberjs/rfcs/pull/11"&gt;RFC #11&lt;/a&gt;, Ember is introducing a
new syntax for computed properties. This change better aligns computed property
syntax with JavaScript getters and setters and makes writing settable computed
properties developer friendly.&lt;/p&gt;

&lt;p&gt;It also has the nice side effect of improving performance, as the old syntax,
with its two-in-one function signatures, was harder for JavaScript engines to
optimize.&lt;/p&gt;

&lt;p&gt;The simplest syntax for a computed property is to define the getter as a function:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,
  &lt;span class="key"&gt;goldenRatioWidth&lt;/span&gt;: Ember.computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.618&lt;/span&gt;;
  })

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is still the way to write simple getters, the most common use-case for
computed properties, in Ember 1.12.&lt;/p&gt;

&lt;p&gt;To create a settable computed property in Ember 1.11 an &lt;code&gt;if&lt;/code&gt; statement was used
to differentiate the get from the set logic. For example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,
  &lt;span class="key"&gt;goldenRatioWidth&lt;/span&gt;: Ember.computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;(key, value){
    &lt;span class="keyword"&gt;if&lt;/span&gt; (&lt;span class="local-variable"&gt;arguments&lt;/span&gt;.length &amp;gt; &lt;span class="integer"&gt;1&lt;/span&gt;) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, value / &lt;span class="float"&gt;1.618&lt;/span&gt;);
    } &lt;span class="keyword"&gt;else&lt;/span&gt; {
      &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.618&lt;/span&gt;;
    }
  })

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This syntax was functional but error-prone, verbose, and hard to understand
(for both humans and JavaScript engines).&lt;/p&gt;

&lt;p&gt;In Ember 1.12, you can nicely separate the getter and setter into two different
functions.&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,
  &lt;span class="key"&gt;goldenRatioWidth&lt;/span&gt;: Ember.computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, {
    get(key) {
      &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.618&lt;/span&gt;;
    },
    set(key, value) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, value / &lt;span class="float"&gt;1.618&lt;/span&gt;);
    }
  });

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This also aligns Ember&amp;#39;s API with JavaScript getters and setters, and
simplifies the path towards using JavaScript getters in Ember 2.0, after IE8
support is dropped.&lt;/p&gt;

&lt;p&gt;For more information see the initial implementation in &lt;a href="https://github.com/emberjs/ember.js/pull/9527"&gt;#9527&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Many thanks to &lt;a href="https://twitter.com/stefanpenner"&gt;@stefanpenner&lt;/a&gt; and
&lt;a href="https://twitter.com/MiguelCamba"&gt;@MiguelCamba&lt;/a&gt; for championing and shipping
this feature.&lt;/p&gt;

&lt;p&gt;One last thing: thanks to the experimental support for &lt;a href="https://github.com/wycats/javascript-decorators"&gt;JavaScript
decorators&lt;/a&gt; in Babel, we are also planning a further improvement in
the near future:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,

  &lt;span class="error"&gt;@&lt;/span&gt;computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
  get goldenRatioWidth(key) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.1618&lt;/span&gt;;
  }

  set goldenRatioWidth(key, value) {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, value / &lt;span class="float"&gt;1.618&lt;/span&gt;);
  }

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_instance-initializers'&gt;Instance Initializers&lt;/h4&gt;
&lt;p&gt;The next feature, instance initializers, makes it possible for FastBoot
applications to run many requests concurrently.&lt;/p&gt;

&lt;p&gt;Before FastBoot, you would only ever run applications one at a time. Even in
automated tests, tests were run one at a time, in serial, so one application
was destroyed before the next one was created.&lt;/p&gt;

&lt;p&gt;In FastBoot, it is important for a single node server to be able to serve
a second request while the first one is fetching its data.&lt;/p&gt;

&lt;p&gt;Thankfully, Ember already ensures that all state is stored in the container,
so in theory, all you need to do is give each request its own container
instance and you get concurrent requests in FastBoot.&lt;/p&gt;

&lt;p&gt;In practice, there was a minor API change we needed to make in order to
make it work involving initializers. In Ember 1.11, initializers would
run on app boot (or once per test). Some initializers were setting up
code (and injection rules), which are the same across all FastBoot requests,
while other initializers were creating instances, which are different
across requests.&lt;/p&gt;

&lt;p&gt;In Ember.js 1.12 application boot is separated into two phases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Application initializers run. At this phase of boot, the goal of initializers
should be to register dependencies and injections. These initializers are doing
work that is shared across all FastBoot requests, and therefore should not
create instances. This phase runs &lt;em&gt;once&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Instance initializers run next. This is the right time to do work that is
specific to each FastBoot request. You can create instances and modify their
state here. This phase runs when the browser application runs, for each
integration test, and for each FastBoot request.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The two-phase initialization process is safer when multiple addons may be
registering factories and injections.&lt;/p&gt;

&lt;p&gt;Ember-CLI 0.2.3 supports instance initializers. For example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/instance-initializers/sleep.js&lt;/span&gt;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;function&lt;/span&gt; &lt;span class="function"&gt;initialize&lt;/span&gt;(application) {
  application.deferReadiness();
  &lt;span class="comment"&gt;// Wait 3s before continuing to boot the app&lt;/span&gt;
  Ember.run.later(application, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;advanceReadiness&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;3000&lt;/span&gt;);
}

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; {
  &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;sleep&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;initialize&lt;/span&gt;: initialize
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To define an instance initializer in globals mode use the &lt;code&gt;Ember.Application.instanceInitializer&lt;/code&gt;
method. For more information about instance intializers see the
implementation in &lt;a href="https://github.com/emberjs/ember.js/pull/10256"&gt;#10256&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt;, &lt;a href="https://twitter.com/wycats"&gt;@wycats&lt;/a&gt; and
&lt;a href="https://twitter.com/dgeb"&gt;@dgeb&lt;/a&gt; for this feature and other
refactoring work around application initialization.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_initializer-context'&gt;Initializer Context&lt;/h4&gt;
&lt;p&gt;Previously, the &lt;code&gt;this&lt;/code&gt; scope of an initializer was simply the global scope.
&lt;a href="https://github.com/emberjs/ember.js/pull/10179"&gt;#10179&lt;/a&gt; changed initializer
scopes to be the initializer object itself.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/gf3"&gt;@gf3&lt;/a&gt; for suggesting and adding this feature.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ember-1-13-beta'&gt;Ember 1.13 Beta&lt;/h2&gt;
&lt;p&gt;And now, the big enchilada!&lt;/p&gt;

&lt;p&gt;Together with the release of Ember 1.12, we are releasing the first beta of Ember 1.13.&lt;/p&gt;

&lt;p&gt;Ember 1.13 is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the last minor release in the 1.x series&lt;/li&gt;
&lt;li&gt;the first release that includes the new &lt;strong&gt;Glimmer rendering engine&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Just to recap; what is Glimmer?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A new faster rendering engine that is especially fast at updates.&lt;/li&gt;
&lt;li&gt;An implementation of the React-inspired &amp;quot;just re-render it&amp;quot; programming model
for components, with one-way data flow by default and better enforcement for
data-down, actions-up.&lt;/li&gt;
&lt;li&gt;Supports angle-bracket components (&lt;code&gt;&amp;lt;my-component /&amp;gt;&lt;/code&gt;), ergonomic attributes
(&lt;code&gt;&amp;lt;my-link href=&amp;quot;{{url}}.html&amp;quot;&amp;gt;go home&amp;lt;/my-link&amp;gt;&lt;/code&gt;), that hews closely to HTML
syntax with a few small enhancements.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;#39;ll be writing a blog post that expands on the programming model of Ember 2.0
and talks about the most important new features in the next few days, and full
docs are coming as well.&lt;/p&gt;

&lt;p&gt;We&amp;#39;d like to give a big thank you to the entire community for all the nights and
weekends over the past few months getting Glimmer (&lt;a href="https://www.isemberfastyet.com"&gt;almost&lt;/a&gt;) over the
finish line. It&amp;#39;s inspiring.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_the-1-13-x-series'&gt;The 1.13.x Series&lt;/h4&gt;
&lt;p&gt;In most cases, you should expect Glimmer to be faster at both initial rendering
and updates. If you find performance regressions in idiomatic usage in your app,
we definitely want to hear about it. Please file bugs.&lt;/p&gt;

&lt;p&gt;The Glimmer rendering engine changes parts of Ember that have been largely
untouched since the days of SproutCore 2.0. In practice, this means that you
may be relying on implementation details of the pre-Glimmer implementation
that were not captured by tests, and that were not discovered during the
Canary period.&lt;/p&gt;

&lt;p&gt;Because of the magnitude of the internal change, we expect the first few
Ember 1.13 betas to be less stable than other betas in the 1.x series. &lt;strong&gt;We
need your help to find and fix compatibility regressions.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Please report any incompatibilities that you discover. We will investigate and
consider shimming any regression that affects a significant number of apps,
even if the root cause is a change in internal implementation details.&lt;/p&gt;

&lt;p&gt;We know that there will likely be some compatibility regressions, especially
in implementation details, that we do not catch during the 1.13 beta period.
We plan to continue to release point releases to the 1.13 series to fix
those details after 2.0 beta is released, and perhaps even for a while after
2.0 final is released.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Our goal is to ensure that most applications can upgrade to Ember 1.13.x,
remove deprecations, and then upgrade to Ember 2.0 with minimal fuss.&lt;/strong&gt; If
a significant number of apps that are earnestly trying to upgrade this way
cannot, we will continue to fix problems that are blocking upgrades.&lt;/p&gt;

&lt;p&gt;For an in-depth look into our transition plan for users with existing Ember 1.x
apps, please see the recent &lt;a href="http://emberjs.com/blog/2015/05/10/run-up-to-two-oh.html"&gt;Transition to Ember 2.0 in
Detail&lt;/a&gt; blog post.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_changelogs'&gt;CHANGELOGS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.12.0/CHANGELOG.md"&gt;Ember 1.12.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.13.0-beta.1/CHANGELOG.md"&gt;Ember 1.13.0-beta.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>The Transition to Ember 2.0 in Detail</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/10/run-up-to-two-oh.html"/>
    <id>http://emberjs.com/blog/2015/05/10/run-up-to-two-oh.html</id>
    <published>2015-05-09T19:00:00-05:00</published>
    <updated>2015-05-09T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;As we approach the eve of the release of Ember 1.13-beta, it's a good
time to talk about the transition plan for those of us who have Ember
1.11 and 1.12 applications.&lt;/p&gt;

&lt;p&gt;The high level:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ember 1.13-beta.1 will be released early this week. It will come...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;As we approach the eve of the release of Ember 1.13-beta, it&amp;#39;s a good
time to talk about the transition plan for those of us who have Ember
1.11 and 1.12 applications.&lt;/p&gt;

&lt;p&gt;The high level:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ember 1.13-beta.1 will be released early this week. It will come with the
new Glimmer engine and a series of new deprecations, preparing for
cruft removal in Ember 2.0.&lt;/li&gt;
&lt;li&gt;Ember 1.13 will ship with support for &lt;strong&gt;angle bracket components&lt;/strong&gt;,
which also serve as the opt-in for one-way data flow and the entirety
of the other React-inspired programming model improvements.&lt;/li&gt;
&lt;li&gt;We will continue to fix regressions caused by the Glimmer engine
throughout the 1.13 beta cycle.&lt;/li&gt;
&lt;li&gt;We plan to release Ember 2.0-beta.1 on June 12, as announced at
EmberConf.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;We will release a point release of Ember 1.13 (likely 1.13.1)
together with the release of Ember 2.0.&lt;/strong&gt; This release will continue
to fix regressions caused by the Glimmer engine, and help smooth the
transition to Ember 2.0.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;We will likely release additional point releases of Ember 1.13 to
help address unexpected difficulties in the transition to Ember 2.0.&lt;/strong&gt;
For the most part, this will likely include new deprecations with
light backporting of features needed to complete a transition away
from deprecated features in 1.13.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Glimmer engine represents the third phase of major performance work
on Ember in the past year (preceded by &lt;code&gt;metal-views&lt;/code&gt; in 1.8 and HTMLBars
in 1.10). Now that it&amp;#39;s landed, we&amp;#39;re going to move into the next phase
of major performance improvements. Expect to see more about that once
Ember 2.0 has shipped.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_dealing-with-glimmer-regressions'&gt;Dealing With Glimmer Regressions&lt;/h3&gt;
&lt;p&gt;We landed Glimmer in Canary, and given that it&amp;#39;s a completely rewritten
rendering engine, we&amp;#39;re quite happy with the results so far.&lt;/p&gt;

&lt;p&gt;That said, we expect to continue seeing compatibility fallout,
especially in heavily-used private APIs, over the next several months.&lt;/p&gt;

&lt;p&gt;As a result, &lt;strong&gt;we plan to continue releasing point releases in the 1.13
series as we learn about additional incompatibilities.&lt;/strong&gt; We will
continue to do this after Ember 2.0, to try to make sure that everyone
who wants to upgrade to Ember 1.13 and remove deprecations (as a
precursor to an Ember 2.0 upgrade) can do so.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_add-on-compatibility-and-private-apis'&gt;Add-On Compatibility and Private APIs&lt;/h3&gt;
&lt;p&gt;Ember 1.x add-ons quite often use private APIs. This was necessary for
many of the most ambitious add-ons (like Liquid Fire), and these add-ons
were a boon for Ember users.&lt;/p&gt;

&lt;p&gt;While Glimmer cannot maintain compatibility for every private API used
by add-ons, we are committed to helping existing add-ons find new
approaches that work post-Glimmer, ideally in the form of public APIs.&lt;/p&gt;

&lt;p&gt;We know that many Ember 1.x apps (including apps by members of the core
team) will not be able to upgrade to Ember 1.13 and Glimmer until
popular existing add-ons can support 1.13. We don&amp;#39;t plan to put the 1.13
series to bed until people with 1.12 apps who are trying to upgrade to
deprecation-free 1.13 in earnest can do so successfully.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_the-roll-out-of-new-features'&gt;The Roll Out of New Features&lt;/h2&gt;
&lt;p&gt;Over the past six months, we&amp;#39;ve talked about a lot of new features that
we plan to work on during this time-frame.&lt;/p&gt;

&lt;p&gt;Since the 1.8.0 release (October 2014), we landed a large chunk of the
features we started to talk about as precursors to 2.0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In Ember 1.13, we will land the last chunk of 2.0 precursor features,
including the Glimmer rendering engine and React-style data flow.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Glimmer rendering engine is fully backwards compatible with the
Ember 1.12 public API, and we continue to do work to ensure
compatibility with real-world apps and addons that are using popular
private APIs.&lt;/p&gt;

&lt;p&gt;The new data flow model, including one-way data flow by default,
separation of attributes from component state, opt-in mutable bindings,
and callback-style actions are all opt-in through the use of another big
new feature: &lt;strong&gt;angle-bracket components&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;We do not plan to remove curly-brace components (with their legacy
semantics) in Ember 2.0, &lt;strong&gt;so you can take your time upgrading your
components to the new semantics and still upgrade to Ember 2.0&lt;/strong&gt;. In the
sections that follow, I will lay out the most important changes and talk
about the transition path.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_2-0-precursor-features-already-landed-by-1-12'&gt;2.0 Precursor Features Already Landed By 1.12&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;elimination of metamorph tags&lt;/strong&gt; landed in Ember 1.8.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;metal-views&lt;/strong&gt; landed in Ember 1.8.0, providing full support for SVG
documents, including components in SVG.&lt;/li&gt;
&lt;li&gt;the &lt;strong&gt;HTMLBars&lt;/strong&gt; engine landed in 1.10, which prepared the codebase
for Glimmer&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;block params&lt;/strong&gt; and &lt;strong&gt;chained else&lt;/strong&gt; in templates landed in 1.10&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;services&lt;/strong&gt; landed in 1.10&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;curly attributes / elimination of &lt;code&gt;bind-attr&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;a
href=&amp;quot;{{src}}&amp;quot;&amp;gt;&lt;/code&gt;), the first big fruits of HTMLBars, landed in 1.11&lt;/li&gt;
&lt;li&gt;the &lt;strong&gt;dynamic {{component}} helper&lt;/strong&gt; landed in 1.11&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;instance initializers&lt;/strong&gt;, a precursor to FastBoot, landed in 1.12&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-1-13-and-the-glimmer-engine'&gt;Ember 1.13 and the Glimmer Engine&lt;/h3&gt;
&lt;p&gt;The Glimmer engine is shorthand for a whole bunch of new features. While
most of the public discussion has focused on performance, it also
integrates many of the programming model improvements pioneered by
React.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_one-way-values-by-default'&gt;One-Way Values By Default&lt;/h4&gt;
&lt;p&gt;First of all, starting in Ember 2.0, template bindings are one-way by
default. Because we know that it will take some time to refactor your
applications to explicitly opt-in to two-way bindings as needed, we have
decided to make this new behavior a consequence of opting in to new
angle-bracket components.&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;{{!-- title is a mutable two-way binding --}}&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;my-component&lt;/span&gt; &lt;span class="attribute-name"&gt;title&lt;/span&gt;=&lt;span class="attribute-value"&gt;model.name&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;

&lt;span class="comment"&gt;{{!-- title is just an (immutable) value --}}&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;my-component&lt;/span&gt; &lt;span class="attribute-name"&gt;title&lt;/span&gt;=&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;model.name&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt; &lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;At the moment, we have not yet decided when precisely to drop two-way
bindings by default, and whether to continue to include the support in a
plugin once we have dropped it. The specifics will depend largely on how
difficult the upgrade to angle-bracket components proves to be.&lt;/p&gt;

&lt;p&gt;We expect angle-bracket components to land as part of Ember 1.13 on June
12.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_fast-re-render'&gt;Fast Re-Render&lt;/h4&gt;
&lt;p&gt;In Ember 1.12, calling &lt;code&gt;rerender()&lt;/code&gt; on a component is an extremely
expensive operation, and blows away all of the existing DOM (together
with its internal state, such as selection, cursor, focus, scroll
position and more).&lt;/p&gt;

&lt;p&gt;In Ember 1.13, thanks to the Glimmer engine, you can safely invoke
&lt;code&gt;rerender()&lt;/code&gt; and it will only update the parts of the template that have
actually changed.&lt;/p&gt;

&lt;p&gt;This allows you to replace an entire data structure with a totally new
POJO, &lt;code&gt;rerender&lt;/code&gt; the component, and get highly performant updates that
preserve the DOM.&lt;/p&gt;

&lt;p&gt;As in React, if you modify a property on the component that is used in
the template (&amp;quot;state&amp;quot; in React), the component will be &lt;code&gt;rerendered()&lt;/code&gt;,
so the most common way to trigger a (fast) re-render is to set a
property on the component that is used by the component&amp;#39;s template.&lt;/p&gt;

&lt;p&gt;Notably, this model is quite similar to the binding model used in Ember
1.12, with some small changes that eliminate the possibility of creating
complex graphs of two-way bindings by accident.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_new-lifecycle-hooks'&gt;New Lifecycle Hooks&lt;/h4&gt;
&lt;p&gt;Instead of having to register observers on &amp;quot;bindings&amp;quot; and try to reflect
the changes into your DOM, which can be fairly error-prone and
confusing, Ember 1.13 introduces a series of new lifecycle hooks that
execute whenever a component&amp;#39;s attributes change.&lt;/p&gt;

&lt;p&gt;Attribute changes can happen either via observation, such as when a
service has changed, or through the data-down/actions-up data flow
pattern enabled by &lt;code&gt;component.rerender()&lt;/code&gt; and &lt;code&gt;component.set()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In Ember 1.12, you might write something like this:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Component.extend({
  didInsertElement() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.&lt;span class="predefined"&gt;$&lt;/span&gt;().button({
      &lt;span class="key"&gt;text&lt;/span&gt;: &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;value&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),
      &lt;span class="key"&gt;disabled&lt;/span&gt;: &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;disabled&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
    });
  },
  &lt;span class="key"&gt;valueDidChange&lt;/span&gt;: observer(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;value&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.&lt;span class="predefined"&gt;$&lt;/span&gt;().option(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;text&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;value&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;))
  }),

  &lt;span class="key"&gt;disabledDidChange&lt;/span&gt;: observer(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;disabled&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.&lt;span class="predefined"&gt;$&lt;/span&gt;().option(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;disabled&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;disabled&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;))
  })
})
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;One problem with this code is that the observer can fire at any time,
and it executes both when the value is changed from inside the component
and when it is changed from the outside.&lt;/p&gt;

&lt;p&gt;As we&amp;#39;ll see in the next section, conflating changes coming from the
inside with changes coming from the outside can make it difficult to
reason about the data flow, and makes it very easy for code in your
component to accidentally trigger observers that were intended for
changes coming from the &lt;em&gt;outside&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Starting with Ember 1.13, you will be able to express the same concept
more clearly:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Component.extend({
  didInsertElement() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.&lt;span class="predefined"&gt;$&lt;/span&gt;().button({
      &lt;span class="key"&gt;text&lt;/span&gt;: &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.value,
      &lt;span class="key"&gt;disabled&lt;/span&gt;: &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.disabled
    });
  },

  didUpdateElement() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.&lt;span class="predefined"&gt;$&lt;/span&gt;().options({
      &lt;span class="key"&gt;text&lt;/span&gt;: &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.value,
      &lt;span class="key"&gt;disabled&lt;/span&gt;: &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.disabled
    });
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A full description of the new lifecycle hooks will be included with the
documentation of Ember 1.13, but they will allow you to perform work in
response to a change in attributes both before and after rendering has
taken place. You will also be able to do work for initial render only,
for updates only, or both.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_the-code-attrs-code-property'&gt;The &lt;code&gt;attrs&lt;/code&gt; Property&lt;/h4&gt;
&lt;p&gt;As described above, conflating the attributes (values provided by the
component&amp;#39;s caller) with the component&amp;#39;s own state can cause confusion,
especially when combined with mutable attributes.&lt;/p&gt;

&lt;p&gt;In particular, a seemingly innocuous change to a piece of component
state can trigger a cascade of changes to child components, sibling
components, and even parent components.&lt;/p&gt;

&lt;p&gt;Beginning with angle-bracket components in Ember 1.13, a component&amp;#39;s
attributes will be available in &lt;code&gt;this.attrs&lt;/code&gt; rather than on the
component itself.&lt;/p&gt;

&lt;p&gt;So when a component is invoked this way:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;my-component&lt;/span&gt; &lt;span class="attribute-name"&gt;title&lt;/span&gt;=&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;model.name&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt; &lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The component will see &lt;code&gt;this.attrs.title&lt;/code&gt; as the current value of
&lt;code&gt;model.name&lt;/code&gt;. Whenever &lt;code&gt;model.name&lt;/code&gt; changes via observation, or when the
parent component is re-rendered, &lt;code&gt;my-component&lt;/code&gt;&amp;#39;s lifecycle hooks will
be triggered, and it will see a new version of &lt;code&gt;model.name&lt;/code&gt;.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_the-code-mut-code-helper'&gt;The &lt;code&gt;mut&lt;/code&gt; Helper&lt;/h4&gt;
&lt;p&gt;But what if you want to allow the child component to modify the property
explicitly.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;mut&lt;/code&gt; helper will produce an object that contains both a &lt;code&gt;value&lt;/code&gt;
property and an &lt;code&gt;update&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Imagine a component that will increment a &lt;code&gt;count&lt;/code&gt; property whenever the
component is clicked.&lt;/p&gt;

&lt;p&gt;You might write such a component this way in Ember 1.12:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;my-counter&lt;/span&gt; &lt;span class="attribute-name"&gt;count&lt;/span&gt;=&lt;span class="attribute-value"&gt;activatedCount&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// my-counter.js&lt;/span&gt;
&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Component.extend({
  &lt;span class="function"&gt;click&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;count&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;count&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="integer"&gt;1&lt;/span&gt;);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While this is fairly terse, the code in the component and its invocation
is fairly unclear.  While it is modifying a property in a parent
component, nothing about the JavaScript code makes that clear. And while
the code that invokes &lt;code&gt;my-counter&lt;/code&gt; is allowing its &lt;code&gt;activatedCount&lt;/code&gt;
property to be modified (which is rather unusual), nothing about the
invocation makes that clear.&lt;/p&gt;

&lt;p&gt;Especially in larger components, and when combined with an observer on
&lt;code&gt;count&lt;/code&gt;, the expected behavior can become quite obtuse and it can become
hard to follow the precise, expected data flow.&lt;/p&gt;

&lt;p&gt;In Ember 1.13, you can write the same component this way:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;my-counter&lt;/span&gt; &lt;span class="attribute-name"&gt;count&lt;/span&gt;=&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;mut&lt;/span&gt; &lt;span class="attribute-name"&gt;activatedCount&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt; &lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// my-counter.js&lt;/span&gt;
&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Component.extend({
  &lt;span class="function"&gt;click&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.count.update(&lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.count.value + &lt;span class="integer"&gt;1&lt;/span&gt;);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The call to &lt;code&gt;{{mut activatedCount}}&lt;/code&gt; packages up an object containing
both its current value and a callback that allows the receiving
component to modify it. There are only a handful of additional
characters, but the intent of the code is far clearer, both when the
component is invoked and when the component is updating the attribute.&lt;/p&gt;

&lt;p&gt;In other words, &lt;code&gt;{{mut}}&lt;/code&gt; just produces a regular JavaScript value that
contains both the current value and a way to update it. The lifecycle
hooks will fire at the same times as well.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_the-code-action-code-helper'&gt;The &lt;code&gt;action&lt;/code&gt; Helper&lt;/h4&gt;
&lt;p&gt;Finally, the behavior of actions in Ember 1.12 is quite magical. You
pass an action string into a component, and &lt;code&gt;sendAction&lt;/code&gt; triggers the
action in the environment that provided the string.&lt;/p&gt;

&lt;p&gt;Frustratingly, it is impossible to pass a component that wants to
trigger an action an alternative function, because actions are strings,
not functions.&lt;/p&gt;

&lt;p&gt;Even in Ember 1.12, you can always pass a function into a component, but
if you simply do something like: &lt;code&gt;&amp;lt;my-component on-playing={{actions.playing}} /&amp;gt;&lt;/code&gt;,
the &lt;code&gt;this&lt;/code&gt; in the function will be wrong (you want it to be the
component). In addition, you want a way to pass arguments into the
function (i.e. &amp;quot;&lt;a href="https://en.wikipedia.org/wiki/Currying"&gt;currying&lt;/a&gt;&amp;quot;).&lt;/p&gt;

&lt;p&gt;Starting in Ember 1.13, a new &lt;code&gt;action&lt;/code&gt; helper provides you with a way to
do both of these things:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;{{!-- parent-component --}}&lt;/span&gt;

&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt; &lt;span class="attribute-name"&gt;users&lt;/span&gt; &lt;span class="attribute-name"&gt;as&lt;/span&gt; &lt;span class="error"&gt;|&lt;/span&gt;&lt;span class="attribute-name"&gt;user&lt;/span&gt;&lt;span class="error"&gt;|&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;big-button&lt;/span&gt; &lt;span class="attribute-name"&gt;on-active&lt;/span&gt;=&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;action&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;selectedUser&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt; &lt;span class="attribute-name"&gt;user&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt; &lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;

  &lt;span class="comment"&gt;{{!-- equivalent --}}&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;big-button&lt;/span&gt; &lt;span class="attribute-name"&gt;on-active&lt;/span&gt;=&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;action&lt;/span&gt; &lt;span class="attribute-name"&gt;actions.selectedUser&lt;/span&gt; &lt;span class="attribute-name"&gt;user&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt; &lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// parent-component.js&lt;/span&gt;
&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Component.extend({
  &lt;span class="key"&gt;actions&lt;/span&gt;: {
    selectedUser(user) {
      &lt;span class="comment"&gt;// this is the component&lt;/span&gt;
      &lt;span class="comment"&gt;// user is the user from the current iteration of the loop&lt;/span&gt;
    }
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// big-button.js&lt;/span&gt;
&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Component.extend({
  &lt;span class="function"&gt;click&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs[&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;on-active&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;]();
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Because &lt;code&gt;big-button&lt;/code&gt; is simply invoking a function, the invoking
component can provide whatever function it wants.&lt;/p&gt;

&lt;p&gt;Another nice touch, &lt;code&gt;action&lt;/code&gt; works seamlessly with &lt;code&gt;mut&lt;/code&gt;. This means
that from the component&amp;#39;s perspective, it&amp;#39;s just calling a callback, but
the code that calls the component can easily pass in a callback that
updates one of its values.&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;my-text&lt;/span&gt; &lt;span class="attribute-name"&gt;on-enter&lt;/span&gt;=&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;action&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;pressedEnter&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt; &lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;my-text&lt;/span&gt; &lt;span class="attribute-name"&gt;on-enter&lt;/span&gt;=&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;action&lt;/span&gt; &lt;span class="error"&gt;(&lt;/span&gt;&lt;span class="attribute-name"&gt;mut&lt;/span&gt; &lt;span class="attribute-name"&gt;currentText&lt;/span&gt;&lt;span class="error"&gt;)&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt; &lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// my-text.js&lt;/span&gt;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Component.extend({
  keyUp(event) {
    &lt;span class="keyword"&gt;if&lt;/span&gt; (event.which === &lt;span class="integer"&gt;13&lt;/span&gt;) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs[&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;on-enter&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;](&lt;span class="local-variable"&gt;this&lt;/span&gt;.&lt;span class="predefined"&gt;$&lt;/span&gt;().val());
    }
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case, &lt;code&gt;this.attrs[&amp;#39;on-enter&amp;#39;]&lt;/code&gt; is simply a function. The
&lt;code&gt;action&lt;/code&gt; helper packages up a method in the component&amp;#39;s &lt;code&gt;actions&lt;/code&gt; hash,
currying &lt;code&gt;this&lt;/code&gt; (and other arguments). It also converts a &lt;code&gt;mut&lt;/code&gt; object
into a function that can be invoked.&lt;/p&gt;

&lt;p&gt;A component that wishes to support mutable bindings as actions need only
invoke the callback with a new value. Actions from the &lt;code&gt;actions&lt;/code&gt; hash,
and even regular functions passed as &lt;code&gt;on-enter={{func}}&lt;/code&gt; will work just
fine.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_routeable-components'&gt;Routeable Components&lt;/h3&gt;
&lt;p&gt;Finally, routeable components are under active development, but there is
still some uncertainty about precisely when they will land.&lt;/p&gt;

&lt;p&gt;The complete feature has two parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The ability to fully define query parameters outside the controller
(in the route). Alex Matchneer and Trek Glowacki are actively working
on this feature.&lt;/li&gt;
&lt;li&gt;The ability to have a route dispatch directly to a component, rather
than to a controller and a template. Erik Bryn is actively working on
this feature.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We intend to land both of these parts in the 1.x series, but there is a
good chance that they will land in 1.13.1, which will be released in
parallel with 2.0-beta. As I said in the beginning of this post, we will
likely backport a few features to the 1.13.x series in order to ease the
transition. Because of the proximity to Ember 2.0 and the impact of this
change on the programming model, routable components are a good
candidate for backporting.&lt;/p&gt;

&lt;p&gt;Whenever we land these features precisely, we are committed to making
sure that there is a clear way to upgrade to the last point release of
1.13, clear all deprecations, and then painlessly upgrade to 2.0.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_conclusion'&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Now that we have landed the Glimmer engine, we will be focusing our
energy over the next few months on the release of Ember 2.0-beta on June
12 and Ember 2.0 final on July 24.&lt;/p&gt;

&lt;p&gt;The 1.13 release is the final minor version in the 1.x series. In order
to aid the transition to Ember 2.0, we plan to release several point
releases of 1.13 (1.13.1, 1.13.2, etc.) that will attempt to fix
regressions caused by Glimmer and do some light backporting of features
that will aid in the transition.&lt;/p&gt;

&lt;p&gt;Note that Glimmer itself implemented the full Ember 1.x test suite, so
many of the regressions are simple bugs, related to untested features,
or related to private APIs. Based on experience over the past week
attempting to integrate Canary into existing applications, we feel
relatively optimistic about the plan of record for Ember 2.0, and where
we are in the process.&lt;/p&gt;

&lt;p&gt;For obvious reasons (the recent merge of Glimmer), Ember 1.13-beta will
be an unusually unstable beta release, but we are hopeful that the
release of Ember 1.13.0 on June 12 will have shaken out the bulk of any
problems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If you have an app, the best thing you can do right now to help is try
to upgrade it to Canary.&lt;/strong&gt; Not all add-ons work yet, but that gap is
closing every day, and the more information we can uncover through
real-app testing, the faster this will go.&lt;/p&gt;

&lt;p&gt;I would like to thank the whole Ember community for your enthusiasm and
effort around the Ember 2.0 release. Maintaining a focus on
compatibility while making major changes is hard, but well worth it.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s make this happen!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Glimmer's In Canary, Test Your Apps!</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/05/glimmer-merging.html"/>
    <id>http://emberjs.com/blog/2015/05/05/glimmer-merging.html</id>
    <published>2015-05-04T19:00:00-05:00</published>
    <updated>2015-05-04T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;After months of work, &lt;strong&gt;Glimmer is landing in Canary today&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What this means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The test suite passes.&lt;/li&gt;
&lt;li&gt;We have tested Glimmer on our own apps, and, for the most part, apps boot and
run correctly.&lt;/li&gt;
&lt;li&gt;There are still known issues (see below), including with...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;After months of work, &lt;strong&gt;Glimmer is landing in Canary today&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What this means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The test suite passes.&lt;/li&gt;
&lt;li&gt;We have tested Glimmer on our own apps, and, for the most part, apps boot and
run correctly.&lt;/li&gt;
&lt;li&gt;There are still known issues (see below), including with the test helpers.&lt;/li&gt;
&lt;li&gt;At this point, we need community help to identify compatibility issues not
covered by the test suite.&lt;/li&gt;
&lt;li&gt;We expect to continue improving compatibility with the pre-Glimmer engine for
some time, as new issues come to light.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Glimmer is the new rendering engine the Ember community has been working on for
the past several months. It is the first ground-up change to the templating
engine since SproutCore 2.0, and takes advantage of the groundwork laid by
HTMLBars to dramatically improve re-rendering performance. It also sets the
stage for more performance improvements during the 2.x series, and
React-inspired improvements to the Ember programming model. Best of all, we are
landing Glimmer in Ember 1.13, compatible with the full public API of Ember
1.x.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s also worth noting that while our apps feel faster, not every
performance benchmark will necessarily show marked improvement. There
will be more on this below, but the Glimmer refactor focused primarily
on dramatic improvements to re-rendering performance and programming
model improvements.&lt;/p&gt;

&lt;p&gt;Initial render of component-heavy pages shows some improvement in most
of our tests, but you should expect to see the biggest improvements when
re-rendering lists, especially when you are not using deprecated
functionality.&lt;/p&gt;

&lt;p&gt;Once we land Glimmer, you will probably see a variety of different
benchmarks testing various aspects of Ember. We expect to see benchmarks
showing that there are still pathologically slow scenarios in Ember,
especially in areas that we did not focus on improving. We expect to
continue to improve performance across Ember throughout the 2.x series,
and discuss that more below.&lt;/p&gt;

&lt;p&gt;Also note that while we took great pains to support features present in
Ember 1.12 (including many long-deprecated features), that compatibility
often comes with significant performance costs. In some cases, seemingly
similar constructs (e.g. &lt;code&gt;{{#each posts as |post|]}&lt;/code&gt; vs. &lt;code&gt;{{#each posts
itemController=&amp;#39;post&amp;#39; as |post|}}&lt;/code&gt;) have significantly different
internal implementation, and the Ember 2.0 version has vastly better
performance.&lt;/p&gt;

&lt;p&gt;Finally, there will be an upcoming guide in the next week or so that
describes the new features of the Glimmer engine (&lt;code&gt;attrs&lt;/code&gt;, new lifecycle
hooks, keys in &lt;code&gt;#each&lt;/code&gt;), but at the moment we are focusing on
compatibility with 1.x and testing the 1.x API with existing
applications.&lt;/p&gt;

&lt;p&gt;Please follow these instructions to test Ember-CLI apps with Canary:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ember-cli.com/#using-canary-build-instead-of-release"&gt;http://www.ember-cli.com/#using-canary-build-instead-of-release&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_known-issues'&gt;Known Issues&lt;/h2&gt;
&lt;p&gt;There are several known issues that you should consider when evaluating
Glimmer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There are still a few memory leaks that we have identified and are
quickly addressing.&lt;/li&gt;
&lt;li&gt;The concept of &lt;code&gt;controller&lt;/code&gt; in templates and actions in Ember 1.x was
fairly nuanced. Glimmer started with a simpler model and layered
compatibility on top. There are known gaps in the compatibility layer
that we are still addressing.&lt;/li&gt;
&lt;li&gt;There are still a number of issues in the testing helpers (especially
the faux unit tests that use &amp;quot;isolated containers&amp;quot;) that are causing
apps that work correctly to fail tests. We are working to fix the test
helpers, and should have that work done before we release 1.13 beta.&lt;/li&gt;
&lt;li&gt;There are likely a number of not-yet-known compatibility issues in
Glimmer. You should assume that the vast majority of issues you
encounter when testing Glimmer over the next few weeks will be addressed
before the final release.&lt;/li&gt;
&lt;li&gt;The compatibility layer is quite slow in some areas, making the
overall Glimmer engine slower than we would like. We have plans to
improve overall performance through the canary and beta cycle, and
then of course in the 2.0 release cycle.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In general, the Glimmer effort was an attempt to improve
re-rendering performance, especially in large lists.&lt;/strong&gt; It also laid
the groundwork for significant performance work in initial render and
throughout the framework, but that work is not yet done. Expect to see
continued performance improvements in Ember throughout the 2.x cycle
as a result of this change.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The most critical of these caveats should be addressed before we release 1.13
beta, and we expect to continue work on the remaining issues throughout the
1.13 beta cycle.&lt;/p&gt;

&lt;p&gt;Because of the magnitude of this change, and the proximity to the Ember 2.0
&amp;quot;cruft removal&amp;quot; pass, we plan to aggressively fix reported bugs during the 1.13
beta period. There will be another post describing our 1.13 and 2.0 release
plans with more precision in the next few weeks.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_performance-gains'&gt;Performance Gains&lt;/h2&gt;
&lt;p&gt;The biggest performance gains in Glimmer come from moving to a simpler
rendering model, built on top of HTMLBars.&lt;/p&gt;

&lt;p&gt;First, this allowed us to remove &lt;strong&gt;all&lt;/strong&gt; internal views for constructs
like &lt;code&gt;{{foo}}&lt;/code&gt;, &lt;code&gt;{{#if bar}}&lt;/code&gt; and even in &lt;code&gt;{{#each posts as |post|}}&lt;/code&gt;.
This view removal has an impact on initial render, because these
constructs are very common in real-world templates.&lt;/p&gt;

&lt;p&gt;Second, as we have discussed extensively, this allows us to
significantly improve the performance of re-rendering, which makes it
practical to re-render lists with entirely new arrays with very good
performance. Previously, achieving reasonable performance was very
difficult, and even when possible, came with significant bookkeeping
overhead.&lt;/p&gt;

&lt;p&gt;Interestingly, we have found that when testing real apps, the
performance gains are much more widespread than we expected, in large
part because of the simplification of the overall model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Glimmer&amp;#39;s performance in real applications has pleasantly surprised
us, exceeding the improvements we&amp;#39;ve seen in benchmarks designed to
stress-test pathological cases.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When upgrading to Glimmer, please pay special attention to the
real-world performance of your application &lt;strong&gt;in production mode&lt;/strong&gt; and
after clearing any deprecations with performance warnings.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_deprecated-features'&gt;Deprecated Features&lt;/h2&gt;
&lt;p&gt;Throughout the 1.x series, Ember has deprecated features we intended to
remove in 2.0. That process has continued with Ember 1.13, which will
contain Glimmer.&lt;/p&gt;

&lt;p&gt;However, it&amp;#39;s worth noting that Glimmer is the first major change to
many parts of the view layer since SproutCore 2! As a result,
perfect compatibility, especially in private APIs, was more
challenging.&lt;/p&gt;

&lt;p&gt;During the process of building Glimmer, we found various semantics of
&amp;quot;controller&amp;quot;s to be the most challenging. For the most part, this is
because the concept of controller has a number of different meanings
depending on context (routes, &lt;code&gt;{{render}}&lt;/code&gt;, &lt;code&gt;{{#each posts
itemController=&amp;#39;post&amp;#39;}}&lt;/code&gt;, &lt;code&gt;{{#each posts itemController=&amp;#39;post&amp;#39; as
|post|}}&lt;/code&gt;, &lt;code&gt;{{#with someController}}&lt;/code&gt;, etc.).&lt;/p&gt;

&lt;p&gt;Controllers and components both manage a template&amp;#39;s &amp;quot;context&amp;quot; (called
&amp;quot;self&amp;quot; in Glimmer) and serve as a target for actions. Mirroring these
semantics, which are effectively derived from implementation details of
Ember 1.x&amp;#39;s rendering engine, has been a challenge. We&amp;#39;re confident they
are very close, but encourage you to open an issue if they have changed.&lt;/p&gt;

&lt;p&gt;Glimmer, through HTMLBars, has a much clearer concept of &amp;quot;scope&amp;quot;, and
features like &lt;code&gt;{{yield}}&lt;/code&gt; work directly with that scope object. We were
able to get the Ember test suite passing by implementing the old
semantics on top of the new scope concept, but &lt;strong&gt;we are aware that we
have gaps in our implementation.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Please let us know if you find controller semantics that we have
implemented incorrectly. Bug reports would help, JSBins would help more,
and pull requests with failing tests would help even more.&lt;/p&gt;

&lt;p&gt;Finally, for the best experience with Glimmer, you should try to move
your application away from &lt;code&gt;itemController&lt;/code&gt;, &lt;code&gt;{{render}}&lt;/code&gt; and other
constructs that manipulate the controller from the template. We know
that this is not always possible (our applications all still make
use of some cases of these features),  which is why we worked so hard on
compatibility.&lt;/p&gt;

&lt;p&gt;That said, you&amp;#39;ll get better performance and a quicker upgrade path to
2.0 if you work on eliminating uses of these features soon. Implementing
them correctly added enough complexity that we will want to move
somewhat aggressively in 2.x to enable us to further improve
performance.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Internet Explorer 8 Support Will Be Removed in Ember 2.0</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/04/20/ie8-support-update.html"/>
    <id>http://emberjs.com/blog/2015/04/20/ie8-support-update.html</id>
    <published>2015-04-19T19:00:00-05:00</published>
    <updated>2015-04-19T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;After reviewing &lt;a href="https://github.com/emberjs/rfcs/pull/45"&gt;this thread&lt;/a&gt;, it seems clear that the vast majority of
Ember users who have responded, including people working at large
corporations, are comfortable with dropping IE8 support in Ember 2.0.
On the other hand, while there is enormous...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;After reviewing &lt;a href="https://github.com/emberjs/rfcs/pull/45"&gt;this thread&lt;/a&gt;, it seems clear that the vast majority of
Ember users who have responded, including people working at large
corporations, are comfortable with dropping IE8 support in Ember 2.0.
On the other hand, while there is enormous support for dropping IE9
support as well, a number of people still rely on support for IE9, and
the benefits of dropping IE9 in Ember 2.0 are not as strong.&lt;/p&gt;

&lt;p&gt;After reviewing discussion on the RFC proposal, many in-person conversations with Ember
users in large companies, and reviewing the private data sent to us via
email, we have decided that Ember 2.0 will support IE9+.&lt;/p&gt;

&lt;p&gt;So how are we going to manage this transition, and what should you do
if your business still requires IE8 support for the time being?&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_1-13-with-extended-browser-support'&gt;1.13 with Extended Browser Support&lt;/h2&gt;
&lt;p&gt;The core team will continue to periodically release point releases in
the 1.13 series to patch security bugs and browser compatibility
issues, including issues in IE8.&lt;/p&gt;

&lt;p&gt;No new features will be added, and we should be clear that we do not
intend people to stay on this release unless they must support IE8. Our
Semantic Version guarantees mean that the vast majority of the
community should migrate to the 2.x series as soon as possible.&lt;/p&gt;

&lt;p&gt;It is important to note that Ember 1.13 will come with deprecation
warnings for everything that we will break in Ember 2.0. As a result,
if you are running Ember 1.13 without any deprecation warnings, you
should be able to easily upgrade to Ember 2.0. And because of the
Semantic Versioning guarantees in the Ember 2.x series, it should be
relatively simple to upgrade from Ember 1.13 to the most recent version
of Ember 2.x when you are able to drop IE8 support.&lt;/p&gt;

&lt;p&gt;For example, imagine you build the Ember app for Big Widget Enterprise
Co. that requires IE8 support. You upgrade to 1.13 (the last release in
the 1.x series) and, over time, refactor code to eliminate all
deprecation warnings. Periodically, you apply 1.13 patch releases to
maintain browser compatibility and to fix potential security issues.&lt;/p&gt;

&lt;p&gt;Then, in April of 2016, management decides that enough customers have
moved off IE8 that you no longer need to support it. At that time,
Ember 2.6 will be the most recent stable release. Because 1.13 without
deprecation warnings is forwards-compatible with Ember 2.6, you can
upgrade from 1.13 to 2.6 with little hassle.&lt;/p&gt;

&lt;p&gt;With the integration of Ember CLI and Ember Data into the Semantic
Versioning guarantees, many of your dependencies will follow a similar
upgrade path.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ecosystem'&gt;Ecosystem&lt;/h2&gt;
&lt;p&gt;Of course, the above guarantees only apply to Ember, Ember Data, Ember
CLI, and the rest of the core-supported packages. Addon authors are
free to define their own support matrices. We encourage those who
depend on older browsers to contribute back by submitting PRs to the
addons they use with compatibility patches. Likewise, we encourage
authors of existing addons to work with users to offer a browser
compatibility matrix as close to the core projects as possible.&lt;/p&gt;

&lt;p&gt;If you require support for IE8 (and as a result, Ember 1.13), make sure
to make your voice heard across the addon ecosystem.&lt;/p&gt;

&lt;p&gt;That said, you should expect that new addons that come out after Ember
2.0 will not target Ember 1.13, and you should factor that into your
decision to remain on the 1.13 Extended Browser Support release of
Ember.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_fastboot'&gt;FastBoot&lt;/h2&gt;
&lt;p&gt;FastBoot, our effort to bring server-side rendering to all Ember apps,
is designed to offer even users with slow, low-feature browsers a fast
experience. While most people think of this as a benefit to mobile
users, IE8 certainly qualifies as a slow, low-feature browser.&lt;/p&gt;

&lt;p&gt;Because Ember applications are written &amp;quot;route first&amp;quot;, any idiomatic
Ember content app that uses links as the primary mode of navigation
will be able to provide a passable experience for users with an
unsupported version of JavaScript, or no JavaScript at all.&lt;/p&gt;

&lt;p&gt;It is worth noting that FastBoot, in the medium term, will have good
support for read-only content sites. However, while it is possible to
support forms pretty easily, forms without JavaScript (using cookie
authentication) introduce the prospect of CSRF attacks. A good solution
for FastBoot forms that is also secure is probably a longer-term
project. We would encourage the community to experiment with a secure
approach to forms that works with FastBoot.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_jquery-compatibility'&gt;jQuery Compatibility&lt;/h2&gt;
&lt;p&gt;In our RFC, we mentioned that dropping IE8 will give us the opportunity
to remove jQuery as a strict dependency. We should have been clearer
that we have no intent to remove the Ember APIs that delegate to jQuery
(such a Ember.$ and this.$() inside components).&lt;/p&gt;

&lt;p&gt;Because these APIs will remain in 2.0, both for ease of upgrade and
because we have not yet made the jQuery dependency optional, Semantic
Versioning prohibits us from removing them until at least Ember 3.0.&lt;/p&gt;

&lt;p&gt;On a personal note, we rely on jQuery heavily in our own apps. We think
it&amp;#39;s a great library that remains hugely valuable to smooth over clunky
DOM APIs and browser quirks (even in modern browsers). For those users
who need the absolute smallest payload size, we don&amp;#39;t want to saddle
you with a dependency that you don&amp;#39;t need. But we expect the majority
of users to continue using jQuery, and we have no plans to remove the
Ember/jQuery integration at this time.&lt;/p&gt;

&lt;p&gt;Thank you again for everyone who took the time to help us make this
decision, and thank you so much for being a part of the Ember
community.&lt;/p&gt;
</content>
  </entry>
</feed>
