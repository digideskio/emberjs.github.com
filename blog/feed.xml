<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember Blog</title>
  <subtitle>Ember News and Updates</subtitle>
  <id>http://emberjs.com/blog</id>
  <link href="http://emberjs.com/blog"/>
  <link href="http://emberjs.com/blog/feed.xml" rel="self"/>
  <updated>2015-08-12T20:00:00-04:00</updated>
  <author>
    <name>Ember</name>
  </author>
  <entry>
    <title>Ember.js 2.0 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/08/13/ember-2-0-released.html"/>
    <id>http://emberjs.com/blog/2015/08/13/ember-2-0-released.html</id>
    <published>2015-08-12T20:00:00-04:00</published>
    <updated>2015-08-12T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember 2.0 is not a traditional major release. After thirteen point releases in
almost two years, we're taking a turn to focus entirely on sweeping out
built-up cruft as a foundation for continued progress.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 2.0 only removes features that were...&lt;/strong&gt;&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Ember 2.0 is not a traditional major release. After thirteen point releases in
almost two years, we&amp;#39;re taking a turn to focus entirely on sweeping out
built-up cruft as a foundation for continued progress.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 2.0 only removes features that were deprecated as of Ember 1.13, so
apps that run on Ember 1.13 without any deprecation warnings should run
without issues on Ember 2.0.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;New applications should begin using Ember 2.0 today. Apps requiring Ember-Data
should use Ember-Data 2.0.0-beta.1 (2.0 release coming shortly!).&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_new-features-in-ember-js-2-0'&gt;New Features in Ember.js 2.0&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;&amp;lt;This space intentionally left blank!&amp;gt;&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Major releases of most libraries try to do two things. They introduce new APIs,
and remove deprecated ones. Our release focuses on doing one thing well:
&lt;strong&gt;Instead of introducing new features, the goal of Ember 2.0 is to remove
accumulated cruft.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since Ember 1.0, adherence to semantic versioning has helped us grow an amazing
community. Ember powers extremely ambitious applications, and most of those
applications have been able to move forward over 13+ releases as new features
arrived.&lt;/p&gt;

&lt;p&gt;We are committed to giving every Ember codebase a path into 2.x. To ensure
this, we&amp;#39;ve flagged everything removed in 2.0 with a deprecation in the 1.x
series. &lt;strong&gt;If your app runs on Ember 1.13 without raising deprecations, it
should run on 2.0.&lt;/strong&gt; There are no new features to adapt to or adopt.&lt;/p&gt;

&lt;p&gt;In the first few releases in Ember 2.x, we plan to land a variety of exciting
features. We are all the more excited that thousands of existing apps will be
ready to use them immediately. More about this below.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_removed-apis'&gt;Removed APIs&lt;/h4&gt;
&lt;p&gt;Internally, we&amp;#39;ve taken to calling Ember 2.0 a &amp;quot;garbage collection&amp;quot; release.
Two years is a lot of framework development, and there are many things dropped
in today&amp;#39;s release.&lt;/p&gt;

&lt;p&gt;Developers migrating forward will find these resources helpful:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;a href="http://emberjs.com/deprecations/v1.x/"&gt;1.x Deprecation Guide&lt;/a&gt; contains
a summary and migration path for many deprecations since Ember 1.7.
Additionally, this guide is linked to from deprecation messages in your
browser&amp;#39;s console.&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/emberjs/ember-inspector#ember-inspector-"&gt;Ember Inspector&lt;/a&gt;
is an essential tool for debugging Ember apps, and provides some tooling for
managing deprecations.&lt;/li&gt;
&lt;li&gt;Core team members &lt;a href="https://twitter.com/rwjblue"&gt;Robert Jackson&lt;/a&gt; and
&lt;a href="https://twitter.com/mixonic"&gt;Matthew Beale&lt;/a&gt; published the
&lt;a href="https://github.com/mixonic/ember-cli-deprecation-workflow"&gt;ember-cli-deprecation-workflow&lt;/a&gt;
addon in July. This tool helps to manage upgrades to your codebase through
deprecation messages. Watch Robert present on upgrade workflows in this
&lt;a href="https://www.youtube.com/watch?v=ltzN4v-ymo4&amp;amp;feature=youtu.be&amp;amp;t=1h25m55s"&gt;NYC meetup video&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;a href="https://github.com/rwjblue/ember-debug-handlers-polyfill"&gt;ember-debug-handlers-polyfill&lt;/a&gt;
addon provides a future-safe API for writing your own upgrade tooling.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some of the major API removals follow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Views&lt;/strong&gt; have been removed in Ember 2.0. Components, which provide better
isolation and scoping semantics, fulfill the use-cases views were introduced
for.&lt;/p&gt;

&lt;p&gt;We recognize that existing apps will not complete their migration away from
views for several months, so we have published the
&lt;a href="https://github.com/emberjs/ember-legacy-views"&gt;ember-legacy-views&lt;/a&gt;
compatibility addon, that will allow you to spread out the transition over more
releases. We are committed to maintain support for this addon until at least
Ember 2.6.&lt;/p&gt;

&lt;p&gt;If you are building a new application, the use-case for views have completely
been subsumed by Components. Existing apps should refactor away from the
&lt;code&gt;{{view}}&lt;/code&gt; helper and &lt;code&gt;Ember.View&lt;/code&gt;s in favor of Components.&lt;/p&gt;

&lt;p&gt;However, existing applications that make use of top-level Views do not need to
immediately refactor those views to components. The future Routable Components
will provide a softer transition path for this use-case and we commit to
support the compatibility addon until the community has had a chance to
transition to Routable Components.&lt;/p&gt;

&lt;p&gt;Similarly, the use-cases for &lt;strong&gt;Controllers&lt;/strong&gt; have largely been eliminated.&lt;/p&gt;

&lt;p&gt;As with views, we have published the
&lt;a href="https://github.com/emberjs/ember-legacy-controllers"&gt;ember-legacy-controllers&lt;/a&gt;
compatibility addon that you can use to spread out the transition. This addon
will also be maintained until at least Ember 2.6.&lt;/p&gt;

&lt;p&gt;If you are building a new application, you should almost never need controllers
except to manage query parameters and communicate with the route (ala
&lt;code&gt;transitionTo&lt;/code&gt;). For these cases, Ember 2.0 retains support for top-level
controllers with no addon required. While we plan to completely replace these
use-cases during the 2.x series, everything that works without the
compatibility addon will continue to work until 3.0.&lt;/p&gt;

&lt;p&gt;Existing applications should refactor away from using the &lt;code&gt;{{controller}}&lt;/code&gt;
property, use of proxying controllers (&lt;code&gt;ArrayController&lt;/code&gt; and
&lt;code&gt;ObjectController&lt;/code&gt;), &lt;code&gt;itemController&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;However, existing applications that make use of top-level Controllers do not
need to immediately eliminate those controllers. As with top-level views, the
future Routable Components will provide a softer transition for this use-case
and we commit to support the compatibility addon until the community has had a
chance to transition to Routable Components.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ReduceComputed and ArrayComputed&lt;/strong&gt; have been made obsolete by the Glimmer
rendering engine introduced in Ember 1.13. These APIs allowed array operations
to be performed without creating new arrays. Glimmer&amp;#39;s value diffing makes this
unnecessary. Computed property macros that operate on arrays are still present,
but they are simply not backed by &lt;code&gt;ReduceComputed&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Context shifting in templates&lt;/strong&gt; (&lt;code&gt;{{#each}}&lt;/code&gt; and &lt;code&gt;{{#with}}&lt;/code&gt; without block
params) is removed in Ember 2.0. For any template, there is now only one this
and it cannot be changed for part of that template by any helper. This makes
templates easier to reason about, and unlocks opportunities for performance
improvements.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IE8 support&lt;/strong&gt; has been dropped for Ember 2.0. For the 2.x series, IE9+ will
be supported.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Legacy Handlebars helpers&lt;/strong&gt; are removed in favor of the &lt;code&gt;Ember.Helper&lt;/code&gt; API.
This API does not provide a mechanism for helpers to take a block, but does
introduce support for nested helpers which can be used in concert with built-in
helpers (like &lt;code&gt;{{#if}}&lt;/code&gt; and &lt;code&gt;{{#each}}&lt;/code&gt;) to achieve the same ends.&lt;/p&gt;

&lt;p&gt;Please see the &lt;a href="https://github.com/emberjs/ember.js/blob/stable/CHANGELOG.md"&gt;CHANGELOG.md&lt;/a&gt;
for an authoritative list of cleanups.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_the-road-ahead'&gt;The Road Ahead&lt;/h4&gt;
&lt;p&gt;Over the last few releases of Ember 1.x, we added a large number of new
features. These additions, including a whole new rendering engine, were
introduced while maintaining backwards compatibility. Unsurprisingly,
maintaining support for the semantics of two rendering engines (among other
things) introduced a large amount of cruft. Continuing to provide backwards
compatible legacy APIs has a non-trivial impact on the performance of Ember
applications, and on the projectâ€™s momentum.&lt;/p&gt;

&lt;p&gt;Ember 2.0 allowed us to purge much of that built-up cruft. That was no small
task; removing code, documenting deprecations, and building new workflows for
managing these changes would not have happened without lots of hands. It was an
incredible effort, and we&amp;#39;d like to thank the community for making it happen.&lt;/p&gt;

&lt;p&gt;With the garbage collection sweep out of our way, we can continue to expand on
the foundation solidified in Emberâ€™s 1.x series.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_improved-release-cadence'&gt;Improved Release Cadence&lt;/h5&gt;
&lt;p&gt;Since Ember 1.0, we have followed &lt;a href="http://semver.org/"&gt;Semantic Versioning&lt;/a&gt;,
working very hard to maintain public API compatibility while adding new
features. In the lead-up to breaking changes in Ember 2.0, we made a number of
mistakes that caused our users to experience a great deal of churn.&lt;/p&gt;

&lt;p&gt;While we successfully followed our existing policies regarding deprecation
before removal, and ensured that each deprecated feature had a viable
replacement, we did not do a good job of distinguishing between different kinds
of deprecations. Additionally, many deprecations landed very late and all at
once. These factors combined made the entire process feel overwhelming.&lt;/p&gt;

&lt;p&gt;The feeling of &amp;quot;churn&amp;quot; is contrary to all our release process goals. In
addition to the continued maintenance of a six-week release cycle, we have a
number of tweaks to the process planned for 2.x. These are intended to help us
avoid a similar problem late in the 2.x cycle.&lt;/p&gt;

&lt;p&gt;Some examples of improvements are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LTS (Long-Term Support) Releases&lt;/strong&gt; (&lt;a href="https://github.com/emberjs/rfcs/pull/56"&gt;RFC #56&lt;/a&gt;),
which can give users who want to upgrade less often than every six week a
sanctioned way to do so.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mandatory docs&lt;/strong&gt;. No new features will be added to the Ember 2.0 release
channel without accompanying documentation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;More informative deprecations&lt;/strong&gt;. All deprecations will include which
release their behavior will be removed in, as well as a link to transition
instructions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Improved deprecation tooling&lt;/strong&gt;. More informative deprecations allow us to
make the Ember inspector&amp;#39;s deprecation pane smarter, and more useful for
incrementally working through deprecations. In particular, we can avoid
nagging you (by default) about removals that will not happen until far in the
future. For more information see
&lt;a href="https://github.com/emberjs/rfcs/pull/65"&gt;RFC #65&lt;/a&gt; and the included comments.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Svelte Builds&lt;/strong&gt;, which allow you to ask Ember CLI not to include deprecated
features you are no longer using. This will reduce pressure on future major
releases.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_ember-2-x-themes'&gt;Ember 2.x Themes&lt;/h4&gt;
&lt;p&gt;In addition to a better release process, you can look forward to several
high-level areas of improvement throughout the 2.x series.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alignment with JavaScript&lt;/strong&gt;. Throughout 2.x, we will continue our efforts to
align Ember with ES6 and future versions of JavaScript. As the JavaScript
decorator proposal stabilizes, and as transpilers improve their
implementations, we plan to adapt computed properties and other APIs to that
syntax.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaScript Modules&lt;/strong&gt;. We will also continue to evolve further towards a
modules development style and away from a globals style. Among other things,
this will allow us to more aggressively automate the removal of dead code
paths.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stabilization and Integration&lt;/strong&gt;. The Ember ecosystem will continue to
stabilize and integrate tightly. Ember-Data and Ember CLI will be versioned in
lockstep with Ember itself. Putting these projects on the &amp;quot;release train&amp;quot; with
Ember will mean they adhere to the same backwards compatible and incremental
change policies as Ember did through 1.x.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember Data&lt;/strong&gt;. With the release of Ember 2.0, Ember Data is now a stable part
of Ember&amp;#39;s releases. It will adhere to Semantic Versioning policies like Ember
itself, and every release of Ember will include a compatible release of Ember
Data. Along those lines, Ember Data will not make any breaking changes until
3.0.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_new-features-in-the-pipeline'&gt;New Features in the Pipeline&lt;/h5&gt;
&lt;p&gt;Many of our other plans have already been proposed via the RFC process and
discussions on GitHub, but here&amp;#39;s a recap.&lt;/p&gt;

&lt;p&gt;We are actively working on the implementation of these features, and expect
them to land gradually over several releases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Angle-Bracket Components and One-Way Data Flow&lt;/strong&gt;. Ember 2.x will transition
to angle-bracket components. For example &lt;code&gt;&amp;lt;my-button&amp;gt;&lt;/code&gt; instead of
&lt;code&gt;{{my-button}}&lt;/code&gt;. These will operate with one-way binding as part of a larger
transition to a &amp;quot;data down, actions up&amp;quot;, or &amp;quot;DDAU&amp;quot;, style of programming that
you will read about as features land. We expect these components to land in
2.2 and be refined over the next few releases. See
&lt;a href="https://github.com/emberjs/rfcs/pull/60"&gt;RFC #60&lt;/a&gt; and
&lt;a href="https://github.com/emberjs/ember.js/pull/12011"&gt;PR #12011&lt;/a&gt; for more details
about our progress.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pods&lt;/strong&gt;. We are also actively working on finalizing the pods directory layout
for applications, which makes it easier to group related parts of your
application together. This change will be completely opt-in, and existing
layouts will continue to work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Routable Components&lt;/strong&gt;. After angle-bracket components and the pods layout
land, we will be able to transition the last few use-cases for controllers to
the much-anticipated Routable Components.
&lt;a href="https://github.com/emberjs/rfcs/pull/38"&gt;RFC #38&lt;/a&gt; and
&lt;a href="https://github.com/emberjs/ember.js/pull/11939"&gt;PR #11939&lt;/a&gt; track our progress
so far.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FastBoot&lt;/strong&gt;, Ember&amp;#39;s alpha release server-side pre-rendering library, will
continue to improve and stabilize over the 2.x lifecycle. Find it on GitHub as
&lt;a href="https://github.com/tildeio/ember-cli-fastboot"&gt;ember-cli-fastboot&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.13 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html"/>
    <id>http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html</id>
    <published>2015-06-17T20:00:00-04:00</published>
    <updated>2015-06-17T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We are proud to announce the release of Ember Data 1.13. This
represents the first stable release of Ember Data since its creation
over 3 years ago. &lt;/p&gt;

&lt;p&gt;As we explained in the &lt;a href="http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html"&gt;The Ember 2.x Project&lt;/a&gt;
blog post, going forward Ember Data will be syncing...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We are proud to announce the release of Ember Data 1.13. This
represents the first stable release of Ember Data since its creation
over 3 years ago. &lt;/p&gt;

&lt;p&gt;As we explained in the &lt;a href="http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html"&gt;The Ember 2.x Project&lt;/a&gt;
blog post, going forward Ember Data will be syncing up its releases and version numbers with Ember.js releases. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember Data 1.13 is the first release of Ember Data that syncs its
  version with a version of Ember.js.&lt;/strong&gt; It will be followed by Ember Data 2.0, which will be released alongside Ember.js 2.0. &lt;strong&gt;Ember Data 1.13 is fully backwards compatible with Ember Data beta.19, allowing for a smooth upgrade path.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-data-1-13-overview'&gt;Ember Data 1.13 Overview&lt;/h3&gt;
&lt;p&gt;Ember Data 1.13 is a massive release we are very proud of.
The highlight of the Ember Data 1.13 release is a total overhaul of Ember Data&amp;#39;s internal format and Serializer API to follow JSON API. &lt;/p&gt;

&lt;p&gt;Two years ago Tom Dale and Yehuda Katz &lt;a href="http://emberjs.com/blog/2013/05/03/ember-data-progress-update.html"&gt;published&lt;/a&gt; a vision for how Ember Data should look in the future and articulated the need for a single, ubiquitous JSON API standard.&lt;/p&gt;

&lt;p&gt;We are very happy to see the vision for that JSON API standard come to life in the form of the &lt;a href="http://jsonapi.org"&gt;JSON API 1.0 release&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;JSON API and Ember Data have been intertwined since JSON API&amp;#39;s inception.
&lt;a href="https://github.com/dgeb"&gt;@dgeb&lt;/a&gt; gives the origins of JSON API in his &lt;a href="http://www.cerebris.com/blog/2015/06/04/jsonapi-1-0/"&gt;1.0 announcement&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yehuda Katz wrote the first draft of the JSON API specification in May 2013 after hammering out the details in a long discussion with Steve Klabnik at RailsConf. JSON API began as a codification of the shared expectations of a single server library for Rails, ActiveModel::Serializers, and a single JavaScript client library, Ember Data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ember Data has long supported JSON API through a community &lt;a href="https://github.com/kurko/ember-json-api"&gt;adapter&lt;/a&gt; started by &lt;a href="https://twitter.com/0x8890"&gt;@0x8890&lt;/a&gt; and maintained by &lt;a href="https://github.com/kurko"&gt;@kurko&lt;/a&gt;. However, now that JSON API has reached 1.0, it&amp;#39;s time for Ember Data to uphold its part of the bargain and make using JSON API a first-class experience.&lt;/p&gt;

&lt;p&gt;We have done exactly that, and Ember Data 1.13 adds support throughout the Ember Data stack for JSON API:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ember Data 1.13 ships with a fully supported JSON API Adapter and Serializer.&lt;/strong&gt; In 2.0, these will become the default Adapter and Serializer.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;JSONSerializer&lt;/code&gt; and &lt;code&gt;RESTSerializer&lt;/code&gt; have been refactored and streamlined to return JSON API payloads.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;store.push&lt;/code&gt; now accepts JSON API compliant payload.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ember Data &lt;code&gt;InvalidError&lt;/code&gt; objects now accept JSON API error objects&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Switching to the JSON API format unlocks many new features which will be added in the 2.0 cycle, including first-class pagination, filtering and metadata support.&lt;/p&gt;

&lt;p&gt;While &lt;strong&gt;using JSONSerializer, RESTSerializer and ActiveModelSerializer is not deprecated&lt;/strong&gt;, we consider JSON API to be the happiest of the happy paths for using Ember Data, and if you are creating a new app today and have control over the API you should be using JSON API, because it is a well designed and comprehensive solution for JSON serialization. &lt;strong&gt;If your app is using the vanilla JSONSerializer or RESTSerializer, you will not have to make any changes, and your app will continue to work.&lt;/strong&gt; The existing serializers have been updated in a backwards compatible way to return JSON API data to the store.&lt;/p&gt;

&lt;p&gt;Other major changes in Ember Data 1.13 include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_simplified-find-methods"&gt;Refactored and simplified find methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-adapter-hooks-for-better-caching"&gt;Adapter level control for identity map caching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-serializer-api-for-custom-serializer-authors"&gt;Refactored and simplified Serializer APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_internal-format-change-to-json-api"&gt;Switch to using JSON API as the internal data storage format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_json-api-support"&gt;Native JSON API Serializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-errors-api"&gt;Better error handling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_upgrade-guide'&gt;Upgrade Guide&lt;/h2&gt;
&lt;p&gt;Ember Data 1.13 is backwards-compatible with previous beta versions, and there are no
breaking changes between Ember Data 1.13 and Ember Data beta.19. Ember Data follows Ember.js&amp;#39;s lead in not removing any features in this release. The upgrade path should be familiar to Ember.js users: upgrade, remove deprecations, upgrade again.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You should update your codebase to Ember Data 1.13, remove all the deprecations
and then move to Ember Data 2.0. It is critically important to do this process step by step&lt;/strong&gt;, as it will give you easy to follow deprecation warnings.
Otherwise, your app might fail in hard-to-debug ways.&lt;/p&gt;

&lt;p&gt;If you have customized your serializer, you should upgrade to Ember Data 1.13, 
check the upgrade guide to see if you need to make any changes, and then set a
temporary flag on your Serializer: &lt;code&gt;isNewSerializerAPI&lt;/code&gt;. This will opt you into
the new serializer API. Once you are on the Ember Data 2.0 train, new Serializer API
is the default one, and there is no need for a flag.&lt;/p&gt;

&lt;p&gt;We will be publishing a detailed step by step upgrade guide along with Ember.js
deprecations guides and &lt;a href="https://github.com/abuiles/ember-watson"&gt;ember-watson&lt;/a&gt; helpers that will automatically upgrade some
of the deprecations for you.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_release-logistics'&gt;Release Logistics&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Ember Data 1.13 is the last release of Ember Data that supports IE8
  and the 1.x series of Ember.js. Ember Data 2.0-beta.1 will be released shortly, and it will follow the Ember.js release train.&lt;/strong&gt; Ember Data 2.0 will not work with the Ember.js 1.x series.&lt;/p&gt;

&lt;p&gt;We would like to extend a special thanks to the many contributors who
have helped out with this release. We would also like to recognize the
following contributors who helped with multiple issues leading up to
this release. If you would like to help, please join #dev-ember-data in the 
&lt;a href="https://ember-community-slackin.herokuapp.com/"&gt;Ember Community&lt;/a&gt; on Slack.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/turbo87"&gt;@turbo87&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/HeroicEric"&gt;@HeroicEric&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pangratz"&gt;@pangratz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sly7-7"&gt;@sly7-7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/yratanov"&gt;@yratanov&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tchak"&gt;@tchak&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/thaume"&gt;@thaume&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mikehollis"&gt;@mikehollis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tricknotes"&gt;@tricknotes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We would also like to thank the companies which generously sponsored some of the work
that has gone into Ember Data:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dockyard.com/"&gt;DockYard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.precisionnutrition.com/"&gt;Precision Nutrition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bookingsync.com"&gt;BookingSync&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As always this release can be obtained from npm (for
use with ember-cli), rubygems, or bower. The builds are also available
as static files at &lt;a href=""&gt;http://emberjs.com/builds&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features'&gt;New Features&lt;/h2&gt;&lt;h2 class='anchorable-toc' id='toc_simplified-find-methods'&gt;Simplified Find Methods&lt;/h2&gt;
&lt;p&gt;Ember Data methods on the store have grown organically over the life
of the project. Originally, Ember Data started with &lt;code&gt;store.find(type)&lt;/code&gt;
to request all records for a type and &lt;code&gt;store.find(type, id)&lt;/code&gt; to
request a specific record. Later Ember Data added ways to issue a
query to the server via &lt;code&gt;store.find(type, {query})&lt;/code&gt; or always reload a
record from the backend using &lt;code&gt;store.fetchById(type, id)&lt;/code&gt; and
&lt;code&gt;store.fetchAll(type)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We realized the overloaded &lt;code&gt;store.find&lt;/code&gt; method and inconsistent naming
of other methods is confusing for both new and existing developers. As a result, we have renamed many of the existing
store methods to make them more consistent and approachable for all
developers.&lt;/p&gt;

&lt;p&gt;In particular, &lt;code&gt;store.find&lt;/code&gt;, &lt;code&gt;store.all&lt;/code&gt;, &lt;code&gt;store.getById&lt;/code&gt; have been 
deprecated and are replaced with consistently named methods. New methods follow a simple convention: If they are async and potentially go to the server, they start with &lt;code&gt;find&lt;/code&gt;, and if they only get store local data without side-effects they start with &lt;code&gt;peek&lt;/code&gt;.
If they return a single record they end in &lt;code&gt;Record&lt;/code&gt; and if they return all the records they end in &lt;code&gt;All&lt;/code&gt; .&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_reorganized-find-methods'&gt;Reorganized Find Methods&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Async from server/store&lt;/th&gt;
      &lt;th&gt;Sync from store&lt;/th&gt;
      &lt;th&gt;Query server&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;b&gt;Single Record&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;findRecord(type,id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;peekRecord(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;queryRecord(type, {query})&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;b&gt;All Records&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;findAll(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;peekAll(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;query(type, {query})*&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* A query usually does not return all the records of a type, so doesn&amp;#39;t end in &lt;code&gt;All&lt;/code&gt;.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_query-and-queryrecord'&gt;query and queryRecord&lt;/h4&gt;
&lt;p&gt;The final use case for the old &lt;code&gt;store.find&lt;/code&gt; method was issuing queries
to the server. This usage of &lt;code&gt;store.find(type, { query })&lt;/code&gt; has been
deprecated and replaced by a new &lt;code&gt;query&lt;/code&gt; method
on the store.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.query(type, { query });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In addition to &lt;code&gt;store.query&lt;/code&gt; we have also added a &lt;code&gt;queryRecord&lt;/code&gt; for
issuing arbitrary queries to the backend where the expected response
is a single record.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.queryRecord(type, { query });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Thanks to &lt;a href="http://github.com/thaume"&gt;@thaume&lt;/a&gt; for his work implementing this feature.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_better-caching-defaults-for-code-findall-code-and-code-findrecord-code'&gt;Better Caching Defaults for &lt;code&gt;findAll&lt;/code&gt; and &lt;code&gt;findRecord&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;In Ember Data beta.19 calling &lt;code&gt;store.find(type, id)&lt;/code&gt; would fetch the
fresh data from the server the first time find was called, and then every time after that
return cached data. If the user always needed fresh data, they had to
know to call &lt;code&gt;store.fetchRecord&lt;/code&gt;, and if they needed to background update
they would have to make multiple calls and be careful about what they return from
a route&amp;#39;s &lt;code&gt;model:&lt;/code&gt; hook.&lt;/p&gt;

&lt;p&gt;Calling &lt;code&gt;store.find(type)&lt;/code&gt; had the exact opposite behavior, where it would
always go to the server, and the user had to know to use &lt;code&gt;store.all(type)&lt;/code&gt;
to only use local data. Mimicking the caching behavior of &lt;code&gt;find(type, id)&lt;/code&gt;
when using &lt;code&gt;find(type)&lt;/code&gt; was not at all straightforward for new developers to write.&lt;/p&gt;

&lt;p&gt;Having observed many Ember apps in the wild, we have realized that neither
of these two behaviors are the most common use case and deserving of being the default. The most commonly desired behavior we have seen in Ember apps is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First time &lt;code&gt;store.find&lt;/code&gt; is called, fetch new data&lt;/li&gt;
&lt;li&gt;Next time return cached data&lt;/li&gt;
&lt;li&gt;Fetch new data in the background and update&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is the behavior of the new &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt; methods. &lt;/p&gt;

&lt;p&gt;The first time you call &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt; they behave the same as
the old &lt;code&gt;find&lt;/code&gt; method:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1 for the first time&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  &lt;span class="comment"&gt;//We do not already have the user, so&lt;/span&gt;
  &lt;span class="comment"&gt;//store.findRecord returns a promise that resolves&lt;/span&gt;
  &lt;span class="comment"&gt;//after it has fetched the user from the server&lt;/span&gt;
  &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;However if you already have the data cached locally, they resolve immediately
while fetching new data in the background:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1 for the second time&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  &lt;span class="comment"&gt;//We already have the user, so store.findRecord&lt;/span&gt;
  &lt;span class="comment"&gt;//will resolve immediately with cached data, but will&lt;/span&gt;
  &lt;span class="comment"&gt;//send off a request in the background to update the user record&lt;/span&gt;
  &lt;span class="comment"&gt;//and once the user is updated your template will show the new changes&lt;/span&gt;
  &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While this is a great default data retrieval strategy, there are certain cases
where you want to ensure you have  the freshest data (the old &lt;code&gt;store.fetch&lt;/code&gt; behavior) or you do not want a background update to happen (the old &lt;code&gt;store.find(type, id)&lt;/code&gt; behavior). &lt;/p&gt;

&lt;p&gt;Because of that, &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt; accept &lt;code&gt;reload: true&lt;/code&gt; and &lt;code&gt;backgroundReload: false&lt;/code&gt; as options in order to modify their default behavior.&lt;/p&gt;

&lt;p&gt;If, for example you want to charge user for a purchase, and want to make sure you
get their latest account balance, you can pass a &lt;code&gt;reload: true&lt;/code&gt; option that will
ensure we get the freshest data before continuing:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1/confirm-payment&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For example if you are showing the user a settings modal and want to opt out from
background updates in order to keep the UI stable you can pass &lt;code&gt;backgroundReload: false&lt;/code&gt; as a flag:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1/open-modal&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;backgroundReload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;false&lt;/span&gt; });
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;All of these behaviors are also shared by &lt;code&gt;findAll&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);  &lt;span class="comment"&gt;//goes to the server the first time&lt;/span&gt;
store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);  &lt;span class="comment"&gt;//after that returns from cache, but updates in background&lt;/span&gt;
store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });  &lt;span class="comment"&gt;//enforces getting fresh data&lt;/span&gt;
store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;backgroundReload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;false&lt;/span&gt; });  &lt;span class="comment"&gt;//opts out of background updating&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_code-fetchbyid-code-and-code-fetchall-code-replaced-by-code-findrecord-code-and-code-findall-code'&gt;&lt;code&gt;fetchById&lt;/code&gt; and &lt;code&gt;fetchAll&lt;/code&gt; Replaced by &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Having these two methods, with customizable flags allows us to get rid of:
&lt;code&gt;store.fetchById&lt;/code&gt; and &lt;code&gt;store.fetchAll&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.fetchById(type, id) -&amp;gt; store.findRecord(type, id, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });
store.fetchAll(type, id) -&amp;gt; store.findAll(type, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_new-adapter-hooks-for-better-caching'&gt;New Adapter Hooks for Better Caching&lt;/h3&gt;
&lt;p&gt;While &lt;code&gt;store.findRecord&lt;/code&gt; and &lt;code&gt;store.findAll&lt;/code&gt; now have sensible caching defaults
and are easy to override in specific places in the app, oftentimes your app and
adapter layer have specific knowledge related to caching. For example, your backend
might have given you an &lt;code&gt;expires&lt;/code&gt; header, or you may not want to try fetching background updates if the network is down. To support these use cases, we have added new adapter
hooks to customize caching app wide beyond just passing options to &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, whenever you call &lt;code&gt;findRecord&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt;, and the record is already cached in the store, the store will ask the adapter whether it needs to immediately reload it, or if it needs to update it in the background.&lt;/p&gt;

&lt;p&gt;For example, if you are building an events ticketing system, in which users can only reserve tickets for 20 minutes at a time, and want to ensure that in each route you have data that is no more than 20 minutes old you could write:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="function"&gt;shouldReloadRecord&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, ticketSnapshot) {
  let timeDiff = moment().diff(ticketSnapshot.attr(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastAccessedAt&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)).minutes();
  &lt;span class="keyword"&gt;if&lt;/span&gt; (timeDiff &amp;gt; &lt;span class="integer"&gt;20&lt;/span&gt;) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;true&lt;/span&gt;;    
  } &lt;span class="keyword"&gt;else&lt;/span&gt; {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;false&lt;/span&gt;;
  }
}, 
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This method would ensure that whenever you do &lt;code&gt;findRecord(&amp;#39;ticket&amp;#39;)&lt;/code&gt; you will
always get a ticket that is no more than 20 minutes old. In case the cached
version is more than 20 minutes old, &lt;code&gt;findRecord&lt;/code&gt; will not resolve until you fetched
the latest version. By default this hook returns false, as most UIs should not block
user interactions while waiting on data update.&lt;/p&gt;

&lt;p&gt;You can also customize whether you should try and do a background update. For example, if you do not want to fetch complex data over a mobile connection, or 
if the network is down, you can implement &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="function"&gt;shouldBackgroundReloadRecord&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, snapshot) {
  &lt;span class="keyword"&gt;if&lt;/span&gt; (window.navigator.connection === &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;cellular&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; ||
    window.navigator.connection === &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;none&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;false&lt;/span&gt;;
  } &lt;span class="keyword"&gt;else&lt;/span&gt; {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;true&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Adapter#shouldBackgroundReloadRecord&lt;/code&gt; is called by the store when the
store is resolving the &lt;code&gt;findRecord&lt;/code&gt; promise with a cached record. If
this method returns &lt;code&gt;true&lt;/code&gt; the store will attempt to reload the record
from the adapter in the background. The default implementation for
this method in Ember Data 1.13 is to always return &lt;code&gt;false&lt;/code&gt;, in order
to ease the upgrade path. However in
Ember Data 2.0 this will be changed to always return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Symmetric methods have also been added for &lt;code&gt;store.findAll&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="function"&gt;shouldReloadAll&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, snapshotRecordArray)
  &lt;span class="function"&gt;shouldBackgroundReloadAll&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, snapshotRecordArray)
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/eccegordo"&gt;@eccegordo&lt;/a&gt; put together this table
listing all the new store apis and the methods they replace.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Ember beta.19&lt;/th&gt;
      &lt;th&gt;Ember 1.13&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.getById(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.peekRecord(type, id)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.all(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.peekAll(type)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.find(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.findRecord(type, id, options)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.find(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.findAll(type, options)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.queryRecord(type, query)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.find(type, { query })&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.query(type, query)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.fetch(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.findRecord(type, id, {reload: true})&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 class='anchorable-toc' id='toc_json-api-support'&gt;JSON API Support&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_json-api-adapter-and-serializer'&gt;JSON API Adapter and Serializer&lt;/h3&gt;
&lt;p&gt;Ember Data 1.13 comes with support for &lt;a href="http://jsonapi.org/"&gt;JSON API&lt;/a&gt;
1.0. There is a new &lt;code&gt;DS.JSONAPIAdapter&lt;/code&gt; and &lt;code&gt;DS.JSONAPISerializer&lt;/code&gt;
that support working with JSON API backends. In Ember Data 2.0 the
JSON API Adapter will be the default loaded by Ember Data.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_internal-format-change-to-json-api'&gt;Internal Format Change to JSON API&lt;/h3&gt;
&lt;p&gt;In Ember Data beta.19, you communicated updates to the store by calling
&lt;code&gt;store.push(type, id)&lt;/code&gt;. We have now changed &lt;code&gt;store.push&lt;/code&gt; so it receives a 
JSON API object, &lt;code&gt;store.push({JSON API compound document})&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.push(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Pangratz&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;becomes&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.push({
  &lt;span class="key"&gt;data&lt;/span&gt;: {
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;attributes&lt;/span&gt;: { 
      &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Pangratz&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; 
    }
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This allows for much better and fine grained meta handling, and ensures we do
not have to support, maintain and document a completely custom JSON format
as we had to until now, but can just reference the &lt;a href="http://jsonapi.org/"&gt;JSON API specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We will be publishing an &lt;a href="https://github.com/abuiles/ember-watson"&gt;ember-watson&lt;/a&gt; helper that will be rewriting all the uses
of &lt;code&gt;store.push&lt;/code&gt; inside your tests to the new format, as well as addon with helpers
that convert the old &lt;code&gt;store.push&lt;/code&gt; format into the new format.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_new-serializer-api-for-custom-serializer-authors'&gt;New Serializer API for custom Serializer authors&lt;/h3&gt;
&lt;p&gt;If you made a &lt;code&gt;store.findRecord(&amp;#39;user&amp;#39;, 1)&lt;/code&gt; request in Ember Data beta.19
and your server payload looked like:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;user&lt;/span&gt;: { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;accounts&lt;/span&gt;: [&lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="integer"&gt;2&lt;/span&gt;] },
  &lt;span class="key"&gt;accounts&lt;/span&gt;: [
    { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@sweden.se&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; },
    { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;2&lt;/span&gt;, &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@greece.gr&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; }
  ]
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Your serializer would get the payload passed in an &lt;code&gt;extract&lt;/code&gt; hook and its job was to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;normalize and &lt;code&gt;store.push&lt;/code&gt; everything that is not the &lt;code&gt;primary record&lt;/code&gt;, in this
case the array of sideloaded accounts&lt;/li&gt;
&lt;li&gt;normalize and return the primary data, in this case the &lt;code&gt;user&lt;/code&gt; data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Having these two ways of pushing data to the store, with both returning primary record data
from &lt;code&gt;extract&lt;/code&gt; hooks but also doing &lt;code&gt;store.push&lt;/code&gt; with other data was both confusing,
hard to debug and optimize and also prevented us from implementing proper metadata support, especially for sideloaded arrays and records.&lt;/p&gt;

&lt;p&gt;In Ember Data 1.13 this process has been greatly simplified. &lt;strong&gt;In 1.13 Serializers
should just make the whole payload conform to the JSON API spec, and return the whole payload&lt;/strong&gt;. They should no longer &lt;code&gt;store.push&lt;/code&gt; themselves.&lt;/p&gt;

&lt;p&gt;In order to be backwards compatible, we created a new hook &lt;code&gt;normalizeResponse&lt;/code&gt; which
Serializers should now implement, and just return JSON API from that hook.&lt;/p&gt;

&lt;p&gt;For example a Serializer responsible for normalizing the above sample payload would just transform it to:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
17
18
19
&lt;strong&gt;20&lt;/strong&gt;
21
22
23
24
25
26
27
28
29
&lt;strong&gt;30&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;data&lt;/span&gt;: { 
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;attributes&lt;/span&gt;: {
      &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
    }, 
    &lt;span class="key"&gt;relationships&lt;/span&gt;: {
      &lt;span class="key"&gt;accounts&lt;/span&gt;: {
        &lt;span class="key"&gt;data&lt;/span&gt;: [
          { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; },
          { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;2&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; }
        ]
      }
    }
  },
  &lt;span class="key"&gt;included&lt;/span&gt;: [{ 
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;attributes&lt;/span&gt;: {
      &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@sweden.se&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  }, {
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;2&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;attributes&lt;/span&gt;: {
      &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@greece.gr&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  }]
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We will be posting a detailed Serializer transition guide shortly.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_new-jsonserializer-and-restserializer-api'&gt;New JSONSerializer and RESTSerializer API&lt;/h3&gt;
&lt;p&gt;As we rewrote JSONSerializer and RESTSerializer to implement the new
Serializer API we also simplified and greatly improved their own APIs.
Previously the possible places to modify a response for &lt;code&gt;store.find(&amp;#39;user&amp;#39;, 1)&lt;/code&gt; were&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFind&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractSingle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizePayload&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeHash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractMeta&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeRelationships&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeAttributes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The new Serializer API allowed us to simplify these. If you receive a response 
to &lt;code&gt;store.findRecord(&amp;#39;user&amp;#39;, 1)&lt;/code&gt; in Ember Data 1.13 you can customize your response
in&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;normalizeResponse&lt;/code&gt; - entry method to the Serializer and responsible for normalizing any response, gets the full payload, returns a JSON API compound document&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeFindRecordResponse&lt;/code&gt; - a normalizeResponse for a specific operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalize&lt;/code&gt; - normalizes data for a single record, returns a JSON API compound document

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extractId&lt;/code&gt; | &lt;code&gt;extractAttributes&lt;/code&gt; | &lt;code&gt;extractRelationships&lt;/code&gt; - normalize delegates to these methods to extract the id, attributes and relationships from the payload. They receive the full payload for a single record and return the subsets of data for id, attributes and relationships, conforming to the JSON API specification.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;extractMeta - extracts the metadata for a payload&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_transition-to-the-new-jsonserializer-and-restserializer-apis'&gt;Transition to the new JSONSerializer and RESTSerializer APIs&lt;/h4&gt;
&lt;p&gt;If you have a custom serializer you will need to make some new changes
to your serializer to get it ready for Ember Data 2.0.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_custom-code-extract-code-methods'&gt;Custom &lt;code&gt;extract&lt;/code&gt; Methods&lt;/h5&gt;
&lt;p&gt;If you have custom &lt;code&gt;extract&lt;/code&gt; hooks you need to do two things:&lt;/p&gt;

&lt;p&gt;First, rename:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extract()              =&amp;gt; normalizeResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindAll()       =&amp;gt; normalizeFindAllResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFind()          =&amp;gt; normalizeFindRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindMany()      =&amp;gt; normalizeFindManyResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindBelongsTo() =&amp;gt; normalizeFindBelongsToResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindHasMany()   =&amp;gt; normalizeFindHasManyResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindQuery()     =&amp;gt; normalizeQueryResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractQueryRecord()   =&amp;gt; normalizeQueryRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractCreateRecord()  =&amp;gt; normalizeCreateRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractDeleteRecord()  =&amp;gt; normalizeDeleteRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractUpdateRecord()  =&amp;gt; normalizeUpdateRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractSave()          =&amp;gt; normalizeSaveResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractSingle()        =&amp;gt; normalizeSingleResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractArray()         =&amp;gt; normalizeArrayResponse()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Second, make sure that your &lt;code&gt;extract&lt;/code&gt; hooks return a full JSON API compound document
(&lt;a href="http://jsonapi.org/format/#document-top-level"&gt;http://jsonapi.org/format/#document-top-level&lt;/a&gt;) with the primary
resource(s) in a &lt;code&gt;data&lt;/code&gt; array or object and eventual sideloaded
resources in a &lt;code&gt;included&lt;/code&gt; array. Every resource object
(&lt;a href="http://jsonapi.org/format/#document-resource-objects"&gt;http://jsonapi.org/format/#document-resource-objects&lt;/a&gt;) has to
follow the JSON API format with &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, attributes in
&lt;code&gt;attributes&lt;/code&gt; and relationships in &lt;code&gt;relationships&lt;/code&gt;. For the full
specification of the JSON API format see
&lt;a href="http://jsonapi.org/format/"&gt;http://jsonapi.org/format/&lt;/a&gt;.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_custom-code-extractmeta-code-method'&gt;Custom &lt;code&gt;extractMeta&lt;/code&gt; Method&lt;/h5&gt;
&lt;p&gt;If you have a custom &lt;code&gt;extractMeta&lt;/code&gt; method you have to make sure it
returns the meta data instead of calling &lt;code&gt;store.setMetadataFor()&lt;/code&gt; (or
relying on &lt;code&gt;_super&lt;/code&gt; to do so).&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_custom-code-normalize-code-method'&gt;Custom &lt;code&gt;normalize&lt;/code&gt; Method&lt;/h5&gt;
&lt;p&gt;If you have a custom &lt;code&gt;normalize()&lt;/code&gt; method you need to update this to
return a full JSON API Document
(&lt;a href="http://jsonapi.org/format/#document-top-level"&gt;http://jsonapi.org/format/#document-top-level&lt;/a&gt;) with the primary
resource object
(&lt;a href="http://jsonapi.org/format/#document-resource-objects"&gt;http://jsonapi.org/format/#document-resource-objects&lt;/a&gt;) located in
&lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_opt-into-the-new-serializer-api'&gt;Opt Into the New Serializer API&lt;/h5&gt;
&lt;p&gt;To tell Ember Data that you are ready to use the new Serializer API,
add &lt;code&gt;isNewSerializerAPI: true&lt;/code&gt; when extending &lt;code&gt;JSONSerializer&lt;/code&gt; or
&lt;code&gt;RESTSerializer&lt;/code&gt;. The new &lt;code&gt;JSONAPISerializer&lt;/code&gt; uses the new Serializer
API by default. The &lt;code&gt;isNewSerializerAPI&lt;/code&gt; flag is &lt;strong&gt;only&lt;/strong&gt; required for
Ember Data 1.13 and will be removed in Ember Data 2.0. The new
&lt;code&gt;JSONAPISerializer&lt;/code&gt; only supports the new Serializer API.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://github.com/wecc"&gt;@wecc&lt;/a&gt; for his hard work on
implementing this feature in a backwards compatible way.&lt;/p&gt;

&lt;p&gt;We would also like thank &lt;a href="https://github.com/kurko"&gt;@kurko&lt;/a&gt;
for his efforts maintaining the
&lt;a href="https://github.com/kurko/ember-json-api"&gt;community JSON API adapter&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-errors-api'&gt;New Errors API&lt;/h2&gt;
&lt;p&gt;Similarly to the find APIs, our error handling APIs have grown over time,
and the switch to JSON API has given us a great opportunity for cleanup
and standardisation. &lt;a href="https://twitter.com/tchak13"&gt;@tchak&lt;/a&gt; has done a great job rewriting our
Errors API to be JSON API compatible, while keeping backwards support for
REST/JSON/ActiveModel adapters. There are two main changes in Ember Data 1.13
error handling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cleaner adapter hooks for errors&lt;/li&gt;
&lt;li&gt;Using JSON API Error object format&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class='anchorable-toc' id='toc_cleaner-adapter-hooks-for-errors'&gt;Cleaner adapter hooks for errors&lt;/h3&gt;
&lt;p&gt;Previously, if you were subclassing the &lt;code&gt;RestAdapter&lt;/code&gt; you could overwrite
&lt;code&gt;ajaxSuccess&lt;/code&gt; and &lt;code&gt;ajaxError&lt;/code&gt; hooks to implement custom error handling.
However, potential errors come in many flavors. For example, you could be receiving responses with a status code of &lt;code&gt;200&lt;/code&gt; with the body of &lt;code&gt;{ error: error }&lt;/code&gt;. In this case it was not intuitive to write error handling code in a method called &lt;code&gt;ajaxSuccess&lt;/code&gt;. Because of this and many other examples, we realized that &lt;code&gt;ajaxSuccess&lt;/code&gt; and &lt;code&gt;ajaxError&lt;/code&gt; were not the
correct level at which to implement error handling.&lt;/p&gt;

&lt;p&gt;In Ember Data 1.13 we are introducing a new, simpler adapter hook:
&lt;code&gt;handleResponse&lt;/code&gt; while deprecating &lt;code&gt;ajaxSuccess&lt;/code&gt; and
&lt;code&gt;ajaxError&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;The responsibility of &lt;code&gt;handleResponse&lt;/code&gt; is to take the returned status,
response headers and payload, and decide whether to pass the payload through as
a success, or to return an instance of &lt;code&gt;AdapterError&lt;/code&gt; or &lt;code&gt;InvalidError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, if your API engineers for some unknown reason decided to return
&lt;code&gt;200 OK&lt;/code&gt; with an error message, you could subclass your adapter to handle this:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="function"&gt;handleResponse&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(status, headers, payload) {
  &lt;span class="keyword"&gt;if&lt;/span&gt; (status === &lt;span class="integer"&gt;200&lt;/span&gt; &amp;amp;&amp;amp; payload.errors) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="keyword"&gt;new&lt;/span&gt; InvalidError(payload.errors);
  }
  &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;._super(...&lt;span class="local-variable"&gt;arguments&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You could also subclass two helper methods, &lt;code&gt;isInvalid&lt;/code&gt; and &lt;code&gt;isSuccess&lt;/code&gt;
to customize when you adapter considers a request succesful or invalid.&lt;/p&gt;

&lt;p&gt;Default implementation of &lt;code&gt;isInvalid&lt;/code&gt; returns
true if http status code is &lt;code&gt;422&lt;/code&gt;, however, you may desire other
semantics, for example checking the &lt;code&gt;code&lt;/code&gt; property on a JSON API
error object.&lt;/p&gt;

&lt;p&gt;This refactor also allows us to abstract away the jQuery &lt;code&gt;jqXHR&lt;/code&gt; object, which
was tying Ember Data&amp;#39;s Rest Adapter too closely with jQuery&amp;#39;s implementation of ajax. New hooks take three arguments instead of &lt;code&gt;jqXHR&lt;/code&gt;: status code, a hash of
response headers and parsed payload. It makes them agnostic about the
underlying implementation and will allow us to easily use methods like
&lt;a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch?hl=en"&gt;fetch&lt;/a&gt;
in the future.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_using-json-api-error-object-format'&gt;Using JSON API Error object format&lt;/h3&gt;
&lt;p&gt;Similarly to the rest of Ember Data 1.13, we have refactored the error handling to use JSON API. JSON API has specified an
&lt;a href="http://jsonapi.org/format/#error-objects"&gt;error objects&lt;/a&gt;
format. Starting with Ember Data 1.13 we are using JSON API format to
communicate errors from the adapter to the store. 
We are deprecating the current Ruby on Rails inspired
format for creating &lt;code&gt;InvalidError&lt;/code&gt; objects and replacing it with
proper JSON API objects. The old format is supported with a
deprecation warning in 1.13.&lt;/p&gt;

&lt;p&gt;Deprecated format:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;new&lt;/span&gt; DS.InvalidError({
  &lt;span class="key"&gt;first_name&lt;/span&gt;: [&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;is invalid&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;]
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;New format:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;new&lt;/span&gt; DS.InvalidError([
  {
    &lt;span class="key"&gt;source&lt;/span&gt;: { &lt;span class="key"&gt;pointer&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;data/attributes/first_name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; },
    &lt;span class="key"&gt;detail&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;is invalid&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
  }
]);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Thanks to &lt;a href="https://github.com/tchak"&gt;@tchak&lt;/a&gt; and
&lt;a href="https://github.com/twokul"&gt;@twokul&lt;/a&gt; for working on the design and
implementation of the new API.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_significant-deprecations'&gt;Significant Deprecations&lt;/h2&gt;
&lt;p&gt;In addition to new features, Ember Data 1.13 introduces deprecations for
features and behavior that will be removed in Ember Data 2.0.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_async-relationships'&gt;Async Relationships&lt;/h3&gt;
&lt;p&gt;In Ember Data 2.0 relationships will be asynchronous by default. Sync
relationships will still be supported but you will need to manually
opt into them by setting &lt;code&gt;{ async: false }&lt;/code&gt; on your
relationships. Ember Data 1.13 will log a deprecation warning you if
you have any relationships where the &lt;code&gt;async&lt;/code&gt; property is not
explicitly set. Additionally you can use
&lt;a href="https://github.com/abuiles/ember-watson"&gt;ember-watson&lt;/a&gt; to help
identify cases in your codebase where you have relationships without
an explicit &lt;code&gt;async&lt;/code&gt; property.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ds-store-filter-moved-to-an-addon'&gt;DS.Store#filter Moved to an Addon&lt;/h3&gt;
&lt;p&gt;With Ember Data 2.0 and the commitment to semver we found we were not
happy with the state of the current &lt;code&gt;store.filter()&lt;/code&gt; method. It
currently only supports a limited number of uses cases and often is a
source of memory leaks in long running applications. In order to give
Ember Data time to iterate on a better filter API the current
&lt;code&gt;store.filter&lt;/code&gt; method has been deprecated and its functionality is
being moved into an addon
&lt;a href="https://github.com/ember-data/ember-data-filter"&gt;https://github.com/ember-data/ember-data-filter/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In Ember 2.0, if you would like to use the current &lt;code&gt;store.filter&lt;/code&gt;
method you will need to include the ember-data-filter addon with your
application.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ds-activemodeladapter-moved-to-an-addon'&gt;DS.ActiveModelAdapter Moved to an Addon&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DS.ActiveModelAdapter&lt;/code&gt; and &lt;code&gt;DS.ActiveModelSerializer&lt;/code&gt; has also been
&lt;a href="https://github.com/ember-data/active-model-adapter"&gt;moved to an addon&lt;/a&gt;. It
will continue to be supported by the Ember Data team, however, it will
no longer ship with Ember Data by default in Ember Data 2.0.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_custom-stores'&gt;Custom Stores&lt;/h3&gt;
&lt;p&gt;Over the years, Ember Data has supported a number of namespaces where
custom stores can be defined. In order to make things conceptually
simpler Ember Data 2.0 will require custom stores to be define as a
service.&lt;/p&gt;

&lt;p&gt;If you have a custom store in your Ember CLI app defined in
&lt;code&gt;app/store.js&lt;/code&gt; you will need to move it to &lt;code&gt;app/services/store.js&lt;/code&gt;. If
you have a custom store in your globals app you will need to move it
to &lt;code&gt;App.StoreService&lt;/code&gt;.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_json-api-adapter-default'&gt;JSON API Adapter Default&lt;/h3&gt;
&lt;p&gt;In Ember Data 2.0 the default adapter will be the &lt;code&gt;JSONAPIAdapter&lt;/code&gt;. In
Ember Data 1.13 when loading the default &lt;code&gt;RESTAdapter&lt;/code&gt; there will be a
deprecation warning.&lt;/p&gt;

&lt;p&gt;To silence the warning and continue using the &lt;code&gt;RESTAdapter&lt;/code&gt; you will
need to set the &lt;code&gt;RESTAdapter&lt;/code&gt; as your application adapter.&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;td colspan="2"&gt;app/adapters/application.js&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;import&lt;/span&gt; DS from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;ember-data&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; DS.RESTAdapter;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_code-store-push-code-changes'&gt;&lt;code&gt;store.push&lt;/code&gt; Changes&lt;/h3&gt;
&lt;p&gt;Previously, Ember Data allowed users to add a record to the store
using &lt;code&gt;store.push(&amp;#39;model-name&amp;#39;, {})&lt;/code&gt;. This format has been deprecated
and now &lt;code&gt;store.push&lt;/code&gt; will take a JSON API document as its first and
only argument. This new change will allow Ember Data to get better
performance in Ember Data 2.0 by deferring the creation of DS.Model
instances until they are needed by user code. &lt;code&gt;store.pushMany&lt;/code&gt; has
also been deprecated because you can push multiple records using in a
JSON API document.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_code-rollback-code-renamed-to-code-rollbackattributes-code'&gt;&lt;code&gt;rollback&lt;/code&gt; Renamed to &lt;code&gt;rollbackAttributes&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;record.rollback()&lt;/code&gt; has been deprecated to
&lt;code&gt;record.rollbackAttributes()&lt;/code&gt;. This new name more closely matches its
behavior and will allow for a new &lt;code&gt;record.rollback()&lt;/code&gt; to be introduced
in the future that rolls back relationships in addition to attributes.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_code-isdirty-code-renamed-to-code-hasdirtyattributes-code'&gt;&lt;code&gt;isDirty&lt;/code&gt; Renamed to &lt;code&gt;hasDirtyAttributes&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;record.isDirty()&lt;/code&gt; has been deprecated to
&lt;code&gt;record.hasDirtyAttributes()&lt;/code&gt;. This new name more closely matches its
behavior and will allow for a new &lt;code&gt;record.hasDirtyRelationships()&lt;/code&gt; to be introduced
in the future that allows you to check dirtiness of relationships.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_preloading-record-data-on-find'&gt;Preloading Record Data on Find&lt;/h3&gt;
&lt;p&gt;If you previously used the preload argument to &lt;code&gt;store.find&lt;/code&gt; it has
been moved into the preload key on &lt;code&gt;findRecord&lt;/code&gt;&amp;#39;s options argument&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// Deprecated&lt;/span&gt;
store.find(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comment&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;post&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt; });

&lt;span class="comment"&gt;// Ember Data 1.13 style&lt;/span&gt;
store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comment&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;preload&lt;/span&gt;: { &lt;span class="key"&gt;post&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt; }});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h2 class='anchorable-toc' id='toc_changelog'&gt;Changelog&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/emberjs/data/blob/3bce36295a6e9f1bbe4824505046d22dc04d056d/CHANGELOG.md#release-113-june-16-2015"&gt;Ember Data 1.13&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>The Ember 2.x Project</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html"/>
    <id>http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html</id>
    <published>2015-06-15T20:00:00-04:00</published>
    <updated>2015-06-15T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;For the past several years, when we've talked about "Ember releases", we were always talking about releases of the Ember codebase itself.&lt;/p&gt;

&lt;p&gt;In practice, that has meant that in order to put together the full, recommended Ember stack, you needed to figure...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;For the past several years, when we&amp;#39;ve talked about &amp;quot;Ember releases&amp;quot;, we were always talking about releases of the Ember codebase itself.&lt;/p&gt;

&lt;p&gt;In practice, that has meant that in order to put together the full, recommended Ember stack, you needed to figure out not just what Ember version to use, but what versions of our other libraries and tools worked with it.&lt;/p&gt;

&lt;p&gt;Starting with Ember 2.0, we will coordinate every release of Ember with releases of the main ecosystem tools maintained by the core team:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ember CLI&lt;/li&gt;
&lt;li&gt;Ember.js&lt;/li&gt;
&lt;li&gt;Ember Data&lt;/li&gt;
&lt;li&gt;Liquid Fire&lt;/li&gt;
&lt;li&gt;List View&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;All of these tools will share a version number with Ember itself.&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;Upgrading to Ember 2.3 means that you&amp;#39;ll get a new version of the Ember tools and a new version of Ember. You&amp;#39;ll also get new versions of Liquid Fire, List View and Ember Data designed to work with (and tested against) Ember 2.3.&lt;/p&gt;

&lt;p&gt;These projects will also ship betas alongside Ember itself, meaning that when Ember 2.3-beta.1 is released, there will be versions of Ember Data, Liquid Fire and List View released at the same time that are tested against the new beta.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We are in the process of aligning the versions now; you should start to see releases of Ember Data and Liquid Fire numbered &amp;quot;2.0 beta&amp;quot; in the next few days.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At a high level, the goal of these releases is for &amp;quot;upgrading to Ember 2.3&amp;quot; to mean upgrading Ember CLI to that version, and getting all of the improvements across all of the projects at once, without having to figure out how to separately upgrade each piece.&lt;/p&gt;

&lt;p&gt;We expect that Semver and a shared community experience of upgrading at once will make this upgrade relatively painless, and will continue to work on improvements to the process that eliminates sources of pain due to upgrades. (See the &lt;a href="https://github.com/emberjs/rfcs/blob/two-dot-x-improvements/active/0000-improved-release-cycle.md"&gt;Release Cycle Improvements&lt;/a&gt; RFC for more on improvements we already have planned for the 2.x cycle.)&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_frequently-asked-questions'&gt;Frequently Asked Questions&lt;/h3&gt;
&lt;p&gt;While I tried to answer the most common questions I&amp;#39;ve heard from people, I&amp;#39;m sure I missed some.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What does this mean for right now?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We have shipped Ember 2.0 beta, and are in the process of shipping &amp;quot;2.0 beta&amp;quot; versions of the remaining projects.&lt;/p&gt;

&lt;p&gt;In practice, this means shipping a final version of the projects that will be compatible with Ember 1.13, and buttoning up any final changes that need to be made before they join Ember&amp;#39;s semantic versioning pace.&lt;/p&gt;

&lt;p&gt;There will be a separate blog post in the next few days describing precisely how this will affect Ember Data, but the short version is the same. There will be a final version of Ember Data that will be compatible with the versions that have been shipping all year, and then we will ship Ember Data 2.0 beta, aligned with Ember itself.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Doesn&amp;#39;t this mean that Ember is becoming a huge monolithic project that is now tightly coupled with all of these other projects?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No. The reason to share a version number is almost entirely about convenience and a less fragmented ecosystem. While it is technically true that Liquid Fire 2.4 will work fine with Ember 2.6, this means that applications will practically be on a smorgasboard of versions of the core libraries, making it harder to write tutorials and answer questions, even once it is clear what version of Ember a user is using.&lt;/p&gt;

&lt;p&gt;What this means it that if a user is using Ember 2.4, and asks a question about animations or Ember Data, it is possible to answer the question without asking a half-dozen other questions to learn basic things about the user&amp;#39;s environment.&lt;/p&gt;

&lt;p&gt;Similarly, if you are looking at a tutorial that was built for Ember 2.4, you know that it will not be targeting a different version of the other core libraries, with the caveats that would bring.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;But doesn&amp;#39;t this mean that upgrading Ember is a huge &amp;quot;big bang
upgrade&amp;quot; that will take an even longer amount of time to perform now that it&amp;#39;s coupled with Ember CLI, Ember Data, and Liquid Fire?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While in principle upgrading Ember.js without one of the other libraries might seem like it would take less time, we don&amp;#39;t think this is true in practice.&lt;/p&gt;

&lt;p&gt;By aligning the release cycles and versions of the most common libraries, it is possible for upgrade guides to cover all of the instructions that you will need in one place, and you will be sharing an upgrade experience with the rest of the ecosystem.&lt;/p&gt;

&lt;p&gt;When you ask a question in IRC, on GitHub Issues or on Stack Overflow about upgrading to Ember 2.4, the known caveats for the entire upgrade process will be well-known and well-trod.&lt;/p&gt;

&lt;p&gt;This is not the case if you are trying to upgrade to Ember 2.5 while remaining on Ember CLI 2.2 with List View 2.3 and Liquid Fire 2.1. It &lt;strong&gt;might&lt;/strong&gt; work out, but the number of people sharing the same combination will be very low, and the people maintaining the libraries might not even have considered that precise combination.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In practice, the fact that all of these libraries share the same SemVer requirements should make upgrading across all five components more straight forward than trying to cobble together a multi-version stack yourself.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I don&amp;#39;t agree with anything you said here and just want to pick and choose the versions of the libraries I want to use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go for it! The people maintaining each of these libraries want older versions of the libraries to work with newer versions of Ember, because it makes their jobs easier.&lt;/p&gt;

&lt;p&gt;If you are deeply committed to upgrading a piece at a time, even though it will mean you will need to work out the details on your own, feel free to attempt it, and report bugs if you encounter any problems.&lt;/p&gt;

&lt;p&gt;(There is one minor caveat. As of Ember 2.0, Liquid Fire and Ember Data make minor use of private Ember APIs. We intend to replace those APIs with public APIs within the first few releases.)&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember.js 1.13.0 and 2.0 Beta Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html"/>
    <id>http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html</id>
    <published>2015-06-11T20:00:00-04:00</published>
    <updated>2015-06-11T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We are pleased to announce the release of both Ember.js 1.13.0 and the
first beta in the 2.0 series. This comes as the thirteenth cycle of our
release process that began just after 1.0 was released.&lt;/p&gt;

&lt;p&gt;The 1.13 release represents the effort of at least...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We are pleased to announce the release of both Ember.js 1.13.0 and the
first beta in the 2.0 series. This comes as the thirteenth cycle of our
release process that began just after 1.0 was released.&lt;/p&gt;

&lt;p&gt;The 1.13 release represents the effort of at least 43 contributors
across over 680 commits.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 1.13 is the last release in the 1.x series and the first release that includes the Glimmer rendering engine.&lt;/strong&gt; It includes a number of deprecations that will ease the upgrade to Ember 2.0, which is due to land in six weeks.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 2.0 beta is the first release in the 2.x series.&lt;/strong&gt; This means that many features deprecated during the 1.x series will be removed in Ember 2.0. If you encounter any unexpected changes in features not marked as deprecated in 1.13 while testing Ember 2.0 beta, please report them immediately. We would like to fix these unintentional regressions before the final release of 2.0 in six weeks.&lt;/p&gt;

&lt;p&gt;The release of Ember 2.0 beta also means that the first features in Ember 2.1 (most notably angle bracket components), are in their final canary stretch. Now is a good time to comment on RFCs and pull requests related to those features.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features-in-ember-js-1-13'&gt;New Features in Ember.js 1.13&lt;/h2&gt;
&lt;p&gt;The Glimmer rendering engine, &lt;a href="https://www.youtube.com/watch?v=o12-90Dm-Qs&amp;amp;feature=youtu.be&amp;amp;t=47m21s"&gt;announced at EmberConf&lt;/a&gt; and introduced to Ember.js
Canary on &lt;a href="/blog/2015/05/05/glimmer-merging.html"&gt;May 5th&lt;/a&gt;, is released today
in Ember.js 1.13. Glimmer is the third overhaul of Ember&amp;#39;s 1.x rendering
layer (wow, right?), and dramatically improves re-render performance in many
common scenarios. Additionally it lays important groundwork for the Ember 2.x
development model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We are tremendously excited to bring Glimmer to existing applications as
a 1.x compatible minor release.&lt;/strong&gt; The herculean efforts of the Ember core team,
addon authors, and community to achieve this release has been inspiring.
Thank you! You are too many to possibly name.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.13 also marks the final minor release of the Ember 1.x cycle.&lt;/strong&gt; As such,
it contains a number of deprecations ahead of Ember 2.0. Resolving these
deprecations in application code aligns that application with Ember&amp;#39;s public
API in 2.0. In general, Ember apps running 1.13 without causing any deprecation notices
to fire should upgrade to 2.0 without changes.&lt;/p&gt;

&lt;p&gt;The easiest way to work through deprecations is the &lt;strong&gt;Ember Inspector&lt;/strong&gt;. Thanks to the work of Teddy Zeenny, deprecations will be routed to the &amp;quot;Deprecations&amp;quot; inspector pane, where you can get a grouped list of them as well as the line of code in your app that triggered the deprecation. You can also ask for a full stack trace of any deprecation.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_improved-rerender-performance'&gt;Improved Rerender Performance&lt;/h4&gt;
&lt;p&gt;Previous iterations of Ember&amp;#39;s rendering engine &lt;strong&gt;relied&lt;/strong&gt; on granular observation for efficiency. When a piece of dynamic content was rendered, Ember registered observers, updating the content when the value changed.&lt;/p&gt;

&lt;p&gt;While this was reasonably efficient in cases where the developer could easily use &lt;code&gt;set&lt;/code&gt; (and the array equivalents) to mutate values, it had two related issues:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This forced developers to represent all changes in terms of granular
observers. In many cases this could be extremely awkward. This was
especially problematic when working with Arrays, since (for example)
representing a sort as a series of mutations is conceptually complex
and can be cost-prohibitive.&lt;/li&gt;
&lt;li&gt;Ember itself was extremely inefficient when an entire object or
array was replaced, despite the fact that this was often the most
natural way to represent the change. This meant that while it was
usually possible in theory to &amp;quot;just re-render&amp;quot; a component, it was,
in practice, cost prohibitive (to say the least).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To address these issues, Glimmer adopts a value-diffing strategy, using a virtual tree of the dynamic areas of the DOM. This means that even if the original data structure (for example, an array) is completely replaced, the DOM is not updated unless the resulting rendered content has changed.&lt;/p&gt;

&lt;p&gt;When updating an array with a new array (because you got a new array from the server, or because you produced a new array through &lt;code&gt;.sort()&lt;/code&gt;), you will see a large improvement in performance, &lt;strong&gt;making this kind of replacement plausible in Ember.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Notably, the Ember strategy continues to support efficient updates via value observation, which we expect to be useful when communicating with services and models.&lt;/p&gt;

&lt;p&gt;Glimmer&amp;#39;s hybrid model can opportunistically take advantage of explicit mutation (via &lt;code&gt;set&lt;/code&gt;) when it is used, while also supporting efficient re-renders of entire data structures, updating only the DOM  nodes that need to be changed.&lt;/p&gt;

&lt;p&gt;The result is a stunning improvement in many rerender cases.&lt;/p&gt;

&lt;p&gt;We would like to thank React for showing that full re-renders can be made efficient. While we did not use their precise Virtual DOM approach, their work with Virtual DOM was extremely influential to our approach in Glimmer.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/wycats"&gt;@wycats&lt;/a&gt; and &lt;a href="https://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt;
for their continued focus on improving
Glimmer&amp;#39;s performance, and to &lt;a href="http://www.linkedin.com"&gt;LinkedIn&lt;/a&gt; and
&lt;a href="http://www.bustle.com/"&gt;Bustle&lt;/a&gt; for their
generous sponsorship of this work.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_component-lifecycle-hooks'&gt;Component Lifecycle Hooks&lt;/h4&gt;
&lt;p&gt;A number of new component lifecycle hooks have been introduced to Ember 1.13.
Using these hooks allows you to write data down, action up (DDAU) style
components today, despite the two-way data binding of curly components.&lt;/p&gt;

&lt;p&gt;On first render (in order):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didInitAttrs&lt;/code&gt; runs after a component was created and passed attrs are guaranteed to be present. In Ember 1.13, the attributes will be available as &lt;code&gt;this.get(&amp;#39;attrName&amp;#39;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt; runs after &lt;code&gt;didInitAttrs&lt;/code&gt;, and it also runs on
subsequent re-renders, which is useful for logic that is the same
on all renders. It does not run when the component has been re-rendered from the inside.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt; runs before the template is rendered. It runs when the
template is updated for any reason (both initial and re-render, and
regardless of whether the change was caused by an attrs change or
re-render).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didInsertElement&lt;/code&gt; runs after the template has rendered and the
element is in the DOM.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt; runs after &lt;code&gt;didInsertElement&lt;/code&gt; (it also runs on subsequent
re-renders).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On re-render (in order):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didUpdateAttrs&lt;/code&gt; runs when the attributes of a component have changed
(but not when the component is re-rendered, via &lt;code&gt;component.rerender&lt;/code&gt;,
&lt;code&gt;component.set&lt;/code&gt;, or changes in models or services used by the
template).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt;, same as above.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willUpdate&lt;/code&gt; runs when the component is re-rendering for any reason,
including &lt;code&gt;component.rerender()&lt;/code&gt;, &lt;code&gt;component.set()&lt;/code&gt; or changes in
models or services used by the template.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt;, same as above&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didUpdate&lt;/code&gt; runs after the template has re-rendered and the DOM is
now up to date.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt;, same as above.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that a component is re-rendered whenever:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;any of its attributes change&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component.set()&lt;/code&gt; is called&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component.rerender()&lt;/code&gt; is called&lt;/li&gt;
&lt;li&gt;a property on a model or service used by the template has changed
(including through computed properties).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Because of the Glimmer engine, these re-renders are fast, and avoid
unnecessary work.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_closure-actions'&gt;Closure Actions&lt;/h4&gt;
&lt;p&gt;In Ember 1.x, the actions system used bubbling as a solution for passing user
behavior to a parent scope. For example, when clicking a button an action
might bubble through several controllers then be handled on a route.&lt;/p&gt;

&lt;p&gt;Action bubbling was difficult to debug, and plagued by an inability to have
a return value (since the return value of an action handler controlled further
bubbling).&lt;/p&gt;

&lt;p&gt;Ember 2.x is component-driven, and replaces action bubbling with a function-passing
solution. This greatly simplifies working with actions (they are just functions),
enables return values, and introduces some powerful new currying capabilities.&lt;/p&gt;

&lt;p&gt;For example, action &lt;code&gt;submit&lt;/code&gt; is passed to &lt;code&gt;my-component&lt;/code&gt; where it is called upon
click:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/controllers/index.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Controller.extend({
  &lt;span class="key"&gt;actions&lt;/span&gt;: {
    setName(name) {
      model.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, name);
    }
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/templates/index.hbs }}
{{my-component submit=(action 'setName')}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/components/my-component.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Component.extend({
  click() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.submit(&lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;));
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Actions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Can be passed multiple arguments&lt;/li&gt;
&lt;li&gt;Return a value. For example &lt;code&gt;var result = this.attrs.submit();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can curry. For example &lt;code&gt;submit=(action &amp;#39;setName&amp;#39; &amp;#39;Sal&amp;#39;)&lt;/code&gt; would pass &lt;code&gt;&amp;quot;Sal&amp;quot;&lt;/code&gt; as
the first argument to &lt;code&gt;setName&lt;/code&gt; when &lt;code&gt;submit&lt;/code&gt; is called. Actions can curry
multiple times, adding arguments at each scope. For example &lt;code&gt;submit=(action attrs.actionPassedIn someProp)&lt;/code&gt; just adds an argument to any already curried onto &lt;code&gt;actionPassedIn&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally the &lt;code&gt;action&lt;/code&gt; helper has two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(action &amp;#39;save&amp;#39; target=session)&lt;/code&gt; would look at the &lt;code&gt;actions&lt;/code&gt; hash on the
&lt;code&gt;session&lt;/code&gt; object instead of the current context.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(action &amp;#39;save&amp;#39; value=&amp;quot;currentTarget.value&amp;quot;)&lt;/code&gt; would read the path &lt;code&gt;currentTarget.value&lt;/code&gt;
off whatever the first argument to the called action is. This is handy for
destructuring objects passed as the first argument (like DOM events).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_note-angle-bracket-components'&gt;Note: Angle Bracket Components&lt;/h4&gt;
&lt;p&gt;Ember 2.1 will (likely) ship with angle-bracket components, which will introduce one-way data flow &lt;strong&gt;by default&lt;/strong&gt;, and provide an opt-in for two-way data flow. Existing components maintain the existing behavior (for compatibility). While the internals of Ember 2.0 support a distinction between one-way and two-way bindings, that distinction will remain largely internal until Ember 2.1.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_new-ember-js-helper-api'&gt;New Ember.js Helper API&lt;/h4&gt;
&lt;p&gt;Ember&amp;#39;s helper story prior to 1.13 has been inconsistent and neglected. In
1.13, we&amp;#39;re introducing a new API for writing helpers along with a set of
constraints and features informed by real-world experience.&lt;/p&gt;

&lt;p&gt;Ember helpers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Represent a single value&lt;/li&gt;
&lt;li&gt;Do not manage DOM or control flow&lt;/li&gt;
&lt;li&gt;Can recompute themselves, similar to how a component can rerender&lt;/li&gt;
&lt;li&gt;Can optionally access services&lt;/li&gt;
&lt;li&gt;Do not require a dash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Helpers come in two flavors. The first is a function-based API we call a
shorthand helper. For example, this shorthand helper joins a first and
last name:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/helpers/full-name.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Helper.helper(&lt;span class="keyword"&gt;function&lt;/span&gt;(params, hash) {
  &lt;span class="keyword"&gt;return&lt;/span&gt; params.join(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This helper can be used in a variety of contexts:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{full-name &amp;quot;Daniel&amp;quot; model.lastName}}
{{my-component name=(full-name model.firstName &amp;quot;Smith&amp;quot;)}}
{{! The following usage would set the model.name to the new full name
    when my-component calls the submit action. }}
{{my-component submit=(action (mut model.name) (full-name model.firstName &amp;quot;Smith&amp;quot;))}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Helpers receive two arguments: &lt;code&gt;params&lt;/code&gt; are the ordered params passed to a
helper, and &lt;code&gt;hash&lt;/code&gt; contains the key-value options, for example &lt;code&gt;title=&amp;quot;Mr.&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This function version satisfies a wide array of use-cases and is quite powerful. In general, you should use this helper form unless you have a strong reason to do otherwise.&lt;/p&gt;

&lt;p&gt;Some helpers, especially in addons, may require access to other parts of Ember (services), and
some control over their own invalidation and recomputation. In these cases, a helper class can be used.&lt;/p&gt;

&lt;p&gt;For example, this helper computes a name based on a &lt;code&gt;name-builder&lt;/code&gt; service. It
also recomputes whenever the &lt;code&gt;isAnonymized&lt;/code&gt; state on that service changes:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/helpers/full-name.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Helper.extend({
  &lt;span class="comment"&gt;// This service name is only an example&lt;/span&gt;
  &lt;span class="key"&gt;nameBuilder&lt;/span&gt;: Ember.service.inject(),
  compute(params, hash) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;nameBuilder&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).build(params, hash.title);
  },
  &lt;span class="key"&gt;rebuildName&lt;/span&gt;: Ember.observer(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;nameBuilder.isAnonymized&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.recompute();
  })
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For more information on the new helper API please see &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0053-helpers.md"&gt;RFC #53&lt;/a&gt; on helpers and &lt;a href="https://github.com/emberjs/rfcs/pull/58"&gt;RFC #58&lt;/a&gt;
on dashless helpers. Thanks to the addon community (especially &lt;a href="https://twitter.com/jamesarosen"&gt;@jamesarosen&lt;/a&gt;) for bringing the
requirements for this API to our attention and testing changes with little notice.
Thanks to &lt;a href="https://twitter.com/mixonic"&gt;@mixonic&lt;/a&gt;
and &lt;a href="https://twitter.com/rwjblue"&gt;@rwjblue&lt;/a&gt; for the implementation.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_component-block-info'&gt;Component Block Info&lt;/h4&gt;
&lt;p&gt;Ember.js 1.13 introduces two new template keywords that provide reflection on
how a component is called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hasBlock&lt;/code&gt; will be true when a component is invoked in block form. For example
given this component:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/components/show-full-name.hbs }}
{{#if hasBlock}}
  {{yield fullName}}
{{else}}
  {{fullName}}
{{/if}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then these two usages would be valid:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/index/template.hbs }}

Full name: {{show-full-name firstName=firstName lastName=lastName}}

{{#show-full-name firstName=firstName lastName=lastName as |fullName|}}
  Full name: {{fullName}}
{{/show-full-name}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Additionally, &lt;code&gt;hasBlockParams&lt;/code&gt; will be true if the component is invoked
with block params (invoke in block form with &lt;code&gt;as |someParam|&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/_mmun"&gt;@mmun&lt;/a&gt; and &lt;a href="https://twitter.com/rwjblue"&gt;@rwjblue&lt;/a&gt;
for implementing this feature.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_notable-deprecations-in-1-13'&gt;Notable Deprecations in 1.13&lt;/h4&gt;
&lt;p&gt;In preparation for Ember 2.0, 1.13 introduces many deprecations. These include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All view APIs in Ember. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-view"&gt;See deprecation guide&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.CoreView&lt;/code&gt;, &lt;code&gt;Ember.View&lt;/code&gt;, &lt;code&gt;Ember.CollectionView&lt;/code&gt;, &lt;code&gt;Ember.ContainerView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{view &amp;#39;some-helper&amp;#39;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view}}&lt;/code&gt; keyword for accessing properties on a view&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Select&lt;/code&gt; and &lt;code&gt;{{view &amp;quot;select&amp;quot;}}&lt;/code&gt;. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-select"&gt;See deprecation guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.LinkView&lt;/code&gt; in favor of &lt;code&gt;Ember.LinkComponent&lt;/code&gt;. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-linkview"&gt;See deprecation guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Options to the &lt;code&gt;{{#each&lt;/code&gt; helper that trigger a legacy and poorly performing
legacy layer. These options are: &lt;code&gt;itemView&lt;/code&gt;, &lt;code&gt;itemViewClass&lt;/code&gt;, &lt;code&gt;tagName&lt;/code&gt;, &lt;code&gt;emptyView&lt;/code&gt; and &lt;code&gt;emptyViewClass&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;itemController&lt;/code&gt; argument for &lt;code&gt;{{#each&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;bind-attr&lt;/code&gt; helper. Using helpers and HTMLBars-style attribute binding
is preferred.&lt;/li&gt;
&lt;li&gt;Reading &lt;code&gt;this.get(&amp;#39;template&amp;#39;)&lt;/code&gt; to check for a yielded block on components.
Instead, use the &lt;code&gt;hasBlock&lt;/code&gt; API.&lt;/li&gt;
&lt;li&gt;Non-block param &lt;code&gt;{{with&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;view&lt;/code&gt; and &lt;code&gt;viewClass&lt;/code&gt; params for &lt;code&gt;{{outlet}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.reduceComputed&lt;/code&gt; and &lt;code&gt;Ember.arrayComputed&lt;/code&gt; in favor of plain normal
array manipulations. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-reducecomputed-ember-arraycomputed"&gt;See deprecation guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_ember-2-0-beta'&gt;Ember 2.0 beta&lt;/h2&gt;
&lt;p&gt;Last November, @wycats and @tomdale published &lt;a href="https://github.com/emberjs/rfcs/pull/15"&gt;The Road to Ember 2.0&lt;/a&gt;,
an RFC summarizing Ember&amp;#39;s goals for a 2.0 release. At EmberConf, when some of
these changes were already complete and others not begun, they announced
our intent to ship 2.0 beta on June 12th.&lt;/p&gt;

&lt;p&gt;Together, the features summarized in the 2.0 RFC describe a new way to
author Ember applications. Model-View-Controller is replaced by
Model-Route-Component-Service. Two-way bindings are replaced by data down,
actions up (DDAU).&lt;/p&gt;

&lt;p&gt;Ember 2.0 will not introduce the entirety of our improved development model.
However it will take significant steps in that direction, and allow the
removal of public APIs that have been difficult to maintain while we
iterate forward.&lt;/p&gt;

&lt;p&gt;Because of the focus on landing migration paths for 1.x codebases in 1.13,
2.0 will have few new features. Among them are:&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_each-in-helper'&gt;each-in helper&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;each-in&lt;/code&gt; helper allows the iteration of object properties. For example,
given this value for &lt;code&gt;items&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;let items = {
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1234&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 2&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;3456&lt;/span&gt;
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following template will iterate the keys:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{#each-in items as |key value|}}
  &amp;lt;p&amp;gt;{{key}}: {{value}}&amp;lt;/p&amp;gt;
{{/each-in}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that this helper is unbound. Adding a new property to &lt;code&gt;items&lt;/code&gt; will not
cause a rerender, but &lt;code&gt;.set(&amp;#39;items&amp;#39;, val)&lt;/code&gt; will.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="http://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt; and implementing this
feature, and to several others for helping push it to completion.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_get-helper'&gt;get helper&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; helper provides a bound way to fetch a single property from an object.
For example given these items:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;let items = {
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1234&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 2&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;3456&lt;/span&gt;
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following template display &lt;code&gt;1234&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{get items 'Item 1'}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This becomes more powerful when the second argument is a bound path:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{get items somePathWithAKey}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Thanks to &lt;a href="https://twitter.com/jmurphyau"&gt;@jmurphyau&lt;/a&gt; for implementing this feature.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_notable-breaking-changes-in-ember-2-0'&gt;Notable Breaking Changes in Ember 2.0&lt;/h4&gt;
&lt;p&gt;Ember 2.0 will remove a number of public APIs, all of which should have been
deprecated in the 1.13 release and have a viable migration path. The Ember
&lt;a href="http://emberjs.com/deprecations/v1.x/"&gt;Deprecation Guide&lt;/a&gt; should provide a
clear migration path for commonly used APIs.&lt;/p&gt;

&lt;p&gt;During the 2.0 beta cycle we will be removing and disabling already
deprecated APIs. Much of this work has not yet started, but the following
represents what we believe the breaking changes will be.&lt;/p&gt;

&lt;p&gt;Many controller APIs are removed in Ember 2.0. Routeable controllers still
exist, but all other uses have been deprecated. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{render &amp;quot;some-controller&amp;quot;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{each item itemController=&amp;quot;some-controller&amp;quot;}}&lt;/code&gt; - This usage can be replaced
by nesting a component inside the item, and by using helpers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.ObjectController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.ArrayController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{controller}}&lt;/code&gt; keyword&lt;/li&gt;
&lt;li&gt;&lt;code&gt;needs:&lt;/code&gt; on controllers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All view APIs are removed in Ember 2.0. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.CoreView&lt;/code&gt;, &lt;code&gt;Ember.View&lt;/code&gt;, &lt;code&gt;Ember.ContainerView&lt;/code&gt; and &lt;code&gt;Ember.CollectionView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember._Metamorph&lt;/code&gt;, &lt;code&gt;Ember._MetamorphView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view &amp;quot;some-view&amp;quot;}}&lt;/code&gt; helper&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view}}&lt;/code&gt; keyword&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{each itemView=&lt;/code&gt;, &lt;code&gt;{{each itemViewClass=&lt;/code&gt;, &lt;code&gt;{{each tagName=&lt;/code&gt;, &lt;code&gt;{{each emptyView=&lt;/code&gt;, &lt;code&gt;{{each emptyViewClass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Select&lt;/code&gt; and &lt;code&gt;{{view &amp;quot;select&amp;quot;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Checkbox&lt;/code&gt; is not removed, but will become a component instead of a view&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The most commonly used parts of the &lt;code&gt;view&lt;/code&gt; API will be supported into the forseeable future via a core-supported addon.&lt;/p&gt;

&lt;p&gt;All Handlebars APIs are removed in Ember 2.0. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;, &lt;code&gt;Ember.Handlebars.makeBoundHelper&lt;/code&gt; and &lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Handlebars.compile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Several template helpers are removed in Ember 2.0. These include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{bindAttr}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{bind-attr}}&lt;/code&gt; (use HTMLBars-style attribute bindings instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{bind}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{template}}&lt;/code&gt; (use &lt;code&gt;{{partial}}&lt;/code&gt; instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{linkTo}}&lt;/code&gt; (use &lt;code&gt;{{link-to}}&lt;/code&gt; instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{collection items}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Non-block params versions of &lt;code&gt;{{#each}}&lt;/code&gt; and &lt;code&gt;{{#with}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Legacy arguments to &lt;code&gt;{{#each}}&lt;/code&gt;, &lt;code&gt;{{outlet}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following routing APIs are removed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#hash&lt;/code&gt; paths with no forward leading slash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other APIs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.tryFinally&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.tryCatchFinally&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.required&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Map#remove&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.computed.defaultTo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.DeferredMixin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Deferred&lt;/code&gt; (use &lt;code&gt;Ember.RSVP.Promise&lt;/code&gt; instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.reduceComputed&lt;/code&gt; and &lt;code&gt;Ember.arrayComputed&lt;/code&gt; (use plain array manipulation)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Freezable&lt;/code&gt; (use Object.freeze instead)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, IE8 is no longer supported in Ember 2.x. IE9+ is supported.&lt;/p&gt;

&lt;p&gt;Many of these deprecated APIs will be moved into core-supported addons, or have already been moved.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_changelogs'&gt;Changelogs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.13.0/CHANGELOG.md"&gt;Ember.js 1.13.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v2.0.0-beta.1/CHANGELOG.md"&gt;Ember.js 2.0.0-beta.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.19.1 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/09/ember-data-1-0-beta-19-1-released.html"/>
    <id>http://emberjs.com/blog/2015/06/09/ember-data-1-0-beta-19-1-released.html</id>
    <published>2015-06-08T20:00:00-04:00</published>
    <updated>2015-06-08T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember Data 19.1 contains fixes for a few regressions. Thanks to everyone
who reported issues. Thanks to @bmac and @wecc for fixing!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fix a regression where a &lt;code&gt;DS.Model&lt;/code&gt;'s &lt;code&gt;InternalModel&lt;/code&gt; would not be set
on init - @bmac &lt;a href="https://github.com/emberjs/data/pull/3262"&gt;Pull Request&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Pass store to inverseFor...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;Ember Data 19.1 contains fixes for a few regressions. Thanks to everyone
who reported issues. Thanks to @bmac and @wecc for fixing!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fix a regression where a &lt;code&gt;DS.Model&lt;/code&gt;&amp;#39;s &lt;code&gt;InternalModel&lt;/code&gt; would not be set
on init - @bmac &lt;a href="https://github.com/emberjs/data/pull/3262"&gt;Pull Request&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pass store to inverseFor in removeEmbeddedForeignKey #3270 - @wecc
&lt;a href="https://github.com/emberjs/data/pull/3270"&gt;Pull Request&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.19 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/05/ember-data-1-0-beta-19-released.html"/>
    <id>http://emberjs.com/blog/2015/06/05/ember-data-1-0-beta-19-released.html</id>
    <published>2015-06-04T20:00:00-04:00</published>
    <updated>2015-06-04T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember Data 1.0.0-beta.19 contains a lot of bugfixes from the comunity!
Thank you for helping us push toward a stable release of Ember Data!&lt;/p&gt;
&lt;h2 class="anchorable-toc" id="toc_new-features"&gt;New Features&lt;/h2&gt;&lt;h3 class="anchorable-toc" id="toc_snapshots-have-changedattributes"&gt;Snapshots have changedAttributes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;changedAttributes&lt;/code&gt;, which represents the changes that have happened...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Ember Data 1.0.0-beta.19 contains a lot of bugfixes from the comunity!
Thank you for helping us push toward a stable release of Ember Data!&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features'&gt;New Features&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_snapshots-have-changedattributes'&gt;Snapshots have changedAttributes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;changedAttributes&lt;/code&gt;, which represents the changes that have happened
since the model was last synced with the server, are now available on
the snapshot in your adapters and serializers, instead of just on
&lt;code&gt;DS.Model&lt;/code&gt; instances.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_breaking-changes'&gt;Breaking Changes&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_passing-classes-to-store-methods'&gt;Passing Classes to Store Methods&lt;/h3&gt;
&lt;p&gt;Previously, you were allowed to pass a classes directly to store methods
like &lt;code&gt;store.push&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; record = store.push(App.Post, {&lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While this isn&amp;#39;t a very popular way and generally not recommended in the
documentation, it did remain the preferred way to do things in Ember
Data&amp;#39;s tests for a long time. As we move toward to using Ember&amp;#39;s
Dependency Injection framework for consistency, passing these classes
directly to store methods has been removed. Instead, you should pass a
dasherized string:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; record = store.push(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, {&lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To help you upgrade through this change easily, we&amp;#39;ve written an &lt;a href="https://github.com/abuiles/ember-watson#ember-watsonconvert-ember-data-model-lookups"&gt;Ember
Watson command&lt;/a&gt;.
You can use this command-line tool in both Ember-CLI projects and
&amp;quot;globals mode&amp;quot; style projects.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_services-depending-on-the-store'&gt;Services depending on the store&lt;/h3&gt;
&lt;p&gt;In order to fix deprecations warning induced by Ember 1.12, the store service is now injected as an
&lt;a href="http://emberjs.com/blog/2015/05/13/ember-1-12-released.html#toc_instance-initializers"&gt;instanceInitializer&lt;/a&gt;.
As a consequence, if you had initializers depending on the store, you should move&lt;br&gt;
them to an instance initializer as well, and mark it as &lt;code&gt;after: &amp;#39;ember-data&amp;#39;&lt;/code&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_important-deprecations'&gt;Important Deprecations&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_fixture-adapter-removed'&gt;Fixture Adapter Removed&lt;/h3&gt;
&lt;p&gt;Support for the Fixture Adapter has been deprecated. After some thought,
the Ember Data team decided it was not the right approach for
integration-style tests. We recommend using an AJAX/data transport
stubbing strategy like &lt;a href="https://github.com/trek/pretender"&gt;Pretender&lt;/a&gt; or
&lt;a href="http://sinonjs.org/"&gt;sinon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll be including docs on integration test strategies using Pretender in the
final release.&lt;/p&gt;

&lt;p&gt;The Fixture Adapter now lives as an &lt;a href="https://github.com/emberjs/ember-data-fixture-adapter"&gt;addon&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_internet-explorer-8'&gt;Internet Explorer 8&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;This will be the last release to support Internet
Explorer 8. Future versions of Ember Data will not support Internet
Explorer 8&lt;/s&gt;&lt;/p&gt;

&lt;p&gt;Update:
&lt;a href="/blog/2015/06/18/ember-data-1-13-released.html"&gt;Ember Data 1.13&lt;/a&gt; has
been released with support for IE8. Ember Data 1.13 is the last
version of Ember Data that supports IE8. Ember Data 2.0 supports IE9+.&lt;/p&gt;
</content>
  </entry>
</feed>
