<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember Blog</title>
  <subtitle>Ember News and Updates</subtitle>
  <id>http://emberjs.com/blog</id>
  <link href="http://emberjs.com/blog"/>
  <link href="http://emberjs.com/blog/feed.xml" rel="self"/>
  <updated>2015-06-11T20:00:00-04:00</updated>
  <author>
    <name>Ember</name>
  </author>
  <entry>
    <title>Ember.js 1.13.0 and 2.0 Beta Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html"/>
    <id>http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html</id>
    <published>2015-06-11T20:00:00-04:00</published>
    <updated>2015-06-11T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We are pleased to announce the release of both Ember.js 1.13.0 and the
first beta in the 2.0 series. This comes as the thirteenth cycle of our
release process that began just after 1.0 was released.&lt;/p&gt;

&lt;p&gt;The 1.13 release represents the effort of at least...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We are pleased to announce the release of both Ember.js 1.13.0 and the
first beta in the 2.0 series. This comes as the thirteenth cycle of our
release process that began just after 1.0 was released.&lt;/p&gt;

&lt;p&gt;The 1.13 release represents the effort of at least 43 contributors
across over 680 commits.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 1.13 is the last release in the 1.x series and the first release that includes the Glimmer rendering engine.&lt;/strong&gt; It includes a number of deprecations that will ease the upgrade to Ember 2.0, which is due to land in six weeks.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 2.0 beta is the first release in the 2.x series.&lt;/strong&gt; This means that many features deprecated during the 1.x series will be removed in Ember 2.0. If you encounter any unexpected changes in features not marked as deprecated in 1.13 while testing Ember 2.0 beta, please report them immediately. We would like to fix these unintentional regressions before the final release of 2.0 in six weeks.&lt;/p&gt;

&lt;p&gt;The release of Ember 2.0 beta also means that the first features in Ember 2.1 (most notably angle bracket components), are in their final canary stretch. Now is a good time to comment on RFCs and pull requests related to those features.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features-in-ember-js-1-13'&gt;New Features in Ember.js 1.13&lt;/h2&gt;
&lt;p&gt;The Glimmer rendering engine, &lt;a href="https://www.youtube.com/watch?v=o12-90Dm-Qs&amp;amp;feature=youtu.be&amp;amp;t=47m21s"&gt;announced at EmberConf&lt;/a&gt; and introduced to Ember.js
Canary on &lt;a href="/blog/2015/05/05/glimmer-merging.html"&gt;May 5th&lt;/a&gt;, is released today
in Ember.js 1.13. Glimmer is the third overhaul of Ember&amp;#39;s 1.x rendering
layer (wow, right?), and dramatically improves re-render performance in many
common scenarios. Additionally it lays important groundwork for the Ember 2.x
development model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We are tremendously excited to bring Glimmer to existing applications as
a 1.x compatible minor release.&lt;/strong&gt; The herculean efforts of the Ember core team,
addon authors, and community to achieve this release has been inspiring.
Thank you! You are too many to possibly name.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.13 also marks the final minor release of the Ember 1.x cycle.&lt;/strong&gt; As such,
it contains a number of deprecations ahead of Ember 2.0. Resolving these
deprecations in application code aligns that application with Ember&amp;#39;s public
API in 2.0. In general, Ember apps running 1.13 without causing any deprecation notices
to fire should upgrade to 2.0 without changes.&lt;/p&gt;

&lt;p&gt;The easiest way to work through deprecations is the &lt;strong&gt;Ember Inspector&lt;/strong&gt;. Thanks to the work of Teddy Zeenny, deprecations will be routed to the &amp;quot;Deprecations&amp;quot; inspector pane, where you can get a grouped list of them as well as the line of code in your app that triggered the deprecation. You can also ask for a full stack trace of any deprecation.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_improved-rerender-performance'&gt;Improved Rerender Performance&lt;/h4&gt;
&lt;p&gt;Previous iterations of Ember&amp;#39;s rendering engine &lt;strong&gt;relied&lt;/strong&gt; on granular observation for efficiency. When a piece of dynamic content was rendered, Ember registered observers, updating the content when the value changed.&lt;/p&gt;

&lt;p&gt;While this was reasonably efficient in cases where the developer could easily use &lt;code&gt;set&lt;/code&gt; (and the array equivalents) to mutate values, it had two related issues:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This forced developers to represent all changes in terms of granular
observers. In many cases this could be extremely awkward. This was
especially problematic when working with Arrays, since (for example)
representing a sort as a series of mutations is conceptually complex
and can be cost-prohibitive.&lt;/li&gt;
&lt;li&gt;Ember itself was extremely inefficient when an entire object or
array was replaced, despite the fact that this was often the most
natural way to represent the change. This meant that while it was
usually possible in theory to &amp;quot;just re-render&amp;quot; a component, it was,
in practice, cost prohibitive (to say the least).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To address these issues, Glimmer adopts a value-diffing strategy, using a virtual tree of the dynamic areas of the DOM. This means that even if the original data structure (for example, an array) is completely replaced, the DOM is not updated unless the resulting rendered content has changed.&lt;/p&gt;

&lt;p&gt;When updating an array with a new array (because you got a new array from the server, or because you produced a new array through &lt;code&gt;.sort()&lt;/code&gt;), you will see a large improvement in performance, &lt;strong&gt;making this kind of replacement plausible in Ember.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Notably, the Ember strategy continues to support efficient updates via value observation, which we expect to be useful when communicating with services and models.&lt;/p&gt;

&lt;p&gt;Glimmer&amp;#39;s hybrid model can opportunistically take advantage of explicit mutation (via &lt;code&gt;set&lt;/code&gt;) when it is used, while also supporting efficient re-renders of entire data structures, updating only the DOM  nodes that need to be changed.&lt;/p&gt;

&lt;p&gt;The result is a stunning improvement in many rerender cases.&lt;/p&gt;

&lt;p&gt;We would like to thank React for showing that full re-renders can be made efficient. While we did not use their precise Virtual DOM approach, their work with Virtual DOM was extremely influential to our approach in Glimmer.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/wycats"&gt;@wycats&lt;/a&gt; and &lt;a href="https://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt;
for their continued focus on improving
Glimmer&amp;#39;s performance, and to &lt;a href="http://www.linkedin.com"&gt;LinkedIn&lt;/a&gt; and
&lt;a href="http://www.bustle.com/"&gt;Bustle&lt;/a&gt; for their
generous sponsorship of this work.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_component-lifecycle-hooks'&gt;Component Lifecycle Hooks&lt;/h4&gt;
&lt;p&gt;A number of new component lifecycle hooks have been introduced to Ember 1.13.
Using these hooks allows you to write data down, action up (DDAU) style
components today, despite the two-way data binding of curly components.&lt;/p&gt;

&lt;p&gt;On first render (in order):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didInitAttrs&lt;/code&gt; runs after a component was created and passed attrs are guaranteed to be present. In Ember 1.13, the attributes will be available as &lt;code&gt;this.get(&amp;#39;attrName&amp;#39;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt; runs after &lt;code&gt;didInitAttrs&lt;/code&gt;, and it also runs on
subsequent re-renders, which is useful for logic that is the same
on all renders. It does not run when the component has been re-rendered from the inside.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt; runs before the template is rendered. It runs when the
template is updated for any reason (both initial and re-render, and
regardless of whether the change was caused by an attrs change or
re-render).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didInsertElement&lt;/code&gt; runs after the template has rendered and the
element is in the DOM.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt; runs after &lt;code&gt;didInsertElement&lt;/code&gt; (it also runs on subsequent
re-renders).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On re-render (in order):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didUpdateAttrs&lt;/code&gt; runs when the attributes of a component have changed
(but not when the component is re-rendered, via &lt;code&gt;component.rerender&lt;/code&gt;,
&lt;code&gt;component.set&lt;/code&gt;, or changes in models or services used by the
template).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt;, same as above.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willUpdate&lt;/code&gt; runs when the component is re-rendering for any reason,
including &lt;code&gt;component.rerender()&lt;/code&gt;, &lt;code&gt;component.set()&lt;/code&gt; or changes in
models or services used by the template.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt;, same as above&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didUpdate&lt;/code&gt; runs after the template has re-rendered and the DOM is
now up to date.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt;, same as above.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that a component is re-rendered whenever:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;any of its attributes change&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component.set()&lt;/code&gt; is called&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component.rerender()&lt;/code&gt; is called&lt;/li&gt;
&lt;li&gt;a property on a model or service used by the template has changed
(including through computed properties).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Because of the Glimmer engine, these re-renders are fast, and avoid
unnecessary work.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_closure-actions'&gt;Closure Actions&lt;/h4&gt;
&lt;p&gt;In Ember 1.x, the actions system used bubbling as a solution for passing user
behavior to a parent scope. For example, when clicking a button an action
might bubble through several controllers then be handled on a route.&lt;/p&gt;

&lt;p&gt;Action bubbling was difficult to debug, and plagued by an inability to have
a return value (since the return value of an action handler controlled further
bubbling).&lt;/p&gt;

&lt;p&gt;Ember 2.x is component-driven, and replaces action bubbling with a function-passing
solution. This greatly simplifies working with actions (they are just functions),
enables return values, and introduces some powerful new currying capabilities.&lt;/p&gt;

&lt;p&gt;For example, action &lt;code&gt;submit&lt;/code&gt; is passed to &lt;code&gt;my-component&lt;/code&gt; where it is called upon
click:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/controllers/index.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Controller.extend({
  &lt;span class="key"&gt;actions&lt;/span&gt;: {
    setName(name) {
      model.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, name);
    }
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/templates/index.hbs }}
{{my-component submit=(action 'setName')}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/components/my-component.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Component.extend({
  click() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.submit(&lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;));
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Actions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Can be passed multiple arguments&lt;/li&gt;
&lt;li&gt;Return a value. For example &lt;code&gt;var result = this.attrs.submit();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can curry. For example &lt;code&gt;submit=(action &amp;#39;setName&amp;#39; &amp;#39;Sal&amp;#39;)&lt;/code&gt; would pass &lt;code&gt;&amp;quot;Sal&amp;quot;&lt;/code&gt; as
the first argument to &lt;code&gt;setName&lt;/code&gt; when &lt;code&gt;submit&lt;/code&gt; is called. Actions can curry
multiple times, adding arguments at each scope. For example &lt;code&gt;submit=(action attrs.actionPassedIn someProp)&lt;/code&gt; just adds an argument to any already curried onto &lt;code&gt;actionPassedIn&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally the &lt;code&gt;action&lt;/code&gt; helper has two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(action &amp;#39;save&amp;#39; target=session)&lt;/code&gt; would look at the &lt;code&gt;actions&lt;/code&gt; hash on the
&lt;code&gt;session&lt;/code&gt; object instead of the current context.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(action &amp;#39;save&amp;#39; value=&amp;quot;currentTarget.value&amp;quot;)&lt;/code&gt; would read the path &lt;code&gt;currentTarget.value&lt;/code&gt;
off whatever the first argument to the called action is. This is handy for
destructuring objects passed as the first argument (like DOM events).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_note-angle-bracket-components'&gt;Note: Angle Bracket Components&lt;/h4&gt;
&lt;p&gt;Ember 2.1 will (likely) ship with angle-bracket components, which will introduce one-way data flow &lt;strong&gt;by default&lt;/strong&gt;, and provide an opt-in for two-way data flow. Existing components maintain the existing behavior (for compatibility). While the internals of Ember 2.0 support a distinction between one-way and two-way bindings, that distinction will remain largely internal until Ember 2.1.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_new-ember-js-helper-api'&gt;New Ember.js Helper API&lt;/h4&gt;
&lt;p&gt;Ember&amp;#39;s helper story prior to 1.13 has been inconsistent and neglected. In
1.13, we&amp;#39;re introducing a new API for writing helpers along with a set of
constraints and features informed by real-world experience.&lt;/p&gt;

&lt;p&gt;Ember helpers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Represent a single value&lt;/li&gt;
&lt;li&gt;Do not manage DOM or control flow&lt;/li&gt;
&lt;li&gt;Can recompute themselves, similar to how a component can rerender&lt;/li&gt;
&lt;li&gt;Can optionally access services&lt;/li&gt;
&lt;li&gt;Do not require a dash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Helpers come in two flavors. The first is a function-based API we call a
shorthand helper. For example, this shorthand helper joins a first and
last name:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/helpers/full-name.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Helper.helper(&lt;span class="keyword"&gt;function&lt;/span&gt;(params, hash) {
  &lt;span class="keyword"&gt;return&lt;/span&gt; params.join(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This helper can be used in a variety of contexts:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{full-name &amp;quot;Daniel&amp;quot; model.lastName}}
{{my-component name=(full-name model.firstName &amp;quot;Smith&amp;quot;)}}
{{! The following usage would set the model.name to the new full name
    when my-component calls the submit action. }}
{{my-component submit=(action (mut model.name) (full-name model.firstName &amp;quot;Smith&amp;quot;))}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Helpers receive two arguments: &lt;code&gt;params&lt;/code&gt; are the ordered params passed to a
helper, and &lt;code&gt;hash&lt;/code&gt; contains the key-value options, for example &lt;code&gt;title=&amp;quot;Mr.&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This function version satisfies a wide array of use-cases and is quite powerful. In general, you should use this helper form unless you have a strong reason to do otherwise.&lt;/p&gt;

&lt;p&gt;Some helpers, especially in addons, may require access to other parts of Ember (services), and
some control over their own invalidation and recomputation. In these cases, a helper class can be used.&lt;/p&gt;

&lt;p&gt;For example, this helper computes a name based on a &lt;code&gt;name-builder&lt;/code&gt; service. It
also recomputes whenever the &lt;code&gt;isAnonymized&lt;/code&gt; state on that service changes:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/helpers/full-name.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Helper.extend({
  &lt;span class="comment"&gt;// This service name is only an example&lt;/span&gt;
  &lt;span class="key"&gt;nameBuilder&lt;/span&gt;: Ember.service.inject(),
  compute(params, hash) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;nameBuilder&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).build(params, hash.title);
  },
  &lt;span class="key"&gt;rebuildName&lt;/span&gt;: Ember.observer(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;nameBuilder.isAnonymized&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.recompute();
  })
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For more information on the new helper API please see &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0053-helpers.md"&gt;RFC #53&lt;/a&gt; on helpers and &lt;a href="https://github.com/emberjs/rfcs/pull/58"&gt;RFC #58&lt;/a&gt;
on dashless helpers. Thanks to the addon community (especially &lt;a href="https://twitter.com/jamesarosen"&gt;@jamesarosen&lt;/a&gt;) for bringing the
requirements for this API to our attention and testing changes with little notice.
Thanks to &lt;a href="https://twitter.com/mixonic"&gt;@mixonic&lt;/a&gt;
and &lt;a href="https://twitter.com/rwjblue"&gt;@rwjblue&lt;/a&gt; for the implementation.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_component-block-info'&gt;Component Block Info&lt;/h4&gt;
&lt;p&gt;Ember.js 1.13 introduces two new template keywords that provide reflection on
how a component is called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hasBlock&lt;/code&gt; will be true when a component is invoked in block form. For example
given this component:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/components/show-full-name }}
{{if hasBlock}}
  {{yield fullName}}
{{else}}
  {{fullName}}
{{/if}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then these two usages would be valid:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/index/template.hbs }}

Full name: {{show-full-name firstName=firstName lastName=lastName}}

{{#show-full-name firstName=firstName lastName=lastName as |fullName|}}
  Full name: {{fullName}}
{{/show-full-name}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Additionally, &lt;code&gt;hasBlockParams&lt;/code&gt; will be true if the component is invoked
with block params (invoke in block form with &lt;code&gt;as |someParam|&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/_mmun"&gt;@mmun&lt;/a&gt; and &lt;a href="https://twitter.com/rwjblue"&gt;@rwjblue&lt;/a&gt;
for implementing this feature.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_notable-deprecations-in-1-13'&gt;Notable Deprecations in 1.13&lt;/h4&gt;
&lt;p&gt;In preparation for Ember 2.0, 1.13 introduces many deprecations. These include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All view APIs in Ember

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.CoreView&lt;/code&gt;, &lt;code&gt;Ember.View&lt;/code&gt;, &lt;code&gt;Ember.CollectionView&lt;/code&gt;, &lt;code&gt;Ember.ContainerView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{view &amp;#39;some-helper&amp;#39;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view}}&lt;/code&gt; keyword for accessing properties on a view&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Select&lt;/code&gt; and &lt;code&gt;{{view &amp;quot;select&amp;quot;}}&lt;/code&gt;.
Options to the &lt;code&gt;{{#each&lt;/code&gt; helper that trigger a legacy and poorly performing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Options to the &lt;code&gt;{{#each&lt;/code&gt; helper that trigger a legacy and poorly performing
legacy layer. These options are: &lt;code&gt;itemView&lt;/code&gt;, &lt;code&gt;itemViewClass&lt;/code&gt;, &lt;code&gt;tagName&lt;/code&gt;, &lt;code&gt;emptyView&lt;/code&gt; and &lt;code&gt;emptyViewClass&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;itemController&lt;/code&gt; argument for &lt;code&gt;{{#each&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;bind-attr&lt;/code&gt; helper. Using helpers and HTMLBars-style attribute binding
is preferred.&lt;/li&gt;
&lt;li&gt;Reading &lt;code&gt;this.get(&amp;#39;template&amp;#39;)&lt;/code&gt; to check for a yielded block on components.
Instead, use the &lt;code&gt;hasBlock&lt;/code&gt; API.&lt;/li&gt;
&lt;li&gt;Non-block param &lt;code&gt;{{with&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;view&lt;/code&gt; and &lt;code&gt;viewClass&lt;/code&gt; params for &lt;code&gt;{{outlet}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_ember-2-0-beta'&gt;Ember 2.0 beta&lt;/h2&gt;
&lt;p&gt;Last November, @wycats and @tomdale published &lt;a href="https://github.com/emberjs/rfcs/pull/15"&gt;The Road to Ember 2.0&lt;/a&gt;,
an RFC summarizing Ember&amp;#39;s goals for a 2.0 release. At EmberConf, when some of
these changes were already complete and others not begun, they announced
our intent to ship 2.0 beta on June 12th.&lt;/p&gt;

&lt;p&gt;Together, the features summarized in the 2.0 RFC describe a new way to
author Ember applications. Model-View-Controller is replaced by
Model-Route-Component-Service. Two-way bindings are replaced by data down,
actions up (DDAU).&lt;/p&gt;

&lt;p&gt;Ember 2.0 will not introduce the entirety of our improved development model.
However it will take significant steps in that direction, and allow the
removal of public APIs that have been difficult to maintain while we
iterate forward.&lt;/p&gt;

&lt;p&gt;Because of the focus on landing migration paths for 1.x codebases in 1.13,
2.0 will have few new features. Among them are:&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_each-in-helper'&gt;each-in helper&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;each-in&lt;/code&gt; helper allows the iteration of object properties. For example,
given this value for &lt;code&gt;items&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;let items = {
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1234&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 2&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;3456&lt;/span&gt;
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following template will iterate the keys:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{#each-in items as |key value|}}
  &amp;lt;p&amp;gt;{{key}}: {{value}}&amp;lt;/p&amp;gt;
{{/each-in}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that this helper is unbound. Adding a new property to &lt;code&gt;items&lt;/code&gt; will not
cause a rerender, but &lt;code&gt;.set(&amp;#39;items&amp;#39;, val)&lt;/code&gt; will.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="http://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt; and implementing this
feature, and to several others for helping push it to completion.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_get-helper'&gt;get helper&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; helper provides a bound way to fetch a single property from an object.
For example given these items:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;let items = {
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1234&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 2&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;3456&lt;/span&gt;
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following template display &lt;code&gt;1234&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{get items 'Item 1'}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This becomes more powerful when the second argument is a bound path:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{get items somePathWithAKey}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Thanks to &lt;a href="https://twitter.com/jmurphyau"&gt;@jmurphyau&lt;/a&gt; for implementing this feature.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_notable-breaking-changes-in-ember-2-0'&gt;Notable Breaking Changes in Ember 2.0&lt;/h4&gt;
&lt;p&gt;Ember 2.0 will remove a number of public APIs, all of which should have been
deprecated in the 1.13 release and have a viable migration path. The Ember
&lt;a href="http://emberjs.com/deprecations/v1.x/"&gt;Deprecation Guide&lt;/a&gt; should provide a
clear migration path for commonly used APIs.&lt;/p&gt;

&lt;p&gt;During the 2.0 beta cycle we will be removing and disabling already
deprecated APIs. Much of this work has not yet started, but the following
represents what we believe the breaking changes will be.&lt;/p&gt;

&lt;p&gt;Many controller APIs are removed in Ember 2.0. Routeable controllers still
exist, but all other uses have been deprecated. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{render &amp;quot;some-controller&amp;quot;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{each item itemController=&amp;quot;some-controller&amp;quot;}}&lt;/code&gt; - This usage can be replaced
by nesting a component inside the item, and by using helpers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.ObjectController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.ArrayController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{controller}}&lt;/code&gt; keyword&lt;/li&gt;
&lt;li&gt;&lt;code&gt;needs:&lt;/code&gt; on controllers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All view APIs are removed in Ember 2.0. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.CoreView&lt;/code&gt;, &lt;code&gt;Ember.View&lt;/code&gt;, &lt;code&gt;Ember.ContainerView&lt;/code&gt; and &lt;code&gt;Ember.CollectionView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember._Metamorph&lt;/code&gt;, &lt;code&gt;Ember._MetamorphView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view &amp;quot;some-view&amp;quot;}}&lt;/code&gt; helper&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view}}&lt;/code&gt; keyword&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{each itemView=&lt;/code&gt;, &lt;code&gt;{{each itemViewClass=&lt;/code&gt;, &lt;code&gt;{{each tagName=&lt;/code&gt;, &lt;code&gt;{{each emptyView=&lt;/code&gt;, &lt;code&gt;{{each emptyViewClass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Select&lt;/code&gt; and &lt;code&gt;{{view &amp;quot;select&amp;quot;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Checkbox&lt;/code&gt; is not removed, but will become a component instead of a view&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The most commonly used parts of the &lt;code&gt;view&lt;/code&gt; API will be supported into the forseeable future via a core-supported addon.&lt;/p&gt;

&lt;p&gt;All Handlebars APIs are removed in Ember 2.0. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;, &lt;code&gt;Ember.Handlebars.makeBoundHelper&lt;/code&gt; and &lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Handlebars.compile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Several template helpers are removed in Ember 2.0. These include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{bindAttr}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{bind-attr}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{bind}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{template}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{linkTo}}&lt;/code&gt; (use &lt;code&gt;{{link-to}}&lt;/code&gt; instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{collection items}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Non-block params versions of &lt;code&gt;{{#each}}&lt;/code&gt; and &lt;code&gt;{{#with}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Legacy arguments to &lt;code&gt;{{#each}}&lt;/code&gt;, &lt;code&gt;{{outlet}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following routing APIs are removed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#hash&lt;/code&gt; paths with no forward leading slash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other APIs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.tryFinally&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.tryCatchFinally&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.required&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Map#remove&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.computed.defaultTo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.DeferredMixin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Deferred&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, IE8 is no longer supported in Ember 2.x. IE9+ is supported.&lt;/p&gt;

&lt;p&gt;Many of these deprecated APIs will be moved into core-supported addons, or have already been moved.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_changelogs'&gt;Changelogs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.13.0/CHANGELOG.md"&gt;Ember.js 1.13.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v2.0.0-beta.1/CHANGELOG.md"&gt;Ember.js 2.0.0-beta.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.19.1 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/09/ember-data-1-0-beta-19-1-released.html"/>
    <id>http://emberjs.com/blog/2015/06/09/ember-data-1-0-beta-19-1-released.html</id>
    <published>2015-06-08T20:00:00-04:00</published>
    <updated>2015-06-08T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember Data 19.1 contains fixes for a few regressions. Thanks to everyone
who reported issues. Thanks to @bmac and @wecc for fixing!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fix a regression where a &lt;code&gt;DS.Model&lt;/code&gt;'s &lt;code&gt;InternalModel&lt;/code&gt; would not be set
on init - @bmac &lt;a href="https://github.com/emberjs/data/pull/3262"&gt;Pull Request&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Pass store to inverseFor...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;Ember Data 19.1 contains fixes for a few regressions. Thanks to everyone
who reported issues. Thanks to @bmac and @wecc for fixing!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fix a regression where a &lt;code&gt;DS.Model&lt;/code&gt;&amp;#39;s &lt;code&gt;InternalModel&lt;/code&gt; would not be set
on init - @bmac &lt;a href="https://github.com/emberjs/data/pull/3262"&gt;Pull Request&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pass store to inverseFor in removeEmbeddedForeignKey #3270 - @wecc
&lt;a href="https://github.com/emberjs/data/pull/3270"&gt;Pull Request&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.19 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/05/ember-data-1-0-beta-19-released.html"/>
    <id>http://emberjs.com/blog/2015/06/05/ember-data-1-0-beta-19-released.html</id>
    <published>2015-06-04T20:00:00-04:00</published>
    <updated>2015-06-04T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember Data 1.0.0-beta.19 contains a lot of bugfixes from the comunity!
Thank you for helping us push toward a stable release of Ember Data!&lt;/p&gt;
&lt;h2 class="anchorable-toc" id="toc_new-features"&gt;New Features&lt;/h2&gt;&lt;h3 class="anchorable-toc" id="toc_snapshots-have-changedattributes"&gt;Snapshots have changedAttributes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;changedAttributes&lt;/code&gt;, which represents the changes that have happened...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Ember Data 1.0.0-beta.19 contains a lot of bugfixes from the comunity!
Thank you for helping us push toward a stable release of Ember Data!&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features'&gt;New Features&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_snapshots-have-changedattributes'&gt;Snapshots have changedAttributes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;changedAttributes&lt;/code&gt;, which represents the changes that have happened
since the model was last synced with the server, are now available on
the snapshot in your adapters and serializers, instead of just on
&lt;code&gt;DS.Model&lt;/code&gt; instances.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_breaking-changes'&gt;Breaking Changes&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_passing-classes-to-store-methods'&gt;Passing Classes to Store Methods&lt;/h3&gt;
&lt;p&gt;Previously, you were allowed to pass a classes directly to store methods
like &lt;code&gt;store.push&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; record = store.push(App.Post, {&lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While this isn&amp;#39;t a very popular way and generally not recommended in the
documentation, it did remain the preferred way to do things in Ember
Data&amp;#39;s tests for a long time. As we move toward to using Ember&amp;#39;s
Dependency Injection framework for consistency, passing these classes
directly to store methods has been removed. Instead, you should pass a
dasherized string:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; record = store.push(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, {&lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To help you upgrade through this change easily, we&amp;#39;ve written an &lt;a href="https://github.com/abuiles/ember-watson#ember-watsonconvert-ember-data-model-lookups"&gt;Ember
Watson command&lt;/a&gt;.
You can use this command-line tool in both Ember-CLI projects and
&amp;quot;globals mode&amp;quot; style projects.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_services-depending-on-the-store'&gt;Services depending on the store&lt;/h3&gt;
&lt;p&gt;In order to fix deprecations warning induced by Ember 1.12, the store service is now injected as an
&lt;a href="http://emberjs.com/blog/2015/05/13/ember-1-12-released.html#toc_instance-initializers"&gt;instanceInitializer&lt;/a&gt;.
As a consequence, if you had initializers depending on the store, you should move&lt;br&gt;
them to an instance initializer as well, and mark it as &lt;code&gt;after: &amp;#39;ember-data&amp;#39;&lt;/code&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_important-deprecations'&gt;Important Deprecations&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_fixture-adapter-removed'&gt;Fixture Adapter Removed&lt;/h3&gt;
&lt;p&gt;Support for the Fixture Adapter has been deprecated. After some thought,
the Ember Data team decided it was not the right approach for
integration-style tests. We recommend using an AJAX/data transport
stubbing strategy like &lt;a href="https://github.com/trek/pretender"&gt;Pretender&lt;/a&gt; or
&lt;a href="http://sinonjs.org/"&gt;sinon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll be including docs on integration test strategies using Pretender in the
final release.&lt;/p&gt;

&lt;p&gt;The Fixture Adapter now lives as an &lt;a href="https://github.com/emberjs/ember-data-fixture-adapter"&gt;addon&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_internet-explorer-8'&gt;Internet Explorer 8&lt;/h2&gt;
&lt;p&gt;This will be the last release to support Internet Explorer 8. Future
versions of Ember Data will not support Internet Explorer 8.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Another Ember 2.x Status Update</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/24/another-two-oh-status-update.html"/>
    <id>http://emberjs.com/blog/2015/05/24/another-two-oh-status-update.html</id>
    <published>2015-05-23T20:00:00-04:00</published>
    <updated>2015-05-23T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We're just a few weeks away from the release of Ember 1.13 and Ember 2.0 beta, and while there's been a lot of focus on those releases, the trains will keep rolling on June 12. There will be a 2.1 release 6 weeks hence, and a 2.2 release 6 weeks later...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We&amp;#39;re just a few weeks away from the release of Ember 1.13 and Ember 2.0 beta, and while there&amp;#39;s been a lot of focus on those releases, the trains will keep rolling on June 12. There will be a 2.1 release 6 weeks hence, and a 2.2 release 6 weeks later.&lt;/p&gt;

&lt;p&gt;With all of the focus on Ember 2.0, it&amp;#39;s easy to forget that 2.0 is just a six-week release, with the added ability to remove some built-up cruft. Because of the symbolic nature of 2.0, discussions about the future have had an artificial end date of June 12, which is now just three weeks away.&lt;/p&gt;

&lt;p&gt;This post gives some more details about what cruft will be removed in Ember 2.0, but, since the first features in Ember 2.1 will land in Canary just three weeks hence, what we plan to do in the early releases of Ember 2.x.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s important to note that we&amp;#39;ve talked a lot about an improved &amp;quot;Ember 2 programming model&amp;quot; over the past several months, significantly inspired by React. While much of the model will be in place in Ember 2.0, the early releases of Ember 2.x (especially 2.1 and 2.2), will finish up some important features. This blog post details the expected timeline.&lt;/p&gt;

&lt;p&gt;Of course, the six-week release cycle means that we ship on a train cycle, so the precise versions of specific features may change before they land in a final release.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_removals'&gt;Removals&lt;/h2&gt;
&lt;p&gt;While we&amp;#39;ve spent a lot of time talking about the new features that Ember is getting over the next few months, the 2.0 release itself is more about removals and de-cruft-ification.&lt;/p&gt;

&lt;p&gt;Some notable examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Context-shifting helpers (&lt;code&gt;#with item&lt;/code&gt; becomes &lt;code&gt;#with item as |i|&lt;/code&gt;,
&lt;code&gt;#each list&lt;/code&gt; becomes &lt;code&gt;#each list as |item|&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Fake block params versions of helpers (&lt;code&gt;#with foo as bar&lt;/code&gt; becomes
&lt;code&gt;#with foo as |bar|&lt;/code&gt;, &lt;code&gt;#each item in list&lt;/code&gt; becomes
&lt;code&gt;#each list as |item|&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ArrayPolyfills&lt;/code&gt; and &lt;code&gt;EnumerableUtils&lt;/code&gt; libraries are being
pulled out into a library; most apps should prefer lodash or other
utility libs.&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;#each&lt;/code&gt;, the options &lt;code&gt;itemController&lt;/code&gt;, &lt;code&gt;itemViewClass&lt;/code&gt;,
&lt;code&gt;itemView&lt;/code&gt;; superseded by using a component inside the loop&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;#with&lt;/code&gt;, the &lt;code&gt;controller&lt;/code&gt; option&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Ember.Handlebars&lt;/code&gt; namespace and all of its properties&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind-attr&lt;/code&gt;, superseded by just using attributes&lt;/li&gt;
&lt;li&gt;The legacy names &lt;code&gt;bindAttr&lt;/code&gt; and &lt;code&gt;linkTo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{collection}}&lt;/code&gt; helper&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{template}}&lt;/code&gt; helper; superseded by &lt;code&gt;{{partial}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{render}}&lt;/code&gt; helper; superseded in most cases by components&lt;/li&gt;
&lt;li&gt;Manually rendering a string into the buffer in a view&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Deferred&lt;/code&gt;; superseded by normal promises&lt;/li&gt;
&lt;li&gt;The globals resolver, which will be moved into an external library;
superseded in normal use by the ES6 module resolver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While top-level controllers will not be removed in 2.0 (see more below), we will remove all of the other uses of controllers from templates (such as &lt;code&gt;#with controller=&lt;/code&gt;, &lt;code&gt;{{render}}&lt;/code&gt;, &lt;code&gt;itemController&lt;/code&gt; and others).&lt;/p&gt;

&lt;p&gt;In all of these cases, we did significant work in the 1.x series, especially in 1.12 and 1.13, to make sure that the dominant use-cases for these features were addressed by existing or new features.&lt;/p&gt;

&lt;p&gt;You can learn about all of the deprecations added in the 1.x era, along with the expected transition to the features that superseded them, in the &lt;a href="http://emberjs.com/deprecations/v1.x/"&gt;1.x deprecations guide&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_the-glimmer-engine'&gt;The Glimmer Engine&lt;/h2&gt;
&lt;p&gt;The Glimmer engine, with its improved performance and improved support for the &amp;quot;data down, actions up&amp;quot; model, landed in Ember 1.13 beta.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_fast-re-render'&gt;Fast Re-Render&lt;/h2&gt;
&lt;p&gt;In Ember 1.12, calling rerender() on a component is an extremely expensive operation, and blows away all of the existing DOM (together with its internal state, such as selection, cursor, focus, scroll position and more).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In Ember 1.13&lt;/strong&gt;, thanks to the Glimmer engine, you can safely invoke rerender() and it will only update the parts of the template that have actually changed.&lt;/p&gt;

&lt;p&gt;This allows you to replace an entire data structure with a totally new POJO, rerender the component, and get highly performant updates that preserve the DOM.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-lifecycle-hooks'&gt;New Lifecycle Hooks&lt;/h2&gt;
&lt;p&gt;Because &lt;code&gt;rerender()&lt;/code&gt; is now fast and reliable, any call to &lt;code&gt;component.set()&lt;/code&gt; will trigger a re-render on the component. When a component re-renders, that may change the attributes of child components, which likewise are re-rendered.&lt;/p&gt;

&lt;p&gt;As a result of the fact that &lt;code&gt;rerender()&lt;/code&gt; is now such an important part of the programming model, &lt;strong&gt;Ember 1.13 beta&lt;/strong&gt; got a bunch of new React-inspired lifecycle hooks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didUpdateAttrs&lt;/code&gt;, invoked when a component&amp;#39;s attributes have changed
but before the component is rendered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willUpdate&lt;/code&gt;, invoked before a component will rerender, whether
the update was triggered by new attributes or by rerender.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didUpdate&lt;/code&gt;, invoked after a component has been rerendered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt;, invoked when a component gets attributes, either
initially or due to an update.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt;, invoked before a component will render, either
initially or due to an update, and regardless of how the rerender
was triggered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt;, invoked after a component has been rendered, either
initially or due to an update.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These lifecycle hooks will fire on all components (but not views), regardless of invocation style (both curlies and angle bracket style).&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_angle-bracket-components'&gt;Angle Bracket Components&lt;/h2&gt;
&lt;p&gt;Angle bracket components (&lt;code&gt;&amp;lt;my-component&amp;gt;&lt;/code&gt;) are a very important part of the Ember 2.x programming model. In addition to nicer syntax, they serve as an opt-in for component changes that we could not easily make compatibly, such as default one-way bindings.&lt;/p&gt;

&lt;p&gt;We originally thought that angle-bracket components would land in time for Ember 1.13, and they have already landed on Canary, and were included in the first 1.13 beta release.&lt;/p&gt;

&lt;p&gt;However, there were some late-breaking concerns, and we have decided to defer this feature so we can write an RFC and go through the regular process. We have already written an implementation of the RFC, which we will land on Canary and keep up to date with the RFC discussions.&lt;/p&gt;

&lt;p&gt;Because we are so close to the Ember 2.0 branch point, &lt;strong&gt;this feature is likely to land in Ember 2.1.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_routeable-components'&gt;Routeable Components&lt;/h2&gt;
&lt;p&gt;The routeable components RFC was first published several months ago, and has been the subject of vigorous discussion. It is one of the most anticipated features of the Ember 2.x programming model.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;(the following two paragraphs are a bit of insider baseball)&lt;/p&gt;

&lt;p&gt;The primary reason to attempt to land this feature in Ember 2.0, despite the fact that its development is at a relatively early stage, was a desire to deprecate controllers for 2.0. In Ember, in order to deprecate a public API, we require an alternate path for all of the use-cases of the old feature. In order to remove a feature in 2.0, it would have needed to be deprecated in 1.13.&lt;/p&gt;

&lt;p&gt;Together, that means that in order to remove controllers in 2.0, we needed to land routeable components, the transition from controllers, in 1.13. During the 1.13 canary cycle, it became obvious that removing controllers in 2.0 would be too aggressive, so the pressure to ship Routeable Components exactly in 2.0.0 is less.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;The work on Routeable Components, as well as work to make it possible to move query parameters fully to routes, is ongoing.&lt;/p&gt;

&lt;p&gt;There are less than three weeks left until the 2.0-beta branch point, and given that the feature has not yet landed in Canary (and the importance and magnitude of the feature), it will probably land in 2.1 at the earliest.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It is extremely likely to land in 2.1, or 2.2 at the latest.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Routeable Component feature also includes a change that makes it possible to provide multiple asynchronous attributes to the component you are routing to, rather than just the &lt;code&gt;model&lt;/code&gt; attribute. The &lt;code&gt;attrs&lt;/code&gt; hook will run on every transition into the route, in contrast to the &lt;code&gt;model&lt;/code&gt; hook, which doesn&amp;#39;t run again in some cases.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_fastboot'&gt;FastBoot&lt;/h2&gt;
&lt;p&gt;An early version of the FastBoot feature, suitable for SEO, is already available as an Ember addon that works with Ember 1.12. We expect the addon to work with the final release of 1.13.&lt;/p&gt;

&lt;p&gt;Work on rehydrating FastBoot will begin very soon, and we hope to land it in Canary early in the 2.x release cycle.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_engines'&gt;Engines&lt;/h2&gt;
&lt;p&gt;The Engines feature was first proposed as an &lt;a href="https://github.com/tomdale/rfcs/blob/master/active/0000-engines.md"&gt;RFC&lt;/a&gt; last year, and work on the feature itself will likely begin very soon.&lt;/p&gt;

&lt;p&gt;We expect the Engines feature to land in Canary early in the 2.x release cycle.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.17/18 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/21/ember-data-1-0-beta-18-released.html"/>
    <id>http://emberjs.com/blog/2015/05/21/ember-data-1-0-beta-18-released.html</id>
    <published>2015-05-20T20:00:00-04:00</published>
    <updated>2015-05-20T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Beta.17 and Beta.18 contained many bugfixes from the community! Please check
them out in the &lt;a href="https://github.com/emberjs/data/blob/master/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt;. Thank you to everyone who submitted
patches!&lt;/p&gt;

&lt;p&gt;While many bugs were stomped, some important changes are worth calling out:&lt;/p&gt;
&lt;h1 class="anchorable-toc" id="toc_possibly-breaking-deprecations"&gt;(Possibly) Breaking Deprecations&lt;/h1&gt;</summary>
    <content type="html">&lt;p&gt;Beta.17 and Beta.18 contained many bugfixes from the community! Please check
them out in the &lt;a href="https://github.com/emberjs/data/blob/master/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt;. Thank you to everyone who submitted
patches!&lt;/p&gt;

&lt;p&gt;While many bugs were stomped, some important changes are worth calling out:&lt;/p&gt;
&lt;h1 class='anchorable-toc' id='toc_possibly-breaking-deprecations'&gt;(Possibly) Breaking Deprecations&lt;/h1&gt;&lt;h2 class='anchorable-toc' id='toc_record-constructor-typekey-is-now-record-constructor-modelname'&gt;record.constructor.typeKey is now record.constructor.modelName&lt;/h2&gt;
&lt;p&gt;In Ember Data, when you ask for a model, Ember Data looks its class up using
Ember&amp;#39;s &lt;a href="http://guides.emberjs.com/v1.10.0/understanding-ember/dependency-injection-and-service-lookup/"&gt;Dependency Injection&lt;/a&gt; API.  When the model class is looked
up, Ember Data stores the type on the model class.&lt;/p&gt;

&lt;p&gt;For example, when the following code runs in your application:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; post = &lt;span class="local-variable"&gt;this&lt;/span&gt;.store.getById(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and Ember Data will store the string &amp;quot;post&amp;quot; on the model class:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;console.log(post.constructor.typeKey); &lt;span class="comment"&gt;// 'post'&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Ember Data uses this &lt;code&gt;typeKey&lt;/code&gt; property internally when creating and extracting
payloads in Serializers, and when locating models in Adapters. The &lt;code&gt;typeKey&lt;/code&gt; is
also currently available on Snapshots, which are passed to adapter and
serializer methods. &lt;code&gt;typeKey&lt;/code&gt; was previously always normalized to be a
camelCased string.&lt;/p&gt;

&lt;p&gt;In Ember Data 1.0.0-beta.18, this property is now called &lt;code&gt;modelName&lt;/code&gt;. In
addition, the &lt;code&gt;modelName&lt;/code&gt; is a dasherized string. For example, if you had a
model called &lt;code&gt;TacoShop&lt;/code&gt;, it would be stored on the model&amp;#39;s constructor&amp;#39;s
&lt;code&gt;modelName&lt;/code&gt; property as &lt;code&gt;taco-shop&lt;/code&gt;, whereas previously it would be stored as
&lt;code&gt;tacoShop&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Accessing the &lt;code&gt;typeKey&lt;/code&gt; property should still work, but will trigger
deprecation warnings.&lt;/p&gt;

&lt;p&gt;If you don&amp;#39;t have any custom serializers or adapters, you are good to go;
outgoing payloads and URLs shouldn&amp;#39;t change. If you&amp;#39;ve overridden a method in
your subclass, remember to call &lt;code&gt;this._super&lt;/code&gt;, or to normalize modelName in
your code. If you need to transform this string, you can use Ember.String&amp;#39;s
&lt;a href="http://emberjs.com/api/classes/Ember.String.html#method_camelize"&gt;camelize&lt;/a&gt; and &lt;a href="http://emberjs.com/api/classes/Ember.String.html#method_underscore"&gt;underscore&lt;/a&gt; functions. Keep in mind you
can&amp;#39;t change &lt;code&gt;modelName&lt;/code&gt; on the model&amp;#39;s constructor; it is &lt;strong&gt;read-only&lt;/strong&gt; and
will trigger an assertion error if you try to override it.&lt;/p&gt;

&lt;p&gt;We changed &lt;code&gt;typeKey&lt;/code&gt; to &lt;code&gt;modelName&lt;/code&gt; to allow us to align to dasherized strings
as Ember and Ember CLI also align with dasherized strings. Changing the name
allows us to make this change with a deprecation phase.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ds-restserializer-typeforroot-is-now-ds-restserializer-modelnamefrompayloadkey'&gt;DS.RESTSerializer.typeForRoot is now DS.RESTSerializer.modelNameFromPayloadKey&lt;/h2&gt;
&lt;p&gt;To gain more consistency in the naming change of  &lt;code&gt;typeKey&lt;/code&gt; to &lt;code&gt;modelName&lt;/code&gt;,
&lt;code&gt;typeForRoot&lt;/code&gt; has been renamed to &lt;code&gt;modelNameFromPayloadKey&lt;/code&gt;. The function
serves the same purpose, so this should be a quick refactor you can achieve via
search and replace in your project. While &lt;em&gt;calling&lt;/em&gt; typeForRoot will trigger a
deprecation warning, overriding in a subclass won&amp;#39;t.&lt;/p&gt;
&lt;h1 class='anchorable-toc' id='toc_new-features'&gt;New Features&lt;/h1&gt;&lt;h2 class='anchorable-toc' id='toc_ds-restserializer-payloadkeyfrommodelname'&gt;DS.RESTSerializer.payloadKeyFromModelName&lt;/h2&gt;
&lt;p&gt;While &lt;code&gt;modelNameFromPayloadKey&lt;/code&gt; returns a &lt;em&gt;model&lt;/em&gt; for a JSON payload key,
&lt;code&gt;payloadKeyFromModelName&lt;/code&gt; can be used to override the serialization of a model
&lt;em&gt;to the server.&lt;/em&gt; For instance, you may have a Post model, but your server
expects a &lt;code&gt;message&lt;/code&gt; as the root. You can override it like so:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/serializers/application.js&lt;/span&gt;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; DS.RESTSerializer.extend({
  &lt;span class="key"&gt;payloadKeyFromModelName&lt;/span&gt;: (modelName) {
    &lt;span class="keyword"&gt;if&lt;/span&gt; (modelName === &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) {
      &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;message&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;
    }
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;._super(modelName);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This would produce the following payload:&lt;/p&gt;
&lt;div class="highlight json "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;message&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: {
    &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;title&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Action Cable comes with 3 Months of Free HBO&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Another example is that ActiveModelSerializer uses this hook to convert a
dasherized &lt;code&gt;modelName&lt;/code&gt; to an &lt;code&gt;under_scored&lt;/code&gt; string.&lt;/p&gt;

&lt;p&gt;While this was possible previously in Ember Data, we noticed that users used
several different hooks to achieve this goal, so it made sense to make one
unifying place for this kind of serialization.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_store-unloadall-can-now-unload-all-models-when-not-passed-a-modelname'&gt;store.unloadAll() can now unload all models when not passed a modelName&lt;/h2&gt;
&lt;p&gt;Previously, &lt;code&gt;store.unloadAll&lt;/code&gt; required a &lt;code&gt;modelName&lt;/code&gt; argument to unload records
of a type.  Now, you can unload all records without calling &lt;code&gt;store.destroy&lt;/code&gt;.
Thanks to &lt;a href="https://github.com/emberjs/data/pull/2999"&gt;svox1&lt;/a&gt; for this pull
request!&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ds-restadapter-buildurl-refactored-into-different-hooks'&gt;DS.RESTAdapter.buildURL refactored into different hooks&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;buildURL&lt;/code&gt; has been refactored into several hooks like &lt;code&gt;urlForFindQuery&lt;/code&gt;. This
makes overriding methods like &lt;code&gt;buildURL&lt;/code&gt; easier to reason about and easier to
change without breaking other request types. Thanks to
&lt;a href="https://github.com/emberjs/data/pull/2966"&gt;thejameskyle&lt;/a&gt; for taking on this
refactor!&lt;/p&gt;

&lt;p&gt;While beta.17 did introduce a regression, this has been fixed in beta.18.&lt;/p&gt;

&lt;!-- Links --&gt;
</content>
  </entry>
  <entry>
    <title>Ember.js 1.12 and 1.13 Beta (Glimmer!) Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/13/ember-1-12-released.html"/>
    <id>http://emberjs.com/blog/2015/05/13/ember-1-12-released.html</id>
    <published>2015-05-12T20:00:00-04:00</published>
    <updated>2015-05-12T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We are please to announce the release of Ember.js 1.12 and the first beta in the 1.13 series.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.13 beta is the first Ember.js release that includes Glimmer, the new Ember
rendering engine, as well as the final batch of Ember 2.0 features.&lt;/strong&gt; We will...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We are please to announce the release of Ember.js 1.12 and the first beta in the 1.13 series.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.13 beta is the first Ember.js release that includes Glimmer, the new Ember
rendering engine, as well as the final batch of Ember 2.0 features.&lt;/strong&gt; We will
discuss those details more below.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features-in-ember-1-12'&gt;New Features in Ember 1.12&lt;/h2&gt;
&lt;p&gt;Ember 1.12 is a relatively light release, and includes features that move Ember
closer to ES6 class syntax and the first parts of the internal implementation
needed for a stable release of the FastBoot addon.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_new-computed-syntax'&gt;New Computed Syntax&lt;/h4&gt;
&lt;p&gt;Per &lt;a href="https://github.com/emberjs/rfcs/pull/11"&gt;RFC #11&lt;/a&gt;, Ember is introducing a
new syntax for computed properties. This change better aligns computed property
syntax with JavaScript getters and setters and makes writing settable computed
properties developer friendly.&lt;/p&gt;

&lt;p&gt;It also has the nice side effect of improving performance, as the old syntax,
with its two-in-one function signatures, was harder for JavaScript engines to
optimize.&lt;/p&gt;

&lt;p&gt;The simplest syntax for a computed property is to define the getter as a function:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,
  &lt;span class="key"&gt;goldenRatioWidth&lt;/span&gt;: Ember.computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;(){
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.618&lt;/span&gt;;
  })

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is still the way to write simple getters, the most common use-case for
computed properties, in Ember 1.12.&lt;/p&gt;

&lt;p&gt;To create a settable computed property in Ember 1.11 an &lt;code&gt;if&lt;/code&gt; statement was used
to differentiate the get from the set logic. For example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,
  &lt;span class="key"&gt;goldenRatioWidth&lt;/span&gt;: Ember.computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;(key, value){
    &lt;span class="keyword"&gt;if&lt;/span&gt; (&lt;span class="local-variable"&gt;arguments&lt;/span&gt;.length &amp;gt; &lt;span class="integer"&gt;1&lt;/span&gt;) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, value / &lt;span class="float"&gt;1.618&lt;/span&gt;);
    } &lt;span class="keyword"&gt;else&lt;/span&gt; {
      &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.618&lt;/span&gt;;
    }
  })

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This syntax was functional but error-prone, verbose, and hard to understand
(for both humans and JavaScript engines).&lt;/p&gt;

&lt;p&gt;In Ember 1.12, you can nicely separate the getter and setter into two different
functions.&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,
  &lt;span class="key"&gt;goldenRatioWidth&lt;/span&gt;: Ember.computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, {
    get(key) {
      &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.618&lt;/span&gt;;
    },
    set(key, value) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, value / &lt;span class="float"&gt;1.618&lt;/span&gt;);
    }
  });

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This also aligns Ember&amp;#39;s API with JavaScript getters and setters, and
simplifies the path towards using JavaScript getters in Ember 2.0, after IE8
support is dropped.&lt;/p&gt;

&lt;p&gt;For more information see the initial implementation in &lt;a href="https://github.com/emberjs/ember.js/pull/9527"&gt;#9527&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Many thanks to &lt;a href="https://twitter.com/stefanpenner"&gt;@stefanpenner&lt;/a&gt; and
&lt;a href="https://twitter.com/MiguelCamba"&gt;@MiguelCamba&lt;/a&gt; for championing and shipping
this feature.&lt;/p&gt;

&lt;p&gt;One last thing: thanks to the experimental support for &lt;a href="https://github.com/wycats/javascript-decorators"&gt;JavaScript
decorators&lt;/a&gt; in Babel, we are also planning a further improvement in
the near future:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Object.extend({

  &lt;span class="key"&gt;height&lt;/span&gt;: &lt;span class="integer"&gt;100&lt;/span&gt;,

  &lt;span class="error"&gt;@&lt;/span&gt;computed(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
  get goldenRatioWidth(key) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) * &lt;span class="float"&gt;1.1618&lt;/span&gt;;
  }

  set goldenRatioWidth(key, value) {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;height&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, value / &lt;span class="float"&gt;1.618&lt;/span&gt;);
  }

});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_instance-initializers'&gt;Instance Initializers&lt;/h4&gt;
&lt;p&gt;The next feature, instance initializers, makes it possible for FastBoot
applications to run many requests concurrently.&lt;/p&gt;

&lt;p&gt;Before FastBoot, you would only ever run applications one at a time. Even in
automated tests, tests were run one at a time, in serial, so one application
was destroyed before the next one was created.&lt;/p&gt;

&lt;p&gt;In FastBoot, it is important for a single node server to be able to serve
a second request while the first one is fetching its data.&lt;/p&gt;

&lt;p&gt;Thankfully, Ember already ensures that all state is stored in the container,
so in theory, all you need to do is give each request its own container
instance and you get concurrent requests in FastBoot.&lt;/p&gt;

&lt;p&gt;In practice, there was a minor API change we needed to make in order to
make it work involving initializers. In Ember 1.11, initializers would
run on app boot (or once per test). Some initializers were setting up
code (and injection rules), which are the same across all FastBoot requests,
while other initializers were creating instances, which are different
across requests.&lt;/p&gt;

&lt;p&gt;In Ember.js 1.12 application boot is separated into two phases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Application initializers run. At this phase of boot, the goal of initializers
should be to register dependencies and injections. These initializers are doing
work that is shared across all FastBoot requests, and therefore should not
create instances. This phase runs &lt;em&gt;once&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Instance initializers run next. This is the right time to do work that is
specific to each FastBoot request. You can create instances and modify their
state here. This phase runs when the browser application runs, for each
integration test, and for each FastBoot request.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The two-phase initialization process is safer when multiple addons may be
registering factories and injections.&lt;/p&gt;

&lt;p&gt;Ember-CLI 0.2.3 supports instance initializers. For example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/instance-initializers/sleep.js&lt;/span&gt;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;function&lt;/span&gt; &lt;span class="function"&gt;initialize&lt;/span&gt;(application) {
  application.deferReadiness();
  &lt;span class="comment"&gt;// Wait 3s before continuing to boot the app&lt;/span&gt;
  Ember.run.later(application, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;advanceReadiness&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;3000&lt;/span&gt;);
}

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; {
  &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;sleep&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;initialize&lt;/span&gt;: initialize
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To define an instance initializer in globals mode use the &lt;code&gt;Ember.Application.instanceInitializer&lt;/code&gt;
method. For more information about instance intializers see the
implementation in &lt;a href="https://github.com/emberjs/ember.js/pull/10256"&gt;#10256&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt;, &lt;a href="https://twitter.com/wycats"&gt;@wycats&lt;/a&gt; and
&lt;a href="https://twitter.com/dgeb"&gt;@dgeb&lt;/a&gt; for this feature and other
refactoring work around application initialization.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_initializer-context'&gt;Initializer Context&lt;/h4&gt;
&lt;p&gt;Previously, the &lt;code&gt;this&lt;/code&gt; scope of an initializer was simply the global scope.
&lt;a href="https://github.com/emberjs/ember.js/pull/10179"&gt;#10179&lt;/a&gt; changed initializer
scopes to be the initializer object itself.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/gf3"&gt;@gf3&lt;/a&gt; for suggesting and adding this feature.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_ember-1-13-beta'&gt;Ember 1.13 Beta&lt;/h2&gt;
&lt;p&gt;And now, the big enchilada!&lt;/p&gt;

&lt;p&gt;Together with the release of Ember 1.12, we are releasing the first beta of Ember 1.13.&lt;/p&gt;

&lt;p&gt;Ember 1.13 is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the last minor release in the 1.x series&lt;/li&gt;
&lt;li&gt;the first release that includes the new &lt;strong&gt;Glimmer rendering engine&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Just to recap; what is Glimmer?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A new faster rendering engine that is especially fast at updates.&lt;/li&gt;
&lt;li&gt;An implementation of the React-inspired &amp;quot;just re-render it&amp;quot; programming model
for components, with one-way data flow by default and better enforcement for
data-down, actions-up.&lt;/li&gt;
&lt;li&gt;Supports angle-bracket components (&lt;code&gt;&amp;lt;my-component /&amp;gt;&lt;/code&gt;), ergonomic attributes
(&lt;code&gt;&amp;lt;my-link href=&amp;quot;{{url}}.html&amp;quot;&amp;gt;go home&amp;lt;/my-link&amp;gt;&lt;/code&gt;), that hews closely to HTML
syntax with a few small enhancements.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;#39;ll be writing a blog post that expands on the programming model of Ember 2.0
and talks about the most important new features in the next few days, and full
docs are coming as well.&lt;/p&gt;

&lt;p&gt;We&amp;#39;d like to give a big thank you to the entire community for all the nights and
weekends over the past few months getting Glimmer (&lt;a href="https://www.isemberfastyet.com"&gt;almost&lt;/a&gt;) over the
finish line. It&amp;#39;s inspiring.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_the-1-13-x-series'&gt;The 1.13.x Series&lt;/h4&gt;
&lt;p&gt;In most cases, you should expect Glimmer to be faster at both initial rendering
and updates. If you find performance regressions in idiomatic usage in your app,
we definitely want to hear about it. Please file bugs.&lt;/p&gt;

&lt;p&gt;The Glimmer rendering engine changes parts of Ember that have been largely
untouched since the days of SproutCore 2.0. In practice, this means that you
may be relying on implementation details of the pre-Glimmer implementation
that were not captured by tests, and that were not discovered during the
Canary period.&lt;/p&gt;

&lt;p&gt;Because of the magnitude of the internal change, we expect the first few
Ember 1.13 betas to be less stable than other betas in the 1.x series. &lt;strong&gt;We
need your help to find and fix compatibility regressions.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Please report any incompatibilities that you discover. We will investigate and
consider shimming any regression that affects a significant number of apps,
even if the root cause is a change in internal implementation details.&lt;/p&gt;

&lt;p&gt;We know that there will likely be some compatibility regressions, especially
in implementation details, that we do not catch during the 1.13 beta period.
We plan to continue to release point releases to the 1.13 series to fix
those details after 2.0 beta is released, and perhaps even for a while after
2.0 final is released.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Our goal is to ensure that most applications can upgrade to Ember 1.13.x,
remove deprecations, and then upgrade to Ember 2.0 with minimal fuss.&lt;/strong&gt; If
a significant number of apps that are earnestly trying to upgrade this way
cannot, we will continue to fix problems that are blocking upgrades.&lt;/p&gt;

&lt;p&gt;For an in-depth look into our transition plan for users with existing Ember 1.x
apps, please see the recent &lt;a href="http://emberjs.com/blog/2015/05/10/run-up-to-two-oh.html"&gt;Transition to Ember 2.0 in
Detail&lt;/a&gt; blog post.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_changelogs'&gt;CHANGELOGS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.12.0/CHANGELOG.md"&gt;Ember 1.12.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.13.0-beta.1/CHANGELOG.md"&gt;Ember 1.13.0-beta.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
