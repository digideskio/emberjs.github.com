<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember Blog</title>
  <subtitle>Ember News and Updates</subtitle>
  <id>http://emberjs.com/blog</id>
  <link href="http://emberjs.com/blog"/>
  <link href="http://emberjs.com/blog/feed.xml" rel="self"/>
  <updated>2015-06-17T20:00:00-04:00</updated>
  <author>
    <name>Ember</name>
  </author>
  <entry>
    <title>Ember Data v1.13 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html"/>
    <id>http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html</id>
    <published>2015-06-17T20:00:00-04:00</published>
    <updated>2015-06-17T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We are proud to announce the release of Ember Data 1.13. This
represents the first stable release of Ember Data since its creation
over 3 years ago. &lt;/p&gt;

&lt;p&gt;As we explained in the &lt;a href="http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html"&gt;The Ember 2.x Project&lt;/a&gt;
blog post, going forward Ember Data will be syncing...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We are proud to announce the release of Ember Data 1.13. This
represents the first stable release of Ember Data since its creation
over 3 years ago. &lt;/p&gt;

&lt;p&gt;As we explained in the &lt;a href="http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html"&gt;The Ember 2.x Project&lt;/a&gt;
blog post, going forward Ember Data will be syncing up its releases and version numbers with Ember.js releases. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember Data 1.13 is the first release of Ember Data that syncs its
  version with a version of Ember.js.&lt;/strong&gt; It will be followed by Ember Data 2.0, which will be released alongside Ember.js 2.0. &lt;strong&gt;Ember Data 1.13 is fully backwards compatible with Ember Data beta.19, allowing for a smooth upgrade path.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-data-1-13-overview'&gt;Ember Data 1.13 Overview&lt;/h3&gt;
&lt;p&gt;Ember Data 1.13 is a massive release we are very proud of.
The highlight of the Ember Data 1.13 release is a total overhaul of Ember Data&amp;#39;s internal format and Serializer API to follow JSON API. &lt;/p&gt;

&lt;p&gt;Two years ago Tom Dale and Yehuda Katz &lt;a href="http://emberjs.com/blog/2013/05/03/ember-data-progress-update.html"&gt;published&lt;/a&gt; a vision for how Ember Data should look in the future and articulated the need for a single, ubiquitous JSON API standard.&lt;/p&gt;

&lt;p&gt;We are very happy to see the vision for that JSON API standard come to life in the form of the &lt;a href="http://jsonapi.org"&gt;JSON API 1.0 release&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;JSON API and Ember Data have been intertwined since JSON API&amp;#39;s inception.
&lt;a href="https://github.com/dgeb"&gt;@dgeb&lt;/a&gt; gives the origins of JSON API in his &lt;a href="http://www.cerebris.com/blog/2015/06/04/jsonapi-1-0/"&gt;1.0 announcement&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yehuda Katz wrote the first draft of the JSON API specification in May 2013 after hammering out the details in a long discussion with Steve Klabnik at RailsConf. JSON API began as a codification of the shared expectations of a single server library for Rails, ActiveModel::Serializers, and a single JavaScript client library, Ember Data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ember Data has long supported JSON API through a community &lt;a href="https://github.com/kurko/ember-json-api"&gt;adapter&lt;/a&gt; started by &lt;a href="https://twitter.com/0x8890"&gt;@0x8890&lt;/a&gt; and maintained by &lt;a href="https://github.com/kurko"&gt;@kurko&lt;/a&gt;. However, now that JSON API has reached 1.0, it&amp;#39;s time for Ember Data to uphold its part of the bargain and make using JSON API a first-class experience.&lt;/p&gt;

&lt;p&gt;We have done exactly that, and Ember Data 1.13 adds support throughout the Ember Data stack for JSON API:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ember Data 1.13 ships with a fully supported JSON API Adapter and Serializer.&lt;/strong&gt; In 2.0, these will become the default Adapter and Serializer.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;JSONSerializer&lt;/code&gt; and &lt;code&gt;RESTSerializer&lt;/code&gt; have been refactored and streamlined to return JSON API payloads.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;store.push&lt;/code&gt; now accepts JSON API compliant payload.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ember Data &lt;code&gt;InvalidError&lt;/code&gt; objects now accept JSON API error objects&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Switching to the JSON API format unlocks many new features which will be added in the 2.0 cycle, including first-class pagination, filtering and metadata support.&lt;/p&gt;

&lt;p&gt;While &lt;strong&gt;using JSONSerializer, RESTSerializer and ActiveModelSerializer is not deprecated&lt;/strong&gt;, we consider JSON API to be the happiest of the happy paths for using Ember Data, and if you are creating a new app today and have control over the API you should be using JSON API, because it is a well designed and comprehensive solution for JSON serialization. &lt;strong&gt;If your app is using the vanilla JSONSerializer or RESTSerializer, you will not have to make any changes, and your app will continue to work.&lt;/strong&gt; The existing serializers have been updated in a backwards compatible way to return JSON API data to the store.&lt;/p&gt;

&lt;p&gt;Other major changes in Ember Data 1.13 include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_simplified-find-methods"&gt;Refactored and simplified find methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-adapter-hooks-for-better-caching"&gt;Adapter level control for identity map caching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-serializer-api-for-custom-serializer-authors"&gt;Refactored and simplified Serializer APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_internal-format-change-to-json-api"&gt;Switch to using JSON API as the internal data storage format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_json-api-support"&gt;Native JSON API Serializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-errors-api"&gt;Better error handling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_upgrade-guide'&gt;Upgrade Guide&lt;/h2&gt;
&lt;p&gt;Ember Data 1.13 is backwards-compatible with previous beta versions, and there are no
breaking changes between Ember Data 1.13 and Ember Data beta.19. Ember Data follows Ember.js&amp;#39;s lead in not removing any features in this release. The upgrade path should be familiar to Ember.js users: upgrade, remove deprecations, upgrade again.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You should update your codebase to Ember Data 1.13, remove all the deprecations
and then move to Ember Data 2.0. It is critically important to do this process step by step&lt;/strong&gt;, as it will give you easy to follow deprecation warnings.
Otherwise, your app might fail in hard-to-debug ways.&lt;/p&gt;

&lt;p&gt;If you have customized your serializer, you should upgrade to Ember Data 1.13, 
check the upgrade guide to see if you need to make any changes, and then set a
temporary flag on your Serializer: &lt;code&gt;isNewSerializerAPI&lt;/code&gt;. This will opt you into
the new serializer API. Once you are on the Ember Data 2.0 train, new Serializer API
is the default one, and there is no need for a flag.&lt;/p&gt;

&lt;p&gt;We will be publishing a detailed step by step upgrade guide along with Ember.js
deprecations guides and &lt;a href="https://github.com/abuiles/ember-watson"&gt;ember-watson&lt;/a&gt; helpers that will automatically upgrade some
of the deprecations for you.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_release-logistics'&gt;Release Logistics&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Ember Data 1.13 is the last release of Ember Data that supports IE8
  and the 1.x series of Ember.js. Ember Data 2.0-beta.1 will be released shortly, and it will follow the Ember.js release train.&lt;/strong&gt; Ember Data 2.0 will not work with the Ember.js 1.x series.&lt;/p&gt;

&lt;p&gt;We would like to extend a special thanks to the many contributors who
have helped out with this release. We would also like to recognize the
following contributors who helped with multiple issues leading up to
this release. If you would like to help, please join #dev-ember-data in the 
&lt;a href="https://ember-community-slackin.herokuapp.com/"&gt;Ember Community&lt;/a&gt; on Slack.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/turbo87"&gt;@turbo87&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/HeroicEric"&gt;@HeroicEric&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pangratz"&gt;@pangratz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sly7-7"&gt;@sly7-7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/yratanov"&gt;@yratanov&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tchak"&gt;@tchak&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/thaume"&gt;@thaume&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mikehollis"&gt;@mikehollis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tricknotes"&gt;@tricknotes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We would also like to thank the companies which generously sponsored some of the work
that has gone into Ember Data:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dockyard.com/"&gt;DockYard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.precisionnutrition.com/"&gt;Precision Nutrition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bookingsync.com"&gt;BookingSync&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As always this release can be obtained from npm (for
use with ember-cli), rubygems, or bower. The builds are also available
as static files at &lt;a href=""&gt;http://emberjs.com/builds&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features'&gt;New Features&lt;/h2&gt;&lt;h2 class='anchorable-toc' id='toc_simplified-find-methods'&gt;Simplified Find Methods&lt;/h2&gt;
&lt;p&gt;Ember Data methods on the store have grown organically over the life
of the project. Originally, Ember Data started with &lt;code&gt;store.find(type)&lt;/code&gt;
to request all records for a type and &lt;code&gt;store.find(type, id)&lt;/code&gt; to
request a specific record. Later Ember Data added ways to issue a
query to the server via &lt;code&gt;store.find(type, {query})&lt;/code&gt; or always reload a
record from the backend using &lt;code&gt;store.fetchById(type, id)&lt;/code&gt; and
&lt;code&gt;store.fetchAll(type)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We realized the overloaded &lt;code&gt;store.find&lt;/code&gt; method and inconsistent naming
of other methods is confusing for both new and existing developers. As a result, we have renamed many of the existing
store methods to make them more consistent and approachable for all
developers.&lt;/p&gt;

&lt;p&gt;In particular, &lt;code&gt;store.find&lt;/code&gt;, &lt;code&gt;store.all&lt;/code&gt;, &lt;code&gt;store.getById&lt;/code&gt; have been 
deprecated and are replaced with consistently named methods. New methods follow a simple convention: If they are async and potentially go to the server, they start with &lt;code&gt;find&lt;/code&gt;, and if they only get store local data without side-effects they start with &lt;code&gt;peek&lt;/code&gt;.
If they return a single record they end in &lt;code&gt;Record&lt;/code&gt; and if they return all the records they end in &lt;code&gt;All&lt;/code&gt; .&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_reorganized-find-methods'&gt;Reorganized Find Methods&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Async from server/store&lt;/th&gt;
      &lt;th&gt;Sync from store&lt;/th&gt;
      &lt;th&gt;Query server&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;b&gt;Single Record&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;findRecord(type,id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;peekRecord(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;queryRecord(type, {query})&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;b&gt;All Records&lt;/b&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;findAll(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;peekAll(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;query(type, {query})*&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* A query usually does not return all the records of a type, so doesn&amp;#39;t end in &lt;code&gt;All&lt;/code&gt;.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_query-and-queryrecord'&gt;query and queryRecord&lt;/h4&gt;
&lt;p&gt;The final use case for the old &lt;code&gt;store.find&lt;/code&gt; method was issuing queries
to the server. This usage of &lt;code&gt;store.find(type, { query })&lt;/code&gt; has been
deprecated and replaced by a new &lt;code&gt;query&lt;/code&gt; method
on the store.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.query(type, { query });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In addition to &lt;code&gt;store.query&lt;/code&gt; we have also added a &lt;code&gt;queryRecord&lt;/code&gt; for
issuing arbitrary queries to the backend where the expected response
is a single record.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.queryRecord(type, { query });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Thanks to &lt;a href="http://github.com/thaume"&gt;@thaume&lt;/a&gt; for his work implementing this feature.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_better-caching-defaults-for-code-findall-code-and-code-findrecord-code'&gt;Better Caching Defaults for &lt;code&gt;findAll&lt;/code&gt; and &lt;code&gt;findRecord&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;In Ember Data beta.19 calling &lt;code&gt;store.find(type, id)&lt;/code&gt; would fetch the
fresh data from the server the first time find was called, and then every time after that
return cached data. If the user always needed fresh data, they had to
know to call &lt;code&gt;store.fetchRecord&lt;/code&gt;, and if they needed to background update
they would have to make multiple calls and be careful about what they return from
a route&amp;#39;s &lt;code&gt;model:&lt;/code&gt; hook.&lt;/p&gt;

&lt;p&gt;Calling &lt;code&gt;store.find(type)&lt;/code&gt; had the exact opposite behavior, where it would
always go to the server, and the user had to know to use &lt;code&gt;store.all(type)&lt;/code&gt;
to only use local data. Mimicking the caching behavior of &lt;code&gt;find(type, id)&lt;/code&gt;
when using &lt;code&gt;find(type)&lt;/code&gt; was not at all straightforward for new developers to write.&lt;/p&gt;

&lt;p&gt;Having observed many Ember apps in the wild, we have realized that neither
of these two behaviors are the most common use case and deserving of being the default. The most commonly desired behavior we have seen in Ember apps is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First time &lt;code&gt;store.find&lt;/code&gt; is called, fetch new data&lt;/li&gt;
&lt;li&gt;Next time return cached data&lt;/li&gt;
&lt;li&gt;Fetch new data in the background and update&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is the behavior of the new &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt; methods. &lt;/p&gt;

&lt;p&gt;The first time you call &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt; they behave the same as
the old &lt;code&gt;find&lt;/code&gt; method:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1 for the first time&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  &lt;span class="comment"&gt;//We do not already have the user, so&lt;/span&gt;
  &lt;span class="comment"&gt;//store.findRecord returns a promise that resolves&lt;/span&gt;
  &lt;span class="comment"&gt;//after it has fetched the user from the server&lt;/span&gt;
  &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;However if you already have the data cached locally, they resolve immediately
while fetching new data in the background:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1 for the second time&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  &lt;span class="comment"&gt;//We already have the user, so store.findRecord&lt;/span&gt;
  &lt;span class="comment"&gt;//will resolve immediately with cached data, but will&lt;/span&gt;
  &lt;span class="comment"&gt;//send off a request in the background to update the user record&lt;/span&gt;
  &lt;span class="comment"&gt;//and once the user is updated your template will show the new changes&lt;/span&gt;
  &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While this is a great default data retrieval strategy, there are certain cases
where you want to ensure you have  the freshest data (the old &lt;code&gt;store.fetch&lt;/code&gt; behavior) or you do not want a background update to happen (the old &lt;code&gt;store.find(type, id)&lt;/code&gt; behavior). &lt;/p&gt;

&lt;p&gt;Because of that, &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt; accept &lt;code&gt;reload: true&lt;/code&gt; and &lt;code&gt;backgroundReload: false&lt;/code&gt; as options in order to modify their default behavior.&lt;/p&gt;

&lt;p&gt;If, for example you want to charge user for a purchase, and want to make sure you
get their latest account balance, you can pass a &lt;code&gt;reload: true&lt;/code&gt; option that will
ensure we get the freshest data before continuing:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1/confirm-payment&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For example if you are showing the user a settings modal and want to opt out from
background updates in order to keep the UI stable you can pass &lt;code&gt;backgroundReload: false&lt;/code&gt; as a flag:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;//visiting /users/1/open-modal&lt;/span&gt;
&lt;span class="function"&gt;model&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
  store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;backgroundReload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;false&lt;/span&gt; });
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;All of these behaviors are also shared by &lt;code&gt;findAll&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);  &lt;span class="comment"&gt;//goes to the server the first time&lt;/span&gt;
store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);  &lt;span class="comment"&gt;//after that returns from cache, but updates in background&lt;/span&gt;
store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });  &lt;span class="comment"&gt;//enforces getting fresh data&lt;/span&gt;
store.findAll(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;backgroundReload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;false&lt;/span&gt; });  &lt;span class="comment"&gt;//opts out of background updating&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_code-fetchbyid-code-and-code-fetchall-code-replaced-by-code-findrecord-code-and-code-findall-code'&gt;&lt;code&gt;fetchById&lt;/code&gt; and &lt;code&gt;fetchAll&lt;/code&gt; Replaced by &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Having these two methods, with customizable flags allows us to get rid of:
&lt;code&gt;store.fetchById&lt;/code&gt; and &lt;code&gt;store.fetchAll&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.fetchById(type, id) -&amp;gt; store.findRecord(type, id, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });
store.fetchAll(type, id) -&amp;gt; store.findAll(type, { &lt;span class="key"&gt;reload&lt;/span&gt;: &lt;span class="predefined-constant"&gt;true&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_new-adapter-hooks-for-better-caching'&gt;New Adapter Hooks for Better Caching&lt;/h3&gt;
&lt;p&gt;While &lt;code&gt;store.findRecord&lt;/code&gt; and &lt;code&gt;store.findAll&lt;/code&gt; now have sensible caching defaults
and are easy to override in specific places in the app, oftentimes your app and
adapter layer have specific knowledge related to caching. For example, your backend
might have given you an &lt;code&gt;expires&lt;/code&gt; header, or you may not want to try fetching background updates if the network is down. To support these use cases, we have added new adapter
hooks to customize caching app wide beyond just passing options to &lt;code&gt;findRecord&lt;/code&gt; and &lt;code&gt;findAll&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, whenever you call &lt;code&gt;findRecord&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt;, and the record is already cached in the store, the store will ask the adapter whether it needs to immediately reload it, or if it needs to update it in the background.&lt;/p&gt;

&lt;p&gt;For example, if you are building an events ticketing system, in which users can only reserve tickets for 20 minutes at a time, and want to ensure that in each route you have data that is no more than 20 minutes old you could write:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="function"&gt;shouldReloadRecord&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, ticketSnapshot) {
  let timeDiff = moment().diff(ticketSnapshot.attr(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastAccessedAt&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)).minutes();
  &lt;span class="keyword"&gt;if&lt;/span&gt; (timeDiff &amp;gt; &lt;span class="integer"&gt;20&lt;/span&gt;) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;true&lt;/span&gt;;    
  } &lt;span class="keyword"&gt;else&lt;/span&gt; {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;false&lt;/span&gt;;
  }
}, 
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This method would ensure that whenever you do &lt;code&gt;findRecord(&amp;#39;ticket&amp;#39;)&lt;/code&gt; you will
always get a ticket that is no more than 20 minutes old. In case the cached
version is more than 20 minutes old, &lt;code&gt;findRecord&lt;/code&gt; will not resolve until you fetched
the latest version. By default this hook returns false, as most UIs should not block
user interactions while waiting on data update.&lt;/p&gt;

&lt;p&gt;You can also customize whether you should try and do a background update. For example, if you do not want to fetch complex data over a mobile connection, or 
if the network is down, you can implement &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="function"&gt;shouldBackgroundReloadRecord&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, snapshot) {
  &lt;span class="keyword"&gt;if&lt;/span&gt; (window.navigator.connection === &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;cellular&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; ||
    window.navigator.connection === &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;none&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;false&lt;/span&gt;;
  } &lt;span class="keyword"&gt;else&lt;/span&gt; {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="predefined-constant"&gt;true&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Adapter#shouldBackgroundReloadRecord&lt;/code&gt; is called by the store when the
store is resolving the &lt;code&gt;findRecord&lt;/code&gt; promise with a cached record. If
this method returns &lt;code&gt;true&lt;/code&gt; the store will attempt to reload the record
from the adapter in the background. The default implementation for
this method in Ember Data 1.13 is to always return &lt;code&gt;false&lt;/code&gt;, in order
to ease the upgrade path. However in
Ember Data 2.0 this will be changed to always return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Symmetric methods have also been added for &lt;code&gt;store.findAll&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;  &lt;span class="function"&gt;shouldReloadAll&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, snapshotRecordArray)
  &lt;span class="function"&gt;shouldBackgroundReloadAll&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(store, snapshotRecordArray)
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/eccegordo"&gt;@eccegordo&lt;/a&gt; put together this table
listing all the new store apis and the methods they replace.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Ember beta.19&lt;/th&gt;
      &lt;th&gt;Ember 1.13&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.getById(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.peekRecord(type, id)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.all(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.peekAll(type)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.find(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.findRecord(type, id, options)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.find(type)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.findAll(type, options)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.queryRecord(type, query)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.find(type, { query })&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.query(type, query)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;store.fetch(type, id)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;store.findRecord(type, id, {reload: true})&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 class='anchorable-toc' id='toc_json-api-support'&gt;JSON API Support&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_json-api-adapter-and-serializer'&gt;JSON API Adapter and Serializer&lt;/h3&gt;
&lt;p&gt;Ember Data 1.13 comes with support for &lt;a href="http://jsonapi.org/"&gt;JSON API&lt;/a&gt;
1.0. There is a new &lt;code&gt;DS.JSONAPIAdapter&lt;/code&gt; and &lt;code&gt;DS.JSONAPISerializer&lt;/code&gt;
that support working with JSON API backends. In Ember Data 2.0 the
JSON API Adapter will be the default loaded by Ember Data.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_internal-format-change-to-json-api'&gt;Internal Format Change to JSON API&lt;/h3&gt;
&lt;p&gt;In Ember Data beta.19, you communicated updates to the store by calling
&lt;code&gt;store.push(type, id)&lt;/code&gt;. We have now changed &lt;code&gt;store.push&lt;/code&gt; so it receives a 
JSON API object, &lt;code&gt;store.push({JSON API compound document})&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.push(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Pangratz&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;becomes&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;store.push({
  &lt;span class="key"&gt;data&lt;/span&gt;: {
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;attributes&lt;/span&gt;: { 
      &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Pangratz&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; 
    }
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This allows for much better and fine grained meta handling, and ensures we do
not have to support, maintain and document a completely custom JSON format
as we had to until now, but can just reference the &lt;a href="http://jsonapi.org/"&gt;JSON API specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We will be publishing an &lt;a href="https://github.com/abuiles/ember-watson"&gt;ember-watson&lt;/a&gt; helper that will be rewriting all the uses
of &lt;code&gt;store.push&lt;/code&gt; inside your tests to the new format, as well as addon with helpers
that convert the old &lt;code&gt;store.push&lt;/code&gt; format into the new format.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_new-serializer-api-for-custom-serializer-authors'&gt;New Serializer API for custom Serializer authors&lt;/h3&gt;
&lt;p&gt;If you made a &lt;code&gt;store.findRecord(&amp;#39;user&amp;#39;, 1)&lt;/code&gt; request in Ember Data beta.19
and your server payload looked like:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;user&lt;/span&gt;: { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;accounts&lt;/span&gt;: [&lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="integer"&gt;2&lt;/span&gt;] },
  &lt;span class="key"&gt;accounts&lt;/span&gt;: [
    { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@sweden.se&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; },
    { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;2&lt;/span&gt;, &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@greece.gr&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; }
  ]
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Your serializer would get the payload passed in an &lt;code&gt;extract&lt;/code&gt; hook and its job was to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;normalize and &lt;code&gt;store.push&lt;/code&gt; everything that is not the &lt;code&gt;primary record&lt;/code&gt;, in this
case the array of sideloaded accounts&lt;/li&gt;
&lt;li&gt;normalize and return the primary data, in this case the &lt;code&gt;user&lt;/code&gt; data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Having these two ways of pushing data to the store, with both returning primary record data
from &lt;code&gt;extract&lt;/code&gt; hooks but also doing &lt;code&gt;store.push&lt;/code&gt; with other data was both confusing,
hard to debug and optimize and also prevented us from implementing proper metadata support, especially for sideloaded arrays and records.&lt;/p&gt;

&lt;p&gt;In Ember Data 1.13 this process has been greatly simplified. &lt;strong&gt;In 1.13 Serializers
should just make the whole payload conform to the JSON API spec, and return the whole payload&lt;/strong&gt;. They should no longer &lt;code&gt;store.push&lt;/code&gt; themselves.&lt;/p&gt;

&lt;p&gt;In order to be backwards compatible, we created a new hook &lt;code&gt;normalizeResponse&lt;/code&gt; which
Serializers should now implement, and just return JSON API from that hook.&lt;/p&gt;

&lt;p&gt;For example a Serializer responsible for normalizing the above sample payload would just transform it to:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
17
18
19
&lt;strong&gt;20&lt;/strong&gt;
21
22
23
24
25
26
27
28
29
&lt;strong&gt;30&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;data&lt;/span&gt;: { 
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;user&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, 
    &lt;span class="key"&gt;attributes&lt;/span&gt;: {
      &lt;span class="key"&gt;name&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
    }, 
    &lt;span class="key"&gt;relationships&lt;/span&gt;: {
      &lt;span class="key"&gt;accounts&lt;/span&gt;: {
        &lt;span class="key"&gt;data&lt;/span&gt;: [
          { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; },
          { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;2&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; }
        ]
      }
    }
  },
  &lt;span class="key"&gt;included&lt;/span&gt;: [{ 
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;1&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;attributes&lt;/span&gt;: {
      &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@sweden.se&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  }, {
    &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;2&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;type&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;account&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="key"&gt;attributes&lt;/span&gt;: {
      &lt;span class="key"&gt;email&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;wecc@greece.gr&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
    }
  }]
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We will be posting a detailed Serializer transition guide shortly.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_new-jsonserializer-and-restserializer-api'&gt;New JSONSerializer and RESTSerializer API&lt;/h3&gt;
&lt;p&gt;As we rewrote JSONSerializer and RESTSerializer to implement the new
Serializer API we also simplified and greatly improved their own APIs.
Previously the possible places to modify a response for &lt;code&gt;store.find(&amp;#39;user&amp;#39;, 1)&lt;/code&gt; were&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFind&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractSingle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizePayload&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeHash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractMeta&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeRelationships&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeAttributes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The new Serializer API allowed us to simplify these. If you receive a response 
to &lt;code&gt;store.findRecord(&amp;#39;user&amp;#39;, 1)&lt;/code&gt; in Ember Data 1.13 you can customize your response
in&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;normalizeResponse&lt;/code&gt; - entry method to the Serializer and responsible for normalizing any response, gets the full payload, returns a JSON API compound document&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalizeFindRecordResponse&lt;/code&gt; - a normalizeResponse for a specific operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalize&lt;/code&gt; - normalizes data for a single record, returns a JSON API compound document

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extractId&lt;/code&gt; | &lt;code&gt;extractAttributes&lt;/code&gt; | &lt;code&gt;extractRelationships&lt;/code&gt; - normalize delegates to these methods to extract the id, attributes and relationships from the payload. They receive the full payload for a single record and return the subsets of data for id, attributes and relationships, conforming to the JSON API specification.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;extractMeta - extracts the metadata for a payload&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_transition-to-the-new-jsonserializer-and-restserializer-apis'&gt;Transition to the new JSONSerializer and RESTSerializer APIs&lt;/h4&gt;
&lt;p&gt;If you have a custom serializer you will need to make some new changes
to your serializer to get it ready for Ember Data 2.0.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_custom-code-extract-code-methods'&gt;Custom &lt;code&gt;extract&lt;/code&gt; Methods&lt;/h5&gt;
&lt;p&gt;If you have custom &lt;code&gt;extract&lt;/code&gt; hooks you need to do two things:&lt;/p&gt;

&lt;p&gt;First, rename:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extract()              =&amp;gt; normalizeResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindAll()       =&amp;gt; normalizeFindAllResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFind()          =&amp;gt; normalizeFindRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindMany()      =&amp;gt; normalizeFindManyResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindBelongsTo() =&amp;gt; normalizeFindBelongsToResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindHasMany()   =&amp;gt; normalizeFindHasManyResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractFindQuery()     =&amp;gt; normalizeQueryResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractQueryRecord()   =&amp;gt; normalizeQueryRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractCreateRecord()  =&amp;gt; normalizeCreateRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractDeleteRecord()  =&amp;gt; normalizeDeleteRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractUpdateRecord()  =&amp;gt; normalizeUpdateRecordResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractSave()          =&amp;gt; normalizeSaveResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractSingle()        =&amp;gt; normalizeSingleResponse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extractArray()         =&amp;gt; normalizeArrayResponse()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Second, make sure that your &lt;code&gt;extract&lt;/code&gt; hooks return a full JSON API compound document
(&lt;a href="http://jsonapi.org/format/#document-top-level"&gt;http://jsonapi.org/format/#document-top-level&lt;/a&gt;) with the primary
resource(s) in a &lt;code&gt;data&lt;/code&gt; array or object and eventual sideloaded
resources in a &lt;code&gt;included&lt;/code&gt; array. Every resource object
(&lt;a href="http://jsonapi.org/format/#document-resource-objects"&gt;http://jsonapi.org/format/#document-resource-objects&lt;/a&gt;) has to
follow the JSON API format with &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, attributes in
&lt;code&gt;attributes&lt;/code&gt; and relationships in &lt;code&gt;relationships&lt;/code&gt;. For the full
specification of the JSON API format see
&lt;a href="http://jsonapi.org/format/"&gt;http://jsonapi.org/format/&lt;/a&gt;.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_custom-code-extractmeta-code-method'&gt;Custom &lt;code&gt;extractMeta&lt;/code&gt; Method&lt;/h5&gt;
&lt;p&gt;If you have a custom &lt;code&gt;extractMeta&lt;/code&gt; method you have to make sure it
returns the meta data instead of calling &lt;code&gt;store.setMetadataFor()&lt;/code&gt; (or
relying on &lt;code&gt;_super&lt;/code&gt; to do so).&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_custom-code-normalize-code-method'&gt;Custom &lt;code&gt;normalize&lt;/code&gt; Method&lt;/h5&gt;
&lt;p&gt;If you have a custom &lt;code&gt;normalize()&lt;/code&gt; method you need to update this to
return a full JSON API Document
(&lt;a href="http://jsonapi.org/format/#document-top-level"&gt;http://jsonapi.org/format/#document-top-level&lt;/a&gt;) with the primary
resource object
(&lt;a href="http://jsonapi.org/format/#document-resource-objects"&gt;http://jsonapi.org/format/#document-resource-objects&lt;/a&gt;) located in
&lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_opt-into-the-new-serializer-api'&gt;Opt Into the New Serializer API&lt;/h5&gt;
&lt;p&gt;To tell Ember Data that you are ready to use the new Serializer API,
add &lt;code&gt;isNewSerializerAPI: true&lt;/code&gt; when extending &lt;code&gt;JSONSerializer&lt;/code&gt; or
&lt;code&gt;RESTSerializer&lt;/code&gt;. The new &lt;code&gt;JSONAPISerializer&lt;/code&gt; uses the new Serializer
API by default. The &lt;code&gt;isNewSerializerAPI&lt;/code&gt; flag is &lt;strong&gt;only&lt;/strong&gt; required for
Ember Data 1.13 and will be removed in Ember Data 2.0. The new
&lt;code&gt;JSONAPISerializer&lt;/code&gt; only supports the new Serializer API.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://github.com/wecc"&gt;@wecc&lt;/a&gt; for his hard work on
implementing this feature in a backwards compatible way.&lt;/p&gt;

&lt;p&gt;We would also like thank &lt;a href="https://github.com/kurko"&gt;@kurko&lt;/a&gt;
for his efforts maintaining the
&lt;a href="https://github.com/kurko/ember-json-api"&gt;community JSON API adapter&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-errors-api'&gt;New Errors API&lt;/h2&gt;
&lt;p&gt;Similarly to the find APIs, our error handling APIs have grown over time,
and the switch to JSON API has given us a great opportunity for cleanup
and standardisation. &lt;a href="https://twitter.com/tchak13"&gt;@tchak&lt;/a&gt; has done a great job rewriting our
Errors API to be JSON API compatible, while keeping backwards support for
REST/JSON/ActiveModel adapters. There are two main changes in Ember Data 1.13
error handling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cleaner adapter hooks for errors&lt;/li&gt;
&lt;li&gt;Using JSON API Error object format&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class='anchorable-toc' id='toc_cleaner-adapter-hooks-for-errors'&gt;Cleaner adapter hooks for errors&lt;/h3&gt;
&lt;p&gt;Previously, if you were subclassing the &lt;code&gt;RestAdapter&lt;/code&gt; you could overwrite
&lt;code&gt;ajaxSuccess&lt;/code&gt; and &lt;code&gt;ajaxError&lt;/code&gt; hooks to implement custom error handling.
However, potential errors come in many flavors. For example, you could be receiving responses with a status code of &lt;code&gt;200&lt;/code&gt; with the body of &lt;code&gt;{ error: error }&lt;/code&gt;. In this case it was not intuitive to write error handling code in a method called &lt;code&gt;ajaxSuccess&lt;/code&gt;. Because of this and many other examples, we realized that &lt;code&gt;ajaxSuccess&lt;/code&gt; and &lt;code&gt;ajaxError&lt;/code&gt; were not the
correct level at which to implement error handling.&lt;/p&gt;

&lt;p&gt;In Ember Data 1.13 we are introducing a new, simpler adapter hook:
&lt;code&gt;handleResponse&lt;/code&gt; while deprecating &lt;code&gt;ajaxSuccess&lt;/code&gt; and
&lt;code&gt;ajaxError&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;The responsibility of &lt;code&gt;handleResponse&lt;/code&gt; is to take the returned status,
response headers and payload, and decide whether to pass the payload through as
a success, or to return an instance of &lt;code&gt;AdapterError&lt;/code&gt; or &lt;code&gt;InvalidError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, if your API engineers for some unknown reason decided to return
&lt;code&gt;200 OK&lt;/code&gt; with an error message, you could subclass your adapter to handle this:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="function"&gt;handleResponse&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(status, headers, payload) {
  &lt;span class="keyword"&gt;if&lt;/span&gt; (status === &lt;span class="integer"&gt;200&lt;/span&gt; &amp;amp;&amp;amp; payload.errors) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="keyword"&gt;new&lt;/span&gt; InvalidError(payload.errors);
  }
  &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;._super(...&lt;span class="local-variable"&gt;arguments&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You could also subclass two helper methods, &lt;code&gt;isInvalid&lt;/code&gt; and &lt;code&gt;isSuccess&lt;/code&gt;
to customize when you adapter considers a request succesful or invalid.&lt;/p&gt;

&lt;p&gt;Default implementation of &lt;code&gt;isInvalid&lt;/code&gt; returns
true if http status code is &lt;code&gt;422&lt;/code&gt;, however, you may desire other
semantics, for example checking the &lt;code&gt;code&lt;/code&gt; property on a JSON API
error object.&lt;/p&gt;

&lt;p&gt;This refactor also allows us to abstract away the jQuery &lt;code&gt;jqXHR&lt;/code&gt; object, which
was tying Ember Data&amp;#39;s Rest Adapter too closely with jQuery&amp;#39;s implementation of ajax. New hooks take three arguments instead of &lt;code&gt;jqXHR&lt;/code&gt;: status code, a hash of
response headers and parsed payload. It makes them agnostic about the
underlying implementation and will allow us to easily use methods like
&lt;a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch?hl=en"&gt;fetch&lt;/a&gt;
in the future.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_using-json-api-error-object-format'&gt;Using JSON API Error object format&lt;/h3&gt;
&lt;p&gt;Similarly to the rest of Ember Data 1.13, we have refactored the error handling to use JSON API. JSON API has specified an
&lt;a href="http://jsonapi.org/format/#error-objects"&gt;error objects&lt;/a&gt;
format. Starting with Ember Data 1.13 we are using JSON API format to
communicate errors from the adapter to the store. 
We are deprecating the current Ruby on Rails inspired
format for creating &lt;code&gt;InvalidError&lt;/code&gt; objects and replacing it with
proper JSON API objects. The old format is supported with a
deprecation warning in 1.13.&lt;/p&gt;

&lt;p&gt;Deprecated format:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;new&lt;/span&gt; DS.InvalidError({
  &lt;span class="key"&gt;first_name&lt;/span&gt;: [&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;is invalid&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;]
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;New format:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;new&lt;/span&gt; DS.InvalidError([
  {
    &lt;span class="key"&gt;source&lt;/span&gt;: { &lt;span class="key"&gt;pointer&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;data/attributes/first_name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; },
    &lt;span class="key"&gt;detail&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;is invalid&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
  }
]);
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Thanks to &lt;a href="https://github.com/tchak"&gt;@tchak&lt;/a&gt; and
&lt;a href="https://github.com/twokul"&gt;@twokul&lt;/a&gt; for working on the design and
implementation of the new API.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_significant-deprecations'&gt;Significant Deprecations&lt;/h2&gt;
&lt;p&gt;In addition to new features, Ember Data 1.13 introduces deprecations for
features and behavior that will be removed in Ember Data 2.0.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_async-relationships'&gt;Async Relationships&lt;/h3&gt;
&lt;p&gt;In Ember Data 2.0 relationships will be asynchronous by default. Sync
relationships will still be supported but you will need to manually
opt into them by setting &lt;code&gt;{ async: false }&lt;/code&gt; on your
relationships. Ember Data 1.13 will log a deprecation warning you if
you have any relationships where the &lt;code&gt;async&lt;/code&gt; property is not
explicitly set. Additionally you can use
&lt;a href="https://github.com/abuiles/ember-watson"&gt;ember-watson&lt;/a&gt; to help
identify cases in your codebase where you have relationships without
an explicit &lt;code&gt;async&lt;/code&gt; property.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ds-store-filter-moved-to-an-addon'&gt;DS.Store#filter Moved to an Addon&lt;/h3&gt;
&lt;p&gt;With Ember Data 2.0 and the commitment to semver we found we were not
happy with the state of the current &lt;code&gt;store.filter()&lt;/code&gt; method. It
currently only supports a limited number of uses cases and often is a
source of memory leaks in long running applications. In order to give
Ember Data time to iterate on a better filter API the current
&lt;code&gt;store.filter&lt;/code&gt; method has been deprecated and its functionality is
being moved into an addon
&lt;a href="https://github.com/ember-data/ember-data-filter"&gt;https://github.com/ember-data/ember-data-filter/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In Ember 2.0, if you would like to use the current &lt;code&gt;store.filter&lt;/code&gt;
method you will need to include the ember-data-filter addon with your
application.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ds-activemodeladapter-moved-to-an-addon'&gt;DS.ActiveModelAdapter Moved to an Addon&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DS.ActiveModelAdapter&lt;/code&gt; and &lt;code&gt;DS.ActiveModelSerializer&lt;/code&gt; has also been
&lt;a href="https://github.com/ember-data/active-model-adapter"&gt;moved to an addon&lt;/a&gt;. It
will continue to be supported by the Ember Data team, however, it will
no longer ship with Ember Data by default in Ember Data 2.0.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_custom-stores'&gt;Custom Stores&lt;/h3&gt;
&lt;p&gt;Over the years, Ember Data has supported a number of namespaces where
custom stores can be defined. In order to make things conceptually
simpler Ember Data 2.0 will require custom stores to be define as a
service.&lt;/p&gt;

&lt;p&gt;If you have a custom store in your Ember CLI app defined in
&lt;code&gt;app/store.js&lt;/code&gt; you will need to move it to &lt;code&gt;app/services/store.js&lt;/code&gt;. If
you have a custom store in your globals app you will need to move it
to &lt;code&gt;App.StoreService&lt;/code&gt;.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_json-api-adapter-default'&gt;JSON API Adapter Default&lt;/h3&gt;
&lt;p&gt;In Ember Data 2.0 the default adapter will be the &lt;code&gt;JSONAPIAdapter&lt;/code&gt;. In
Ember Data 1.13 when loading the default &lt;code&gt;RESTAdapter&lt;/code&gt; there will be a
deprecation warning.&lt;/p&gt;

&lt;p&gt;To silence the warning and continue using the &lt;code&gt;RESTAdapter&lt;/code&gt; you will
need to set the &lt;code&gt;RESTAdapter&lt;/code&gt; as your application adapter.&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;td colspan="2"&gt;app/adapters/application.js&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="reserved"&gt;import&lt;/span&gt; DS from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;ember-data&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; DS.RESTAdapter;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_code-store-push-code-changes'&gt;&lt;code&gt;store.push&lt;/code&gt; Changes&lt;/h3&gt;
&lt;p&gt;Previously, Ember Data allowed users to add a record to the store
using &lt;code&gt;store.push(&amp;#39;model-name&amp;#39;, {})&lt;/code&gt;. This format has been deprecated
and now &lt;code&gt;store.push&lt;/code&gt; will take a JSON API document as its first and
only argument. This new change will allow Ember Data to get better
performance in Ember Data 2.0 by deferring the creation of DS.Model
instances until they are needed by user code. &lt;code&gt;store.pushMany&lt;/code&gt; has
also been deprecated because you can push multiple records using in a
JSON API document.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_code-rollback-code-renamed-to-code-rollbackattributes-code'&gt;&lt;code&gt;rollback&lt;/code&gt; Renamed to &lt;code&gt;rollbackAttributes&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;record.rollback()&lt;/code&gt; has been deprecated to
&lt;code&gt;record.rollbackAttributes()&lt;/code&gt;. This new name more closely matches its
behavior and will allow for a new &lt;code&gt;record.rollback()&lt;/code&gt; to be introduced
in the future that rolls back relationships in addition to attributes.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_code-isdirty-code-renamed-to-code-hasdirtyattributes-code'&gt;&lt;code&gt;isDirty&lt;/code&gt; Renamed to &lt;code&gt;hasDirtyAttributes&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;record.isDirty()&lt;/code&gt; has been deprecated to
&lt;code&gt;record.hasDirtyAttributes()&lt;/code&gt;. This new name more closely matches its
behavior and will allow for a new &lt;code&gt;record.hasDirtyRelationships()&lt;/code&gt; to be introduced
in the future that allows you to check dirtiness of relationships.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_preloading-record-data-on-find'&gt;Preloading Record Data on Find&lt;/h3&gt;
&lt;p&gt;If you previously used the preload argument to &lt;code&gt;store.find&lt;/code&gt; it has
been moved into the preload key on &lt;code&gt;findRecord&lt;/code&gt;&amp;#39;s options argument&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// Deprecated&lt;/span&gt;
store.find(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comment&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;post&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt; });

&lt;span class="comment"&gt;// Ember Data 1.13 style&lt;/span&gt;
store.findRecord(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comment&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="integer"&gt;1&lt;/span&gt;, { &lt;span class="key"&gt;preload&lt;/span&gt;: { &lt;span class="key"&gt;post&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt; }});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h2 class='anchorable-toc' id='toc_changelog'&gt;Changelog&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/emberjs/data/blob/3bce36295a6e9f1bbe4824505046d22dc04d056d/CHANGELOG.md#release-113-june-16-2015"&gt;Ember Data 1.13&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>The Ember 2.x Project</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html"/>
    <id>http://emberjs.com/blog/2015/06/16/ember-project-at-2-0.html</id>
    <published>2015-06-15T20:00:00-04:00</published>
    <updated>2015-06-15T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;For the past several years, when we've talked about "Ember releases", we were always talking about releases of the Ember codebase itself.&lt;/p&gt;

&lt;p&gt;In practice, that has meant that in order to put together the full, recommended Ember stack, you needed to figure...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;For the past several years, when we&amp;#39;ve talked about &amp;quot;Ember releases&amp;quot;, we were always talking about releases of the Ember codebase itself.&lt;/p&gt;

&lt;p&gt;In practice, that has meant that in order to put together the full, recommended Ember stack, you needed to figure out not just what Ember version to use, but what versions of our other libraries and tools worked with it.&lt;/p&gt;

&lt;p&gt;Starting with Ember 2.0, we will coordinate every release of Ember with releases of the main ecosystem tools maintained by the core team:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ember CLI&lt;/li&gt;
&lt;li&gt;Ember.js&lt;/li&gt;
&lt;li&gt;Ember Data&lt;/li&gt;
&lt;li&gt;Liquid Fire&lt;/li&gt;
&lt;li&gt;List View&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;All of these tools will share a version number with Ember itself.&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;Upgrading to Ember 2.3 means that you&amp;#39;ll get a new version of the Ember tools and a new version of Ember. You&amp;#39;ll also get new versions of Liquid Fire, List View and Ember Data designed to work with (and tested against) Ember 2.3.&lt;/p&gt;

&lt;p&gt;These projects will also ship betas alongside Ember itself, meaning that when Ember 2.3-beta.1 is released, there will be versions of Ember Data, Liquid Fire and List View released at the same time that are tested against the new beta.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We are in the process of aligning the versions now; you should start to see releases of Ember Data and Liquid Fire numbered &amp;quot;2.0 beta&amp;quot; in the next few days.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At a high level, the goal of these releases is for &amp;quot;upgrading to Ember 2.3&amp;quot; to mean upgrading Ember CLI to that version, and getting all of the improvements across all of the projects at once, without having to figure out how to separately upgrade each piece.&lt;/p&gt;

&lt;p&gt;We expect that Semver and a shared community experience of upgrading at once will make this upgrade relatively painless, and will continue to work on improvements to the process that eliminates sources of pain due to upgrades. (See the &lt;a href="https://github.com/emberjs/rfcs/blob/two-dot-x-improvements/active/0000-improved-release-cycle.md"&gt;Release Cycle Improvements&lt;/a&gt; RFC for more on improvements we already have planned for the 2.x cycle.)&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_frequently-asked-questions'&gt;Frequently Asked Questions&lt;/h3&gt;
&lt;p&gt;While I tried to answer the most common questions I&amp;#39;ve heard from people, I&amp;#39;m sure I missed some.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What does this mean for right now?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We have shipped Ember 2.0 beta, and are in the process of shipping &amp;quot;2.0 beta&amp;quot; versions of the remaining projects.&lt;/p&gt;

&lt;p&gt;In practice, this means shipping a final version of the projects that will be compatible with Ember 1.13, and buttoning up any final changes that need to be made before they join Ember&amp;#39;s semantic versioning pace.&lt;/p&gt;

&lt;p&gt;There will be a separate blog post in the next few days describing precisely how this will affect Ember Data, but the short version is the same. There will be a final version of Ember Data that will be compatible with the versions that have been shipping all year, and then we will ship Ember Data 2.0 beta, aligned with Ember itself.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Doesn&amp;#39;t this mean that Ember is becoming a huge monolithic project that is now tightly coupled with all of these other projects?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No. The reason to share a version number is almost entirely about convenience and a less fragmented ecosystem. While it is technically true that Liquid Fire 2.4 will work fine with Ember 2.6, this means that applications will practically be on a smorgasboard of versions of the core libraries, making it harder to write tutorials and answer questions, even once it is clear what version of Ember a user is using.&lt;/p&gt;

&lt;p&gt;What this means it that if a user is using Ember 2.4, and asks a question about animations or Ember Data, it is possible to answer the question without asking a half-dozen other questions to learn basic things about the user&amp;#39;s environment.&lt;/p&gt;

&lt;p&gt;Similarly, if you are looking at a tutorial that was built for Ember 2.4, you know that it will not be targeting a different version of the other core libraries, with the caveats that would bring.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;But doesn&amp;#39;t this mean that upgrading Ember is a huge &amp;quot;big bang
upgrade&amp;quot; that will take an even longer amount of time to perform now that it&amp;#39;s coupled with Ember CLI, Ember Data, and Liquid Fire?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While in principle upgrading Ember.js without one of the other libraries might seem like it would take less time, we don&amp;#39;t think this is true in practice.&lt;/p&gt;

&lt;p&gt;By aligning the release cycles and versions of the most common libraries, it is possible for upgrade guides to cover all of the instructions that you will need in one place, and you will be sharing an upgrade experience with the rest of the ecosystem.&lt;/p&gt;

&lt;p&gt;When you ask a question in IRC, on GitHub Issues or on Stack Overflow about upgrading to Ember 2.4, the known caveats for the entire upgrade process will be well-known and well-trod.&lt;/p&gt;

&lt;p&gt;This is not the case if you are trying to upgrade to Ember 2.5 while remaining on Ember CLI 2.2 with List View 2.3 and Liquid Fire 2.1. It &lt;strong&gt;might&lt;/strong&gt; work out, but the number of people sharing the same combination will be very low, and the people maintaining the libraries might not even have considered that precise combination.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In practice, the fact that all of these libraries share the same SemVer requirements should make upgrading across all five components more straight forward than trying to cobble together a multi-version stack yourself.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I don&amp;#39;t agree with anything you said here and just want to pick and choose the versions of the libraries I want to use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go for it! The people maintaining each of these libraries want older versions of the libraries to work with newer versions of Ember, because it makes their jobs easier.&lt;/p&gt;

&lt;p&gt;If you are deeply committed to upgrading a piece at a time, even though it will mean you will need to work out the details on your own, feel free to attempt it, and report bugs if you encounter any problems.&lt;/p&gt;

&lt;p&gt;(There is one minor caveat. As of Ember 2.0, Liquid Fire and Ember Data make minor use of private Ember APIs. We intend to replace those APIs with public APIs within the first few releases.)&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember.js 1.13.0 and 2.0 Beta Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html"/>
    <id>http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html</id>
    <published>2015-06-11T20:00:00-04:00</published>
    <updated>2015-06-11T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We are pleased to announce the release of both Ember.js 1.13.0 and the
first beta in the 2.0 series. This comes as the thirteenth cycle of our
release process that began just after 1.0 was released.&lt;/p&gt;

&lt;p&gt;The 1.13 release represents the effort of at least...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We are pleased to announce the release of both Ember.js 1.13.0 and the
first beta in the 2.0 series. This comes as the thirteenth cycle of our
release process that began just after 1.0 was released.&lt;/p&gt;

&lt;p&gt;The 1.13 release represents the effort of at least 43 contributors
across over 680 commits.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 1.13 is the last release in the 1.x series and the first release that includes the Glimmer rendering engine.&lt;/strong&gt; It includes a number of deprecations that will ease the upgrade to Ember 2.0, which is due to land in six weeks.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ember 2.0 beta is the first release in the 2.x series.&lt;/strong&gt; This means that many features deprecated during the 1.x series will be removed in Ember 2.0. If you encounter any unexpected changes in features not marked as deprecated in 1.13 while testing Ember 2.0 beta, please report them immediately. We would like to fix these unintentional regressions before the final release of 2.0 in six weeks.&lt;/p&gt;

&lt;p&gt;The release of Ember 2.0 beta also means that the first features in Ember 2.1 (most notably angle bracket components), are in their final canary stretch. Now is a good time to comment on RFCs and pull requests related to those features.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features-in-ember-js-1-13'&gt;New Features in Ember.js 1.13&lt;/h2&gt;
&lt;p&gt;The Glimmer rendering engine, &lt;a href="https://www.youtube.com/watch?v=o12-90Dm-Qs&amp;amp;feature=youtu.be&amp;amp;t=47m21s"&gt;announced at EmberConf&lt;/a&gt; and introduced to Ember.js
Canary on &lt;a href="/blog/2015/05/05/glimmer-merging.html"&gt;May 5th&lt;/a&gt;, is released today
in Ember.js 1.13. Glimmer is the third overhaul of Ember&amp;#39;s 1.x rendering
layer (wow, right?), and dramatically improves re-render performance in many
common scenarios. Additionally it lays important groundwork for the Ember 2.x
development model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We are tremendously excited to bring Glimmer to existing applications as
a 1.x compatible minor release.&lt;/strong&gt; The herculean efforts of the Ember core team,
addon authors, and community to achieve this release has been inspiring.
Thank you! You are too many to possibly name.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.13 also marks the final minor release of the Ember 1.x cycle.&lt;/strong&gt; As such,
it contains a number of deprecations ahead of Ember 2.0. Resolving these
deprecations in application code aligns that application with Ember&amp;#39;s public
API in 2.0. In general, Ember apps running 1.13 without causing any deprecation notices
to fire should upgrade to 2.0 without changes.&lt;/p&gt;

&lt;p&gt;The easiest way to work through deprecations is the &lt;strong&gt;Ember Inspector&lt;/strong&gt;. Thanks to the work of Teddy Zeenny, deprecations will be routed to the &amp;quot;Deprecations&amp;quot; inspector pane, where you can get a grouped list of them as well as the line of code in your app that triggered the deprecation. You can also ask for a full stack trace of any deprecation.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_improved-rerender-performance'&gt;Improved Rerender Performance&lt;/h4&gt;
&lt;p&gt;Previous iterations of Ember&amp;#39;s rendering engine &lt;strong&gt;relied&lt;/strong&gt; on granular observation for efficiency. When a piece of dynamic content was rendered, Ember registered observers, updating the content when the value changed.&lt;/p&gt;

&lt;p&gt;While this was reasonably efficient in cases where the developer could easily use &lt;code&gt;set&lt;/code&gt; (and the array equivalents) to mutate values, it had two related issues:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This forced developers to represent all changes in terms of granular
observers. In many cases this could be extremely awkward. This was
especially problematic when working with Arrays, since (for example)
representing a sort as a series of mutations is conceptually complex
and can be cost-prohibitive.&lt;/li&gt;
&lt;li&gt;Ember itself was extremely inefficient when an entire object or
array was replaced, despite the fact that this was often the most
natural way to represent the change. This meant that while it was
usually possible in theory to &amp;quot;just re-render&amp;quot; a component, it was,
in practice, cost prohibitive (to say the least).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To address these issues, Glimmer adopts a value-diffing strategy, using a virtual tree of the dynamic areas of the DOM. This means that even if the original data structure (for example, an array) is completely replaced, the DOM is not updated unless the resulting rendered content has changed.&lt;/p&gt;

&lt;p&gt;When updating an array with a new array (because you got a new array from the server, or because you produced a new array through &lt;code&gt;.sort()&lt;/code&gt;), you will see a large improvement in performance, &lt;strong&gt;making this kind of replacement plausible in Ember.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Notably, the Ember strategy continues to support efficient updates via value observation, which we expect to be useful when communicating with services and models.&lt;/p&gt;

&lt;p&gt;Glimmer&amp;#39;s hybrid model can opportunistically take advantage of explicit mutation (via &lt;code&gt;set&lt;/code&gt;) when it is used, while also supporting efficient re-renders of entire data structures, updating only the DOM  nodes that need to be changed.&lt;/p&gt;

&lt;p&gt;The result is a stunning improvement in many rerender cases.&lt;/p&gt;

&lt;p&gt;We would like to thank React for showing that full re-renders can be made efficient. While we did not use their precise Virtual DOM approach, their work with Virtual DOM was extremely influential to our approach in Glimmer.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/wycats"&gt;@wycats&lt;/a&gt; and &lt;a href="https://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt;
for their continued focus on improving
Glimmer&amp;#39;s performance, and to &lt;a href="http://www.linkedin.com"&gt;LinkedIn&lt;/a&gt; and
&lt;a href="http://www.bustle.com/"&gt;Bustle&lt;/a&gt; for their
generous sponsorship of this work.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_component-lifecycle-hooks'&gt;Component Lifecycle Hooks&lt;/h4&gt;
&lt;p&gt;A number of new component lifecycle hooks have been introduced to Ember 1.13.
Using these hooks allows you to write data down, action up (DDAU) style
components today, despite the two-way data binding of curly components.&lt;/p&gt;

&lt;p&gt;On first render (in order):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didInitAttrs&lt;/code&gt; runs after a component was created and passed attrs are guaranteed to be present. In Ember 1.13, the attributes will be available as &lt;code&gt;this.get(&amp;#39;attrName&amp;#39;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt; runs after &lt;code&gt;didInitAttrs&lt;/code&gt;, and it also runs on
subsequent re-renders, which is useful for logic that is the same
on all renders. It does not run when the component has been re-rendered from the inside.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt; runs before the template is rendered. It runs when the
template is updated for any reason (both initial and re-render, and
regardless of whether the change was caused by an attrs change or
re-render).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didInsertElement&lt;/code&gt; runs after the template has rendered and the
element is in the DOM.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt; runs after &lt;code&gt;didInsertElement&lt;/code&gt; (it also runs on subsequent
re-renders).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On re-render (in order):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didUpdateAttrs&lt;/code&gt; runs when the attributes of a component have changed
(but not when the component is re-rendered, via &lt;code&gt;component.rerender&lt;/code&gt;,
&lt;code&gt;component.set&lt;/code&gt;, or changes in models or services used by the
template).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt;, same as above.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willUpdate&lt;/code&gt; runs when the component is re-rendering for any reason,
including &lt;code&gt;component.rerender()&lt;/code&gt;, &lt;code&gt;component.set()&lt;/code&gt; or changes in
models or services used by the template.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt;, same as above&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didUpdate&lt;/code&gt; runs after the template has re-rendered and the DOM is
now up to date.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt;, same as above.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that a component is re-rendered whenever:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;any of its attributes change&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component.set()&lt;/code&gt; is called&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component.rerender()&lt;/code&gt; is called&lt;/li&gt;
&lt;li&gt;a property on a model or service used by the template has changed
(including through computed properties).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Because of the Glimmer engine, these re-renders are fast, and avoid
unnecessary work.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_closure-actions'&gt;Closure Actions&lt;/h4&gt;
&lt;p&gt;In Ember 1.x, the actions system used bubbling as a solution for passing user
behavior to a parent scope. For example, when clicking a button an action
might bubble through several controllers then be handled on a route.&lt;/p&gt;

&lt;p&gt;Action bubbling was difficult to debug, and plagued by an inability to have
a return value (since the return value of an action handler controlled further
bubbling).&lt;/p&gt;

&lt;p&gt;Ember 2.x is component-driven, and replaces action bubbling with a function-passing
solution. This greatly simplifies working with actions (they are just functions),
enables return values, and introduces some powerful new currying capabilities.&lt;/p&gt;

&lt;p&gt;For example, action &lt;code&gt;submit&lt;/code&gt; is passed to &lt;code&gt;my-component&lt;/code&gt; where it is called upon
click:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/controllers/index.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Controller.extend({
  &lt;span class="key"&gt;actions&lt;/span&gt;: {
    setName(name) {
      model.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, name);
    }
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/templates/index.hbs }}
{{my-component submit=(action 'setName')}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/components/my-component.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Component.extend({
  click() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.attrs.submit(&lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;name&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;));
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Actions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Can be passed multiple arguments&lt;/li&gt;
&lt;li&gt;Return a value. For example &lt;code&gt;var result = this.attrs.submit();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can curry. For example &lt;code&gt;submit=(action &amp;#39;setName&amp;#39; &amp;#39;Sal&amp;#39;)&lt;/code&gt; would pass &lt;code&gt;&amp;quot;Sal&amp;quot;&lt;/code&gt; as
the first argument to &lt;code&gt;setName&lt;/code&gt; when &lt;code&gt;submit&lt;/code&gt; is called. Actions can curry
multiple times, adding arguments at each scope. For example &lt;code&gt;submit=(action attrs.actionPassedIn someProp)&lt;/code&gt; just adds an argument to any already curried onto &lt;code&gt;actionPassedIn&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally the &lt;code&gt;action&lt;/code&gt; helper has two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(action &amp;#39;save&amp;#39; target=session)&lt;/code&gt; would look at the &lt;code&gt;actions&lt;/code&gt; hash on the
&lt;code&gt;session&lt;/code&gt; object instead of the current context.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(action &amp;#39;save&amp;#39; value=&amp;quot;currentTarget.value&amp;quot;)&lt;/code&gt; would read the path &lt;code&gt;currentTarget.value&lt;/code&gt;
off whatever the first argument to the called action is. This is handy for
destructuring objects passed as the first argument (like DOM events).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_note-angle-bracket-components'&gt;Note: Angle Bracket Components&lt;/h4&gt;
&lt;p&gt;Ember 2.1 will (likely) ship with angle-bracket components, which will introduce one-way data flow &lt;strong&gt;by default&lt;/strong&gt;, and provide an opt-in for two-way data flow. Existing components maintain the existing behavior (for compatibility). While the internals of Ember 2.0 support a distinction between one-way and two-way bindings, that distinction will remain largely internal until Ember 2.1.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_new-ember-js-helper-api'&gt;New Ember.js Helper API&lt;/h4&gt;
&lt;p&gt;Ember&amp;#39;s helper story prior to 1.13 has been inconsistent and neglected. In
1.13, we&amp;#39;re introducing a new API for writing helpers along with a set of
constraints and features informed by real-world experience.&lt;/p&gt;

&lt;p&gt;Ember helpers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Represent a single value&lt;/li&gt;
&lt;li&gt;Do not manage DOM or control flow&lt;/li&gt;
&lt;li&gt;Can recompute themselves, similar to how a component can rerender&lt;/li&gt;
&lt;li&gt;Can optionally access services&lt;/li&gt;
&lt;li&gt;Do not require a dash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Helpers come in two flavors. The first is a function-based API we call a
shorthand helper. For example, this shorthand helper joins a first and
last name:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/helpers/full-name.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Helper.helper(&lt;span class="keyword"&gt;function&lt;/span&gt;(params, hash) {
  &lt;span class="keyword"&gt;return&lt;/span&gt; params.join(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This helper can be used in a variety of contexts:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{full-name &amp;quot;Daniel&amp;quot; model.lastName}}
{{my-component name=(full-name model.firstName &amp;quot;Smith&amp;quot;)}}
{{! The following usage would set the model.name to the new full name
    when my-component calls the submit action. }}
{{my-component submit=(action (mut model.name) (full-name model.firstName &amp;quot;Smith&amp;quot;))}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Helpers receive two arguments: &lt;code&gt;params&lt;/code&gt; are the ordered params passed to a
helper, and &lt;code&gt;hash&lt;/code&gt; contains the key-value options, for example &lt;code&gt;title=&amp;quot;Mr.&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This function version satisfies a wide array of use-cases and is quite powerful. In general, you should use this helper form unless you have a strong reason to do otherwise.&lt;/p&gt;

&lt;p&gt;Some helpers, especially in addons, may require access to other parts of Ember (services), and
some control over their own invalidation and recomputation. In these cases, a helper class can be used.&lt;/p&gt;

&lt;p&gt;For example, this helper computes a name based on a &lt;code&gt;name-builder&lt;/code&gt; service. It
also recomputes whenever the &lt;code&gt;isAnonymized&lt;/code&gt; state on that service changes:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/helpers/full-name.js&lt;/span&gt;
&lt;span class="reserved"&gt;import&lt;/span&gt; Ember from &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;ember&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; Ember.Helper.extend({
  &lt;span class="comment"&gt;// This service name is only an example&lt;/span&gt;
  &lt;span class="key"&gt;nameBuilder&lt;/span&gt;: Ember.service.inject(),
  compute(params, hash) {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;nameBuilder&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).build(params, hash.title);
  },
  &lt;span class="key"&gt;rebuildName&lt;/span&gt;: Ember.observer(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;nameBuilder.isAnonymized&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.recompute();
  })
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;For more information on the new helper API please see &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0053-helpers.md"&gt;RFC #53&lt;/a&gt; on helpers and &lt;a href="https://github.com/emberjs/rfcs/pull/58"&gt;RFC #58&lt;/a&gt;
on dashless helpers. Thanks to the addon community (especially &lt;a href="https://twitter.com/jamesarosen"&gt;@jamesarosen&lt;/a&gt;) for bringing the
requirements for this API to our attention and testing changes with little notice.
Thanks to &lt;a href="https://twitter.com/mixonic"&gt;@mixonic&lt;/a&gt;
and &lt;a href="https://twitter.com/rwjblue"&gt;@rwjblue&lt;/a&gt; for the implementation.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_component-block-info'&gt;Component Block Info&lt;/h4&gt;
&lt;p&gt;Ember.js 1.13 introduces two new template keywords that provide reflection on
how a component is called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hasBlock&lt;/code&gt; will be true when a component is invoked in block form. For example
given this component:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/components/show-full-name.hbs }}
{{#if hasBlock}}
  {{yield fullName}}
{{else}}
  {{fullName}}
{{/if}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Then these two usages would be valid:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{! app/index/template.hbs }}

Full name: {{show-full-name firstName=firstName lastName=lastName}}

{{#show-full-name firstName=firstName lastName=lastName as |fullName|}}
  Full name: {{fullName}}
{{/show-full-name}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Additionally, &lt;code&gt;hasBlockParams&lt;/code&gt; will be true if the component is invoked
with block params (invoke in block form with &lt;code&gt;as |someParam|&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/_mmun"&gt;@mmun&lt;/a&gt; and &lt;a href="https://twitter.com/rwjblue"&gt;@rwjblue&lt;/a&gt;
for implementing this feature.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_notable-deprecations-in-1-13'&gt;Notable Deprecations in 1.13&lt;/h4&gt;
&lt;p&gt;In preparation for Ember 2.0, 1.13 introduces many deprecations. These include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All view APIs in Ember. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-view"&gt;See deprecation guide&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.CoreView&lt;/code&gt;, &lt;code&gt;Ember.View&lt;/code&gt;, &lt;code&gt;Ember.CollectionView&lt;/code&gt;, &lt;code&gt;Ember.ContainerView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{view &amp;#39;some-helper&amp;#39;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view}}&lt;/code&gt; keyword for accessing properties on a view&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Select&lt;/code&gt; and &lt;code&gt;{{view &amp;quot;select&amp;quot;}}&lt;/code&gt;. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-select"&gt;See deprecation guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.LinkView&lt;/code&gt; in favor of &lt;code&gt;Ember.LinkComponent&lt;/code&gt;. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-linkview"&gt;See deprecation guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Options to the &lt;code&gt;{{#each&lt;/code&gt; helper that trigger a legacy and poorly performing
legacy layer. These options are: &lt;code&gt;itemView&lt;/code&gt;, &lt;code&gt;itemViewClass&lt;/code&gt;, &lt;code&gt;tagName&lt;/code&gt;, &lt;code&gt;emptyView&lt;/code&gt; and &lt;code&gt;emptyViewClass&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;itemController&lt;/code&gt; argument for &lt;code&gt;{{#each&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;bind-attr&lt;/code&gt; helper. Using helpers and HTMLBars-style attribute binding
is preferred.&lt;/li&gt;
&lt;li&gt;Reading &lt;code&gt;this.get(&amp;#39;template&amp;#39;)&lt;/code&gt; to check for a yielded block on components.
Instead, use the &lt;code&gt;hasBlock&lt;/code&gt; API.&lt;/li&gt;
&lt;li&gt;Non-block param &lt;code&gt;{{with&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;view&lt;/code&gt; and &lt;code&gt;viewClass&lt;/code&gt; params for &lt;code&gt;{{outlet}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.reduceComputed&lt;/code&gt; and &lt;code&gt;Ember.arrayComputed&lt;/code&gt; in favor of plain normal
array manipulations. &lt;a href="http://emberjs.com/deprecations/v1.x/#toc_ember-reducecomputed-ember-arraycomputed"&gt;See deprecation guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class='anchorable-toc' id='toc_ember-2-0-beta'&gt;Ember 2.0 beta&lt;/h2&gt;
&lt;p&gt;Last November, @wycats and @tomdale published &lt;a href="https://github.com/emberjs/rfcs/pull/15"&gt;The Road to Ember 2.0&lt;/a&gt;,
an RFC summarizing Ember&amp;#39;s goals for a 2.0 release. At EmberConf, when some of
these changes were already complete and others not begun, they announced
our intent to ship 2.0 beta on June 12th.&lt;/p&gt;

&lt;p&gt;Together, the features summarized in the 2.0 RFC describe a new way to
author Ember applications. Model-View-Controller is replaced by
Model-Route-Component-Service. Two-way bindings are replaced by data down,
actions up (DDAU).&lt;/p&gt;

&lt;p&gt;Ember 2.0 will not introduce the entirety of our improved development model.
However it will take significant steps in that direction, and allow the
removal of public APIs that have been difficult to maintain while we
iterate forward.&lt;/p&gt;

&lt;p&gt;Because of the focus on landing migration paths for 1.x codebases in 1.13,
2.0 will have few new features. Among them are:&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_each-in-helper'&gt;each-in helper&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;each-in&lt;/code&gt; helper allows the iteration of object properties. For example,
given this value for &lt;code&gt;items&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;let items = {
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1234&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 2&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;3456&lt;/span&gt;
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following template will iterate the keys:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{#each-in items as |key value|}}
  &amp;lt;p&amp;gt;{{key}}: {{value}}&amp;lt;/p&amp;gt;
{{/each-in}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that this helper is unbound. Adding a new property to &lt;code&gt;items&lt;/code&gt; will not
cause a rerender, but &lt;code&gt;.set(&amp;#39;items&amp;#39;, val)&lt;/code&gt; will.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href="http://twitter.com/tomdale"&gt;@tomdale&lt;/a&gt; and implementing this
feature, and to several others for helping push it to completion.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_get-helper'&gt;get helper&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; helper provides a bound way to fetch a single property from an object.
For example given these items:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;let items = {
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 1&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;1234&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Item 2&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="integer"&gt;3456&lt;/span&gt;
};
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following template display &lt;code&gt;1234&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{get items 'Item 1'}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This becomes more powerful when the second argument is a bound path:&lt;/p&gt;
&lt;div class="highlight hbs "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{{get items somePathWithAKey}}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Thanks to &lt;a href="https://twitter.com/jmurphyau"&gt;@jmurphyau&lt;/a&gt; for implementing this feature.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_notable-breaking-changes-in-ember-2-0'&gt;Notable Breaking Changes in Ember 2.0&lt;/h4&gt;
&lt;p&gt;Ember 2.0 will remove a number of public APIs, all of which should have been
deprecated in the 1.13 release and have a viable migration path. The Ember
&lt;a href="http://emberjs.com/deprecations/v1.x/"&gt;Deprecation Guide&lt;/a&gt; should provide a
clear migration path for commonly used APIs.&lt;/p&gt;

&lt;p&gt;During the 2.0 beta cycle we will be removing and disabling already
deprecated APIs. Much of this work has not yet started, but the following
represents what we believe the breaking changes will be.&lt;/p&gt;

&lt;p&gt;Many controller APIs are removed in Ember 2.0. Routeable controllers still
exist, but all other uses have been deprecated. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{render &amp;quot;some-controller&amp;quot;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{each item itemController=&amp;quot;some-controller&amp;quot;}}&lt;/code&gt; - This usage can be replaced
by nesting a component inside the item, and by using helpers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.ObjectController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.ArrayController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{controller}}&lt;/code&gt; keyword&lt;/li&gt;
&lt;li&gt;&lt;code&gt;needs:&lt;/code&gt; on controllers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All view APIs are removed in Ember 2.0. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.CoreView&lt;/code&gt;, &lt;code&gt;Ember.View&lt;/code&gt;, &lt;code&gt;Ember.ContainerView&lt;/code&gt; and &lt;code&gt;Ember.CollectionView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember._Metamorph&lt;/code&gt;, &lt;code&gt;Ember._MetamorphView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view &amp;quot;some-view&amp;quot;}}&lt;/code&gt; helper&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{view}}&lt;/code&gt; keyword&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{each itemView=&lt;/code&gt;, &lt;code&gt;{{each itemViewClass=&lt;/code&gt;, &lt;code&gt;{{each tagName=&lt;/code&gt;, &lt;code&gt;{{each emptyView=&lt;/code&gt;, &lt;code&gt;{{each emptyViewClass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Select&lt;/code&gt; and &lt;code&gt;{{view &amp;quot;select&amp;quot;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Checkbox&lt;/code&gt; is not removed, but will become a component instead of a view&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The most commonly used parts of the &lt;code&gt;view&lt;/code&gt; API will be supported into the forseeable future via a core-supported addon.&lt;/p&gt;

&lt;p&gt;All Handlebars APIs are removed in Ember 2.0. This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;, &lt;code&gt;Ember.Handlebars.makeBoundHelper&lt;/code&gt; and &lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Handlebars.compile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Several template helpers are removed in Ember 2.0. These include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{bindAttr}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{bind-attr}}&lt;/code&gt; (use HTMLBars-style attribute bindings instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{bind}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{template}}&lt;/code&gt; (use &lt;code&gt;{{partial}}&lt;/code&gt; instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{linkTo}}&lt;/code&gt; (use &lt;code&gt;{{link-to}}&lt;/code&gt; instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{collection items}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Non-block params versions of &lt;code&gt;{{#each}}&lt;/code&gt; and &lt;code&gt;{{#with}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Legacy arguments to &lt;code&gt;{{#each}}&lt;/code&gt;, &lt;code&gt;{{outlet}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following routing APIs are removed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#hash&lt;/code&gt; paths with no forward leading slash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other APIs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ember.tryFinally&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.tryCatchFinally&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.required&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Map#remove&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.computed.defaultTo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.DeferredMixin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Deferred&lt;/code&gt; (use &lt;code&gt;Ember.RSVP.Promise&lt;/code&gt; instead)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.reduceComputed&lt;/code&gt; and &lt;code&gt;Ember.arrayComputed&lt;/code&gt; (use plain array manipulation)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Freezable&lt;/code&gt; (use Object.freeze instead)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, IE8 is no longer supported in Ember 2.x. IE9+ is supported.&lt;/p&gt;

&lt;p&gt;Many of these deprecated APIs will be moved into core-supported addons, or have already been moved.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_changelogs'&gt;Changelogs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.13.0/CHANGELOG.md"&gt;Ember.js 1.13.0 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v2.0.0-beta.1/CHANGELOG.md"&gt;Ember.js 2.0.0-beta.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.19.1 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/09/ember-data-1-0-beta-19-1-released.html"/>
    <id>http://emberjs.com/blog/2015/06/09/ember-data-1-0-beta-19-1-released.html</id>
    <published>2015-06-08T20:00:00-04:00</published>
    <updated>2015-06-08T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember Data 19.1 contains fixes for a few regressions. Thanks to everyone
who reported issues. Thanks to @bmac and @wecc for fixing!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fix a regression where a &lt;code&gt;DS.Model&lt;/code&gt;'s &lt;code&gt;InternalModel&lt;/code&gt; would not be set
on init - @bmac &lt;a href="https://github.com/emberjs/data/pull/3262"&gt;Pull Request&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;Pass store to inverseFor...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;Ember Data 19.1 contains fixes for a few regressions. Thanks to everyone
who reported issues. Thanks to @bmac and @wecc for fixing!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fix a regression where a &lt;code&gt;DS.Model&lt;/code&gt;&amp;#39;s &lt;code&gt;InternalModel&lt;/code&gt; would not be set
on init - @bmac &lt;a href="https://github.com/emberjs/data/pull/3262"&gt;Pull Request&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pass store to inverseFor in removeEmbeddedForeignKey #3270 - @wecc
&lt;a href="https://github.com/emberjs/data/pull/3270"&gt;Pull Request&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.19 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/06/05/ember-data-1-0-beta-19-released.html"/>
    <id>http://emberjs.com/blog/2015/06/05/ember-data-1-0-beta-19-released.html</id>
    <published>2015-06-04T20:00:00-04:00</published>
    <updated>2015-06-04T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember Data 1.0.0-beta.19 contains a lot of bugfixes from the comunity!
Thank you for helping us push toward a stable release of Ember Data!&lt;/p&gt;
&lt;h2 class="anchorable-toc" id="toc_new-features"&gt;New Features&lt;/h2&gt;&lt;h3 class="anchorable-toc" id="toc_snapshots-have-changedattributes"&gt;Snapshots have changedAttributes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;changedAttributes&lt;/code&gt;, which represents the changes that have happened...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Ember Data 1.0.0-beta.19 contains a lot of bugfixes from the comunity!
Thank you for helping us push toward a stable release of Ember Data!&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-features'&gt;New Features&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_snapshots-have-changedattributes'&gt;Snapshots have changedAttributes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;changedAttributes&lt;/code&gt;, which represents the changes that have happened
since the model was last synced with the server, are now available on
the snapshot in your adapters and serializers, instead of just on
&lt;code&gt;DS.Model&lt;/code&gt; instances.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_breaking-changes'&gt;Breaking Changes&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_passing-classes-to-store-methods'&gt;Passing Classes to Store Methods&lt;/h3&gt;
&lt;p&gt;Previously, you were allowed to pass a classes directly to store methods
like &lt;code&gt;store.push&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; record = store.push(App.Post, {&lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While this isn&amp;#39;t a very popular way and generally not recommended in the
documentation, it did remain the preferred way to do things in Ember
Data&amp;#39;s tests for a long time. As we move toward to using Ember&amp;#39;s
Dependency Injection framework for consistency, passing these classes
directly to store methods has been removed. Instead, you should pass a
dasherized string:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; record = store.push(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, {&lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To help you upgrade through this change easily, we&amp;#39;ve written an &lt;a href="https://github.com/abuiles/ember-watson#ember-watsonconvert-ember-data-model-lookups"&gt;Ember
Watson command&lt;/a&gt;.
You can use this command-line tool in both Ember-CLI projects and
&amp;quot;globals mode&amp;quot; style projects.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_services-depending-on-the-store'&gt;Services depending on the store&lt;/h3&gt;
&lt;p&gt;In order to fix deprecations warning induced by Ember 1.12, the store service is now injected as an
&lt;a href="http://emberjs.com/blog/2015/05/13/ember-1-12-released.html#toc_instance-initializers"&gt;instanceInitializer&lt;/a&gt;.
As a consequence, if you had initializers depending on the store, you should move&lt;br&gt;
them to an instance initializer as well, and mark it as &lt;code&gt;after: &amp;#39;ember-data&amp;#39;&lt;/code&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_important-deprecations'&gt;Important Deprecations&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_fixture-adapter-removed'&gt;Fixture Adapter Removed&lt;/h3&gt;
&lt;p&gt;Support for the Fixture Adapter has been deprecated. After some thought,
the Ember Data team decided it was not the right approach for
integration-style tests. We recommend using an AJAX/data transport
stubbing strategy like &lt;a href="https://github.com/trek/pretender"&gt;Pretender&lt;/a&gt; or
&lt;a href="http://sinonjs.org/"&gt;sinon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll be including docs on integration test strategies using Pretender in the
final release.&lt;/p&gt;

&lt;p&gt;The Fixture Adapter now lives as an &lt;a href="https://github.com/emberjs/ember-data-fixture-adapter"&gt;addon&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_internet-explorer-8'&gt;Internet Explorer 8&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;This will be the last release to support Internet
Explorer 8. Future versions of Ember Data will not support Internet
Explorer 8&lt;/s&gt;&lt;/p&gt;

&lt;p&gt;Update:
&lt;a href="/blog/2015/06/18/ember-data-1-13-released.html"&gt;Ember Data 1.13&lt;/a&gt; has
been released with support for IE8. Ember Data 1.13 is the last
version of Ember Data that supports IE8. Ember Data 2.0 supports IE9+.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Another Ember 2.x Status Update</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/05/24/another-two-oh-status-update.html"/>
    <id>http://emberjs.com/blog/2015/05/24/another-two-oh-status-update.html</id>
    <published>2015-05-23T20:00:00-04:00</published>
    <updated>2015-05-23T20:00:00-04:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We're just a few weeks away from the release of Ember 1.13 and Ember 2.0 beta, and while there's been a lot of focus on those releases, the trains will keep rolling on June 12. There will be a 2.1 release 6 weeks hence, and a 2.2 release 6 weeks later...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We&amp;#39;re just a few weeks away from the release of Ember 1.13 and Ember 2.0 beta, and while there&amp;#39;s been a lot of focus on those releases, the trains will keep rolling on June 12. There will be a 2.1 release 6 weeks hence, and a 2.2 release 6 weeks later.&lt;/p&gt;

&lt;p&gt;With all of the focus on Ember 2.0, it&amp;#39;s easy to forget that 2.0 is just a six-week release, with the added ability to remove some built-up cruft. Because of the symbolic nature of 2.0, discussions about the future have had an artificial end date of June 12, which is now just three weeks away.&lt;/p&gt;

&lt;p&gt;This post gives some more details about what cruft will be removed in Ember 2.0, but, since the first features in Ember 2.1 will land in Canary just three weeks hence, what we plan to do in the early releases of Ember 2.x.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s important to note that we&amp;#39;ve talked a lot about an improved &amp;quot;Ember 2 programming model&amp;quot; over the past several months, significantly inspired by React. While much of the model will be in place in Ember 2.0, the early releases of Ember 2.x (especially 2.1 and 2.2), will finish up some important features. This blog post details the expected timeline.&lt;/p&gt;

&lt;p&gt;Of course, the six-week release cycle means that we ship on a train cycle, so the precise versions of specific features may change before they land in a final release.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_removals'&gt;Removals&lt;/h2&gt;
&lt;p&gt;While we&amp;#39;ve spent a lot of time talking about the new features that Ember is getting over the next few months, the 2.0 release itself is more about removals and de-cruft-ification.&lt;/p&gt;

&lt;p&gt;Some notable examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Context-shifting helpers (&lt;code&gt;#with item&lt;/code&gt; becomes &lt;code&gt;#with item as |i|&lt;/code&gt;,
&lt;code&gt;#each list&lt;/code&gt; becomes &lt;code&gt;#each list as |item|&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Fake block params versions of helpers (&lt;code&gt;#with foo as bar&lt;/code&gt; becomes
&lt;code&gt;#with foo as |bar|&lt;/code&gt;, &lt;code&gt;#each item in list&lt;/code&gt; becomes
&lt;code&gt;#each list as |item|&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ArrayPolyfills&lt;/code&gt; and &lt;code&gt;EnumerableUtils&lt;/code&gt; libraries are being
pulled out into a library; most apps should prefer lodash or other
utility libs.&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;#each&lt;/code&gt;, the options &lt;code&gt;itemController&lt;/code&gt;, &lt;code&gt;itemViewClass&lt;/code&gt;,
&lt;code&gt;itemView&lt;/code&gt;; superseded by using a component inside the loop&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;#with&lt;/code&gt;, the &lt;code&gt;controller&lt;/code&gt; option&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Ember.Handlebars&lt;/code&gt; namespace and all of its properties&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind-attr&lt;/code&gt;, superseded by just using attributes&lt;/li&gt;
&lt;li&gt;The legacy names &lt;code&gt;bindAttr&lt;/code&gt; and &lt;code&gt;linkTo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{collection}}&lt;/code&gt; helper&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{template}}&lt;/code&gt; helper; superseded by &lt;code&gt;{{partial}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;{{render}}&lt;/code&gt; helper; superseded in most cases by components&lt;/li&gt;
&lt;li&gt;Manually rendering a string into the buffer in a view&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ember.Deferred&lt;/code&gt;; superseded by normal promises&lt;/li&gt;
&lt;li&gt;The globals resolver, which will be moved into an external library;
superseded in normal use by the ES6 module resolver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While top-level controllers will not be removed in 2.0 (see more below), we will remove all of the other uses of controllers from templates (such as &lt;code&gt;#with controller=&lt;/code&gt;, &lt;code&gt;{{render}}&lt;/code&gt;, &lt;code&gt;itemController&lt;/code&gt; and others).&lt;/p&gt;

&lt;p&gt;In all of these cases, we did significant work in the 1.x series, especially in 1.12 and 1.13, to make sure that the dominant use-cases for these features were addressed by existing or new features.&lt;/p&gt;

&lt;p&gt;You can learn about all of the deprecations added in the 1.x era, along with the expected transition to the features that superseded them, in the &lt;a href="http://emberjs.com/deprecations/v1.x/"&gt;1.x deprecations guide&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_the-glimmer-engine'&gt;The Glimmer Engine&lt;/h2&gt;
&lt;p&gt;The Glimmer engine, with its improved performance and improved support for the &amp;quot;data down, actions up&amp;quot; model, landed in Ember 1.13 beta.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_fast-re-render'&gt;Fast Re-Render&lt;/h2&gt;
&lt;p&gt;In Ember 1.12, calling rerender() on a component is an extremely expensive operation, and blows away all of the existing DOM (together with its internal state, such as selection, cursor, focus, scroll position and more).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In Ember 1.13&lt;/strong&gt;, thanks to the Glimmer engine, you can safely invoke rerender() and it will only update the parts of the template that have actually changed.&lt;/p&gt;

&lt;p&gt;This allows you to replace an entire data structure with a totally new POJO, rerender the component, and get highly performant updates that preserve the DOM.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_new-lifecycle-hooks'&gt;New Lifecycle Hooks&lt;/h2&gt;
&lt;p&gt;Because &lt;code&gt;rerender()&lt;/code&gt; is now fast and reliable, any call to &lt;code&gt;component.set()&lt;/code&gt; will trigger a re-render on the component. When a component re-renders, that may change the attributes of child components, which likewise are re-rendered.&lt;/p&gt;

&lt;p&gt;As a result of the fact that &lt;code&gt;rerender()&lt;/code&gt; is now such an important part of the programming model, &lt;strong&gt;Ember 1.13 beta&lt;/strong&gt; got a bunch of new React-inspired lifecycle hooks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didUpdateAttrs&lt;/code&gt;, invoked when a component&amp;#39;s attributes have changed
but before the component is rendered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willUpdate&lt;/code&gt;, invoked before a component will rerender, whether
the update was triggered by new attributes or by rerender.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didUpdate&lt;/code&gt;, invoked after a component has been rerendered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didReceiveAttrs&lt;/code&gt;, invoked when a component gets attributes, either
initially or due to an update.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willRender&lt;/code&gt;, invoked before a component will render, either
initially or due to an update, and regardless of how the rerender
was triggered.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRender&lt;/code&gt;, invoked after a component has been rendered, either
initially or due to an update.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These lifecycle hooks will fire on all components (but not views), regardless of invocation style (both curlies and angle bracket style).&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_angle-bracket-components'&gt;Angle Bracket Components&lt;/h2&gt;
&lt;p&gt;Angle bracket components (&lt;code&gt;&amp;lt;my-component&amp;gt;&lt;/code&gt;) are a very important part of the Ember 2.x programming model. In addition to nicer syntax, they serve as an opt-in for component changes that we could not easily make compatibly, such as default one-way bindings.&lt;/p&gt;

&lt;p&gt;We originally thought that angle-bracket components would land in time for Ember 1.13, and they have already landed on Canary, and were included in the first 1.13 beta release.&lt;/p&gt;

&lt;p&gt;However, there were some late-breaking concerns, and we have decided to defer this feature so we can write an RFC and go through the regular process. We have already written an implementation of the RFC, which we will land on Canary and keep up to date with the RFC discussions.&lt;/p&gt;

&lt;p&gt;Because we are so close to the Ember 2.0 branch point, &lt;strong&gt;this feature is likely to land in Ember 2.1.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_routeable-components'&gt;Routeable Components&lt;/h2&gt;
&lt;p&gt;The routeable components RFC was first published several months ago, and has been the subject of vigorous discussion. It is one of the most anticipated features of the Ember 2.x programming model.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;(the following two paragraphs are a bit of insider baseball)&lt;/p&gt;

&lt;p&gt;The primary reason to attempt to land this feature in Ember 2.0, despite the fact that its development is at a relatively early stage, was a desire to deprecate controllers for 2.0. In Ember, in order to deprecate a public API, we require an alternate path for all of the use-cases of the old feature. In order to remove a feature in 2.0, it would have needed to be deprecated in 1.13.&lt;/p&gt;

&lt;p&gt;Together, that means that in order to remove controllers in 2.0, we needed to land routeable components, the transition from controllers, in 1.13. During the 1.13 canary cycle, it became obvious that removing controllers in 2.0 would be too aggressive, so the pressure to ship Routeable Components exactly in 2.0.0 is less.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;The work on Routeable Components, as well as work to make it possible to move query parameters fully to routes, is ongoing.&lt;/p&gt;

&lt;p&gt;There are less than three weeks left until the 2.0-beta branch point, and given that the feature has not yet landed in Canary (and the importance and magnitude of the feature), it will probably land in 2.1 at the earliest.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It is extremely likely to land in 2.1, or 2.2 at the latest.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Routeable Component feature also includes a change that makes it possible to provide multiple asynchronous attributes to the component you are routing to, rather than just the &lt;code&gt;model&lt;/code&gt; attribute. The &lt;code&gt;attrs&lt;/code&gt; hook will run on every transition into the route, in contrast to the &lt;code&gt;model&lt;/code&gt; hook, which doesn&amp;#39;t run again in some cases.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_fastboot'&gt;FastBoot&lt;/h2&gt;
&lt;p&gt;An early version of the FastBoot feature, suitable for SEO, is already available as an Ember addon that works with Ember 1.12. We expect the addon to work with the final release of 1.13.&lt;/p&gt;

&lt;p&gt;Work on rehydrating FastBoot will begin very soon, and we hope to land it in Canary early in the 2.x release cycle.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_engines'&gt;Engines&lt;/h2&gt;
&lt;p&gt;The Engines feature was first proposed as an &lt;a href="https://github.com/tomdale/rfcs/blob/master/active/0000-engines.md"&gt;RFC&lt;/a&gt; last year, and work on the feature itself will likely begin very soon.&lt;/p&gt;

&lt;p&gt;We expect the Engines feature to land in Canary early in the 2.x release cycle.&lt;/p&gt;
</content>
  </entry>
</feed>
