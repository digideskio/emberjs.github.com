<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember Blog</title>
  <subtitle>Ember News and Updates</subtitle>
  <id>http://emberjs.com/blog</id>
  <link href="http://emberjs.com/blog"/>
  <link href="http://emberjs.com/blog/feed.xml" rel="self"/>
  <updated>2015-02-04T19:00:00-05:00</updated>
  <author>
    <name>Ember</name>
  </author>
  <entry>
    <title>Compiling templates with Ember 1.10</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/02/05/compiling-templates-in-1-10-0.html"/>
    <id>http://emberjs.com/blog/2015/02/05/compiling-templates-in-1-10-0.html</id>
    <published>2015-02-04T19:00:00-05:00</published>
    <updated>2015-02-04T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;As many of you know, Ember 1.10 will be the first version of Ember that uses &lt;a href="https://github.com/tildeio/htmlbars"&gt;HTMLBars&lt;/a&gt; as its templating engine. With this change you may need to change the way you compile your templates.&lt;/p&gt;

&lt;p&gt;The HTMLBars API is evolving and not 1.0.0 yet, so to ensure...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;As many of you know, Ember 1.10 will be the first version of Ember that uses &lt;a href="https://github.com/tildeio/htmlbars"&gt;HTMLBars&lt;/a&gt; as its templating engine. With this change you may need to change the way you compile your templates.&lt;/p&gt;

&lt;p&gt;The HTMLBars API is evolving and not 1.0.0 yet, so to ensure that templates are compiled compatibly with your Ember version we have updated the Ember build system to generate a &lt;code&gt;ember-template-compiler.js&lt;/code&gt; file alongside every build of Ember. This template compiler can be used server-side for precompilation or in the browser to compile templates on the fly. If you do not need to compile templates at runtime (in the browser) the &lt;code&gt;ember.debug.js&lt;/code&gt; or &lt;code&gt;ember.prod.js&lt;/code&gt; file alone is sufficient. There is no need to include a runtime dependency. This is a departure from previous versions, where you would always include either &lt;code&gt;handlebars.js&lt;/code&gt; or &lt;code&gt;handlebars.runtime.js&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most of the time you will use a third party library like &lt;a href="https://github.com/ember-cli/ember-cli"&gt;ember-cli&lt;/a&gt;, &lt;a href="https://github.com/rondale-sc/ember-cli-htmlbars"&gt;ember-cli-htmlbars&lt;/a&gt;, or &lt;a href="https://github.com/dgeb/grunt-ember-templates"&gt;grunt-ember-templates&lt;/a&gt; to precompile templates, but this post will discuss how libraries like this should work internally.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_server-side-compilation'&gt;Server Side Compilation&lt;/h3&gt;
&lt;p&gt;If possible, it is definitely a best practice to compile your templates server side. This is much faster due to less total size (you don&amp;#39;t need the compiler on the client) and less work that the app needs to do.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_ember-1-0-through-1-9'&gt;Ember 1.0 through 1.9&lt;/h4&gt;
&lt;p&gt;In prior versions, you would typically use the &lt;code&gt;ember-template-compiler&lt;/code&gt; NPM package that corresponded to your Ember version to precompile your templates. That might look something like the following:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; fs = require(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fs&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class="keyword"&gt;var&lt;/span&gt; compiler = require(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;ember-template-compiler&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class="keyword"&gt;var&lt;/span&gt; input = fs.readFileSync(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;path/to/template.hbs&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;encoding&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;utf8&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; });
&lt;span class="keyword"&gt;var&lt;/span&gt; template = compiler.precompile(input, &lt;span class="predefined-constant"&gt;false&lt;/span&gt;);
&lt;span class="keyword"&gt;var&lt;/span&gt; output = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;export default Ember.Handlebars.template(&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + template + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;);&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;

fs.writeFileSync(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;path/to/output.js&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, output, { &lt;span class="key"&gt;encoding&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;utf8&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You would also need to include &lt;code&gt;handlebars.runtime.js&lt;/code&gt; in your final build&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_ember-1-10'&gt;Ember 1.10+&lt;/h4&gt;
&lt;p&gt;With Ember 1.10, you will use the &lt;code&gt;ember-template-compiler.js&lt;/code&gt; file that is paired with your Ember version. If you use our &lt;a href="https://github.com/components/ember"&gt;Bower repo&lt;/a&gt;, &lt;a href="https://rubygems.org/gems/ember-source"&gt;RubyGem&lt;/a&gt;, or simply download Ember from our &lt;a href="http://emberjs.com/builds/"&gt;builds site&lt;/a&gt; there is a &lt;code&gt;ember-template-compiler.js&lt;/code&gt; in the same path as &lt;code&gt;ember.debug.js&lt;/code&gt; and &lt;code&gt;ember.prod.js&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can use this template compiler directly  and without additional requirements. For example:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; fs = require(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fs&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class="keyword"&gt;var&lt;/span&gt; compiler = require(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;./bower_components/ember/ember-template-compiler&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class="keyword"&gt;var&lt;/span&gt; input = fs.readFileSync(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;path/to/template.hbs&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;encoding&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;utf8&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; });
&lt;span class="keyword"&gt;var&lt;/span&gt; template = compiler.precompile(input, &lt;span class="predefined-constant"&gt;false&lt;/span&gt;);
&lt;span class="keyword"&gt;var&lt;/span&gt; output = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;export default Ember.HTMLBars.template(&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + template + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;);&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;

fs.writeFileSync(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;path/to/output.js&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, output, { &lt;span class="key"&gt;encoding&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;utf8&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As you will notice, the new API for server-side compilation is nearly identical to that of prior versions. The main change is the usage of the local &lt;code&gt;bower_components/ember/ember-template-compiler.js&lt;/code&gt; file as opposed to the NPM module.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_client-side-compilation'&gt;Client Side Compilation&lt;/h3&gt;
&lt;p&gt;Generally speaking, you should avoid compiling templates on the client, but there are times that you cannot avoid this. Live demo apps like &lt;a href="http://emberjs.jsbin.com"&gt;JSBin&lt;/a&gt; are one example.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-1-0-through-1-9'&gt;Ember 1.0 through 1.9&lt;/h3&gt;
&lt;p&gt;In prior versions of Ember you would need to ensure that the full version of &lt;a href="handlebarsjs.com"&gt;Handlebars.js&lt;/a&gt; was present to allow compiling of templates. Perhaps something like the following in your &lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight html "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;assets/handlebars.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;assets/ember.prod.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_ember-1-10'&gt;Ember 1.10+&lt;/h3&gt;
&lt;p&gt;With Ember 1.10, you will include the &lt;code&gt;ember-template-compiler.js&lt;/code&gt; for your specific Ember version.  Something like the following:&lt;/p&gt;
&lt;div class="highlight html "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;assets/ember-template-compiler.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="attribute-name"&gt;src&lt;/span&gt;=&lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;assets/ember.prod.js&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you include the &lt;code&gt;ember.debug.js&lt;/code&gt; file instead of a production file the compiler is still required.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_template-compilation-build-tools'&gt;Template Compilation Build Tools&lt;/h3&gt;
&lt;p&gt;There are any number of build tool libraries that are intended to make the server side compilation of templates easier. Here are just a few (please let us know of others):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/rondale-sc/ember-cli-htmlbars"&gt;ember-cli-htmlbars&lt;/a&gt; - Can be used either as a standalone Broccoli plugin, or as an ember-cli addon.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dgeb/grunt-ember-templates"&gt;grunt-ember-templates&lt;/a&gt; - Works as a Grunt plugin. To precompile HTMLBars templates, you must supply specific parameters to your task definition as mentioned in &lt;a href="https://github.com/dgeb/grunt-ember-templates/pull/77"&gt;this PR&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbashford/mimosa-ember-htmlbars"&gt;mimosa-ember-htmbars&lt;/a&gt; - A plugin for the &lt;a href="http://mimosa.io/"&gt;mimosa&lt;/a&gt; build tool.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember-rails"&gt;ember-rails&lt;/a&gt; - The Rails Asset Pipeline plugin supports HTMLBars templates.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Inside FastBoot: Faking the DOM in Node</title>
    <link rel="alternate" href="http://emberjs.com/blog/2015/01/08/inside-fastboot-faking-the-dom-in-node.html"/>
    <id>http://emberjs.com/blog/2015/01/08/inside-fastboot-faking-the-dom-in-node.html</id>
    <published>2015-01-07T19:00:00-05:00</published>
    <updated>2015-01-07T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;As we &lt;a href="/blog/2014/12/22/inside-fastboot-the-road-to-server-side-rendering.html"&gt;announced in the inaugural blog post in our Inside FastBoot
series&lt;/a&gt;, we
have begun working on giving Ember.js developers the ability to run
their apps in Node.js. Once complete, this feature will allow your users
to see HTML and CSS right away...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;As we &lt;a href="/blog/2014/12/22/inside-fastboot-the-road-to-server-side-rendering.html"&gt;announced in the inaugural blog post in our Inside FastBoot
series&lt;/a&gt;, we
have begun working on giving Ember.js developers the ability to run
their apps in Node.js. Once complete, this feature will allow your users
to see HTML and CSS right away, with the JavaScript downloading
in the background and taking over once it has fully loaded.&lt;/p&gt;

&lt;p&gt;Before the holidays, we had already succeeded in getting the Ember.js
framework loading in Node.js (where it cannot rely on things like the
DOM) without throwing any exceptions. We also were able to get Ember
apps booting, parsing URLs, and completing most of the functionality
necessary to start the app, including loading controllers, routes and
models, etc.&lt;/p&gt;

&lt;p&gt;This week, we&amp;#39;ve made good progress on the next major piece of
functionality: allowing HTMLbars templates to render in Node.js where,
again, there is no native DOM available.&lt;/p&gt;

&lt;p&gt;So how does HTMLbars, a DOM-based templating library, work in an
environment without a DOM?&lt;/p&gt;

&lt;p&gt;As it turns out, we can introduce a &amp;quot;virtual DOM&amp;quot; into the server-side
environment, implemented in pure JavaScript. That&amp;#39;s exactly what we&amp;#39;ve
done, thanks to the work of Kris Selden and his &lt;a href="https://github.com/krisselden/simple-dom"&gt;simple-dom&lt;/a&gt;
library.&lt;/p&gt;

&lt;p&gt;Importantly, &lt;code&gt;simple-dom&lt;/code&gt; implements a very, very small subset of the WHATWG
DOM specification, optimized for performance, and for the requirements
of the Ember view layer. For example, it does not implement any part of
the DOM that would require the use of accessors; it&amp;#39;s just an attempt to
faithfully represent the DOM as a &lt;strong&gt;data structure&lt;/strong&gt;, not its complete
API surface. (If you need the whole enchilada, check out something like
&lt;a href="https://github.com/tmpvar/jsdom"&gt;jsdom&lt;/a&gt;, which is much more complete.)&lt;/p&gt;

&lt;p&gt;While working on FastBoot, we have created a series of integration tests
we run in Node.js that verify everything is working correctly. In those
tests, we swap out the code that accesses the DOM (encapsulated inside
an object we call a &lt;code&gt;DOMHelper&lt;/code&gt;) with a version that uses a &lt;code&gt;Document&lt;/code&gt;
provided by &lt;code&gt;simple-dom&lt;/code&gt; rather than relying on the global &lt;code&gt;document&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This week, with our implementation of &amp;quot;the little DOM that could,&amp;quot; we were
able to get more and more sophisticated templates rendering to a string.&lt;/p&gt;

&lt;p&gt;First, we started with just a simple template that printed a string:
&lt;code&gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then we moved on to bound expressions, so &lt;code&gt;&amp;lt;h1&amp;gt;Hello {{location}}&amp;lt;/h1&amp;gt;&lt;/code&gt;
became &lt;code&gt;&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Yesterday, we got &lt;code&gt;{{#if}}&lt;/code&gt; helpers and nested components working as
well.  (Other helpers likely work, we just have not written tests for
them yet.)&lt;/p&gt;

&lt;p&gt;Now that we have bare-bones rendering in place, we are theoretically
able to start booting Ember apps in Node.js, connecting their router
with a server-side routing library like Express, and serving up requests
as they come in.&lt;/p&gt;

&lt;p&gt;Next week, we&amp;#39;ll begin working on giving Ember CLI the ability to
compile Ember apps to be consumed by Node.js. Once that&amp;#39;s in place, our
plan is to start updating all of the tests in Ember&amp;#39;s test suite that
flex the templating and view layers, ensuring that they pass in a
DOM-less environment.&lt;/p&gt;

&lt;p&gt;Our goal is to have something alpha quality but useable as soon as
possible, so those with simpler apps can start taking advantage and
helping us test right away. As people run into incompatibilities in the
real world, we can incorporate fixes into the codebase and our test
suite and rapidly increase the number of compatible apps.&lt;/p&gt;

&lt;p&gt;If you&amp;#39;re interested in following along at home, you may want to star
these repos on GitHub to watch our progress:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js"&gt;https://github.com/emberjs/ember.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/krisselden/simple-dom"&gt;https://github.com/krisselden/simple-dom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tildeio/htmlbars"&gt;https://github.com/tildeio/htmlbars&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;#39;ll have more for you in future posts in the Inside FastBoot series,
cataloging implementation challenges and successes, so stay tuned for
more.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.14.1 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2014/12/31/ember-data-1-0-beta-14-1-released.html"/>
    <id>http://emberjs.com/blog/2014/12/31/ember-data-1-0-beta-14-1-released.html</id>
    <published>2014-12-30T19:00:00-05:00</published>
    <updated>2014-12-30T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember Data v1.0.0-beta.14.1 is a bugfix release that adds sourcemaps
to your build pipeline in Ember CLI and Rails. Additionally support
for versions of Ember &amp;lt;= 1.7.1 have been removed. This was mentioned
in the &lt;a href="http://emberjs.com/blog/2014/12/25/ember-data-1-0-beta-14-released.html"&gt;beta.12 blogpost&lt;/a&gt;, and is now enforced...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Ember Data v1.0.0-beta.14.1 is a bugfix release that adds sourcemaps
to your build pipeline in Ember CLI and Rails. Additionally support
for versions of Ember &amp;lt;= 1.7.1 have been removed. This was mentioned
in the &lt;a href="http://emberjs.com/blog/2014/12/25/ember-data-1-0-beta-14-released.html"&gt;beta.12 blogpost&lt;/a&gt;, and is now enforced via an assertion
in the code and by your package manager files.&lt;/p&gt;

&lt;!-- Links --&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data v1.0.0-beta.14 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2014/12/25/ember-data-1-0-beta-14-released.html"/>
    <id>http://emberjs.com/blog/2014/12/25/ember-data-1-0-beta-14-released.html</id>
    <published>2014-12-24T19:00:00-05:00</published>
    <updated>2014-12-24T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Due to a hiccup during the publishing step while releasing beta.13,
we've removed beta.13 from npm and instead published beta.14. This
release is available to you whether you are using npm and ember-cli,
rubygems, or bower. Of course, the builds are...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Due to a hiccup during the publishing step while releasing beta.13,
we&amp;#39;ve removed beta.13 from npm and instead published beta.14. This
release is available to you whether you are using npm and ember-cli,
rubygems, or bower. Of course, the builds are always available as static
files at &lt;a href="http://emberjs.com/builds"&gt;emberjs.com/builds&lt;/a&gt;.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_improvements'&gt;Improvements&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/terzicigor"&gt;Igor Terzic&lt;/a&gt;, &lt;a href="https://twitter.com/hjdivad"&gt;David Hamilton&lt;/a&gt;, and &lt;a href="https://twitter.com/stefanpenner"&gt;Stefan
Penner&lt;/a&gt; put in some great strides to improve performance around
how relationships work together in Ember Data. These performance changes
have wide-reaching effects into everything you do in Ember Data:
querying records, pushing records into the store, and creating records.
Since everyone on the Ember Data team works on real apps, we tested
these changes in our applications and saw improvements averaging 50% or
higher around pushing and creating records into the store.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_breaking-changes'&gt;Breaking Changes&lt;/h2&gt;&lt;h3 class='anchorable-toc' id='toc_code-store-update-code-has-been-deprecated'&gt;&lt;code&gt;store.update()&lt;/code&gt; has been deprecated&lt;/h3&gt;
&lt;p&gt;Calling &lt;code&gt;store.update()&lt;/code&gt; has been deprecated in favor of &lt;code&gt;store.push()&lt;/code&gt;
now
handling partial payloads:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="keyword"&gt;var&lt;/span&gt; post = store.push(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, {
  &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;,
  &lt;span class="key"&gt;title&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Ember.js is fantastic&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;author&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Tomster&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
});

post.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;title&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 'Ember.js is fantastic'&lt;/span&gt;
post.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;author&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 'Tomster'&lt;/span&gt;

store.push(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;post&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, { &lt;span class="key"&gt;id&lt;/span&gt;: &lt;span class="integer"&gt;1&lt;/span&gt;, &lt;span class="key"&gt;author&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;Tom Dale&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; });

post.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;title&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 'Ember.js is fantastic'&lt;/span&gt;
post.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;author&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 'Tom Dale'&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This also means that properties missing in the payload will no longer be
reset,
but stay the same.&lt;/p&gt;

&lt;p&gt;If you need to reset values to null, you should have your server
explicitly
send back null values in the payload:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;person&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: {
    &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="predefined-constant"&gt;null&lt;/span&gt;,
    &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="predefined-constant"&gt;null&lt;/span&gt;
    &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;role&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Computer Science Pioneer&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you cannot change your API and you desire this behavior, you can
create a
serializer and do the logic yourself:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/serializers/person.js&lt;/span&gt;
&lt;span class="comment"&gt;// or App.PersonSerializer if you aren't using Ember CLI&lt;/span&gt;
&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; DS.RESTSerializer.extend({
  &lt;span class="function"&gt;normalize&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(type, hash, prop) {
    hash = &lt;span class="local-variable"&gt;this&lt;/span&gt;._super(type, hash, prop);
    &lt;span class="keyword"&gt;if&lt;/span&gt; (!hash.hasOwnProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)){
      hash.firstName = &lt;span class="predefined-constant"&gt;null&lt;/span&gt;;
    }
    &lt;span class="keyword"&gt;if&lt;/span&gt; (!hash.hasOwnProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)){
      hash.lastName = &lt;span class="predefined-constant"&gt;null&lt;/span&gt;;
    }
    &lt;span class="keyword"&gt;return&lt;/span&gt; hash;
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Or if you want to restore the old behavior for all of your models:&lt;/p&gt;
&lt;div class="highlight javascript "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// app/serializers/application.js&lt;/span&gt;
&lt;span class="comment"&gt;// or App.ApplicationSerializer&lt;/span&gt;
&lt;span class="reserved"&gt;export&lt;/span&gt; &lt;span class="keyword"&gt;default&lt;/span&gt; DS.RESTSerializer.extend({
  &lt;span class="function"&gt;normalize&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;(type, hash, prop) {
    hash = &lt;span class="local-variable"&gt;this&lt;/span&gt;._super(type, hash, prop);
    type.eachAttribute(&lt;span class="keyword"&gt;function&lt;/span&gt;(key) {
      &lt;span class="keyword"&gt;if&lt;/span&gt; (!hash.hasOwnProperty(key)) {
        hash[key] = &lt;span class="predefined-constant"&gt;null&lt;/span&gt;;
      }
    }, &lt;span class="local-variable"&gt;this&lt;/span&gt;);
    &lt;span class="keyword"&gt;return&lt;/span&gt; hash;
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h2 class='anchorable-toc' id='toc_special-thanks'&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;A special thanks to &lt;a href="http://dockyard.com"&gt;Dockyard&lt;/a&gt; for sponsoring Igor during the
month of December!&lt;/p&gt;

&lt;!-- Links --&gt;
</content>
  </entry>
  <entry>
    <title>Ember.js 1.9.1 Released</title>
    <link rel="alternate" href="http://emberjs.com/blog/2014/12/23/ember-1-9-1-released.html"/>
    <id>http://emberjs.com/blog/2014/12/23/ember-1-9-1-released.html</id>
    <published>2014-12-22T19:00:00-05:00</published>
    <updated>2014-12-22T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Today, the Ember team is pleased to announce the release of Ember.js
1.9.1. Ember 1.9.1 fixes one regression and introduces more conservative
escaping of attributes to help developers guard against inadvertent cross-site
scripting (XSS) vulnerabilities...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Today, the Ember team is pleased to announce the release of Ember.js
1.9.1. Ember 1.9.1 fixes one regression and introduces more conservative
escaping of attributes to help developers guard against inadvertent cross-site
scripting (XSS) vulnerabilities.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_view-helper-instances'&gt;{{view}} Helper &amp;amp; Instances&lt;/h3&gt;
&lt;p&gt;The 1.9.0 release introduced a regression where the Handlebars
&lt;code&gt;{{view}}&lt;/code&gt; helper would only work with &lt;code&gt;Ember.View&lt;/code&gt; subclasses, not
instances. In 1.9.1, passing a view instance to the helper has been
fully restored.&lt;/p&gt;

&lt;p&gt;We intended to deprecate this functionality, not remove it entirely.
If your app was relying on this behavior, first, please accept our
apologies for the accidental regression. Second, please consider
refactoring your code to use components instead of views, as support for
this API will be removed in Ember 2.0.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_xss-improvements-for-bound-attributes'&gt;XSS Improvements for Bound Attributes&lt;/h3&gt;
&lt;p&gt;XSS vulnerabilities happen when you unintentionally put unescaped
user-supplied content into the DOM, creating a vector for attackers
to trick the browser into evaluating JavaScript that has the same access
to data as your legitimate JavaScript.&lt;/p&gt;

&lt;p&gt;Since its inception, Ember.js has automatically guarded against these
attacks by HTML-escaping any bound data that goes into the DOM. For
example, given this model data:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;&amp;lt;script type=javascript&amp;gt;alert('pwned!');&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following template would not be vulnerable to XSS:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Hello, &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;firstName&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;!
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;That&amp;#39;s because Ember automatically replaces the &amp;lt; and &amp;gt; characters
with &lt;code&gt;&amp;amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, there is still another potential exploit vector: bound attributes.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s say you display a profile for your users and allow them to supply
an arbitrary homepage that your app links to:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;{{!-- templates/user.hbs --}}&lt;/span&gt;
First Name: &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;firstName&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
Homepage: &lt;span class="tag"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;bind-attr&lt;/span&gt; &lt;span class="attribute-name"&gt;href&lt;/span&gt;=&lt;span class="attribute-value"&gt;homepageUrl&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;homepageUrl&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;While this template may look harmless at first glance, imagine a
malicious user provides the following data:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;{
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Guardians of Peace&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;homepageUrl&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;javascript:alert('Kim Jong Un is not to be
disrespected!')&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If the attacker can induce another user to click the profile link, you
will have inadvertently allowed their JavaScript to be evaluated in the
same origin as your trusted code.&lt;/p&gt;

&lt;p&gt;As of Ember 1.9.1, we will automatically escape any bound &lt;code&gt;href&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt;
or &lt;code&gt;background&lt;/code&gt; attributes that contain a &lt;code&gt;javascript:&lt;/code&gt; or &lt;code&gt;vbscript:&lt;/code&gt;
protocol handler by prefixing their value with &lt;code&gt;unsafe:&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We are also releasing a new beta version of Ember 1.10 that contains
even more targeted fixes. Thanks to the additional power the HTMLbars
parser gives us, these attributes will only be escaped on elements where
they trigger a top-level navigation and thus a potential exploit: &lt;code&gt;a&lt;/code&gt;,
&lt;code&gt;body&lt;/code&gt;, &lt;code&gt;link&lt;/code&gt;, &lt;code&gt;iframe&lt;/code&gt;, and &lt;code&gt;img&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#39;d like to thank Mano and Manoharan from Zoho for responsibly disclosing
this potential XSS vector and working with us to find a solution that makes
it as easy as possible for developers to write secure apps.&lt;/p&gt;
&lt;h2 class='anchorable-toc' id='toc_changelogs'&gt;Changelogs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.9.1/CHANGELOG.md"&gt;Ember.js 1.9.1 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emberjs/ember.js/blob/v1.10.0-beta.2/CHANGELOG.md"&gt;Ember.js 1.10.0-beta.2 CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Inside FastBoot: The Road to Server-Side Rendering</title>
    <link rel="alternate" href="http://emberjs.com/blog/2014/12/22/inside-fastboot-the-road-to-server-side-rendering.html"/>
    <id>http://emberjs.com/blog/2014/12/22/inside-fastboot-the-road-to-server-side-rendering.html</id>
    <published>2014-12-21T19:00:00-05:00</published>
    <updated>2014-12-21T19:00:00-05:00</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Using JavaScript to write fast, interactive web applications has exploded in popularity over the past few years. JavaScript apps offer many strengths over traditional server-rendered applications. Most notably, rich interactions and lightning-fast...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Using JavaScript to write fast, interactive web applications has exploded in popularity over the past few years. JavaScript apps offer many strengths over traditional server-rendered applications. Most notably, rich interactions and lightning-fast responses to user clicks allow for UIs that previously were only the domain of native apps.&lt;/p&gt;

&lt;p&gt;The first JavaScript-heavy applications were productivity apps, and the experience of loading an app on the web, even with a spinner, was far better than the equivalent experience of downloading and installing a native app.&lt;/p&gt;

&lt;p&gt;Increasingly, though, content-rich destinations such as news or video sites are starting to move to JavaScript to gain the benefits of improved interactivity. Unlike productivity apps, where the user logs in once at the beginning of the day and stays logged in, content sites are loaded many times per day, often via search engines or social sharing.&lt;/p&gt;

&lt;p&gt;In this context, where the JavaScript app looks like a &amp;quot;normal&amp;quot; web page, loading spinners or long delays feel out-of-place and not very web-like. Indeed, this is the reason that &lt;a href="https://blog.twitter.com/2012/improving-performance-on-twittercom"&gt;Twitter migrated from a client-side JavaScript approach back to server-rendered content&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Being able to boot JavaScript apps on the server and &amp;quot;rehydrate&amp;quot; in the browser has been considered a Holy Grail for some time. However, most  attempts have focused solely on rendering the view layer on the server into HTML. This is an important step, but this alone does not sufficiently solve the problem.&lt;/p&gt;

&lt;p&gt;Solving the whole problem involves not just the view layer, but the entire lifecycle of booting an application: routing, fetching models, and rendering. By leaning heavily on Ember&amp;#39;s conventional application structure, we can move this complexity out of each application and into the framework.&lt;/p&gt;

&lt;p&gt;We are building this feature into Ember.js, &lt;strong&gt;and we&amp;#39;re calling it FastBoot&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;FastBoot will allow you to deliver the HTML and CSS for a page in your Ember app right away, then allow the JavaScript to take over once it has finished loading. Your Ember app will behave no differently than server-rendered apps when it comes to search engines, mobile users, cURL, or users with JavaScript disabled.&lt;/p&gt;

&lt;p&gt;For everyone else, you&amp;#39;ll still have the responsiveness and interactivity users have come to expect from Ember apps.&lt;/p&gt;

&lt;p&gt;Because of the Ember community&amp;#39;s strong focus on conventional app structure, we believe that we can make server rendering so simple to enable and deploy that, in the long run, very few Ember apps would choose not to use it.&lt;/p&gt;

&lt;p&gt;In this series of blog posts, we will demystify our efforts, and talk about implementation details. We will also give you a sense of our progress. Like every Ember feature, FastBoot will be landing a bit at a time, so every new release will unlock more capabilities. As features land, we will talk about how you can take advantage of them in your own apps.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Journey So Far&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;From the beginning, we knew that we would eventually want to tackle running JavaScript apps on the server, but we didn&amp;#39;t want to bet Ember on a boil-the-ocean effort to solve every aspect of client-side development at once.&lt;/p&gt;

&lt;p&gt;That being said, we have always kept this feature in mind as we were architecting the framework. We carefully isolated all parts of the system that depend on a full-fledged browser environment.&lt;/p&gt;

&lt;p&gt;Even during the most recent HTMLBars effort, which is inherently a DOM-based rendering engine, we made sure to use an &lt;a href="https://github.com/tildeio/htmlbars/blob/master/packages/morph/lib/dom-helper.js"&gt;abstraction&lt;/a&gt; whenever we touched the DOM, so that we could swap it out for something else on the server. Similarly, when we designed the router, all communication with the URL went through a &amp;quot;&lt;a href="https://github.com/emberjs/ember.js/blob/master/packages/ember-routing/lib/location/api.js"&gt;location&lt;/a&gt;&amp;quot; abstraction, instead of touching the URL bar directly. The routing microlibraries we built (&lt;a href="https://github.com/tildeio/router.js"&gt;router.js&lt;/a&gt; and &lt;a href="https://github.com/tildeio/route-recognizer"&gt;route-recognizer&lt;/a&gt;) were designed from the beginning to be decoupled from the DOM.&lt;/p&gt;

&lt;p&gt;Because of this, we were able to get the Ember framework executing in Node in just a day of work, and were able to get an app completely booted and routing in under a week.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstracting Feature Detection&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One of the first problems we encountered when trying to execute Ember in node was top-level feature detection. Because Ember previously assumed it was running inside a browser, it inadvertently relied on the existence of basic DOM APIs, like &lt;code&gt;window&lt;/code&gt;, the &lt;code&gt;document&lt;/code&gt; and &lt;code&gt;navigator&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While the vast majority of the subsequent code was resilient to environments without a DOM, the feature detection and helpful assertion messages (&amp;quot;you&amp;#39;re using an old version of jQuery&amp;quot;) was sloppy because it historically wasn&amp;#39;t expecting to run in Node.&lt;/p&gt;

&lt;p&gt;To address this issue, we moved all top-level assumptions into &lt;a href="https://github.com/emberjs/ember.js/blob/master/packages/ember-metal/lib/environment.js"&gt;an &lt;code&gt;environment&lt;/code&gt; abstraction&lt;/a&gt;. If you look at it, it&amp;#39;s really boring; it just lets top-level code throughout the framework quickly short-circuit if basic DOM facilities are missing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Container and Session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ember&amp;#39;s powerful dependency injection (&amp;quot;DI&amp;quot;) system has been a boon for managing application state, supporting the transition from globals to modules, and ensuring tests are fast and robust.&lt;/p&gt;

&lt;p&gt;Rather than storing application state globally (either in a global variable or as a property on a global object like &lt;code&gt;App&lt;/code&gt;), all state in an idiomatic Ember app is stored inside an object called the &amp;quot;container&amp;quot;. This makes it easy to throw away state between each automated test, ensuring you&amp;#39;re testing what you think you&amp;#39;re testing and not the side-effects of a previous test. It also improves the speed of tests, allowing you to run your test suite as you develop instead of waiting hours for a CI server.&lt;/p&gt;

&lt;p&gt;The container also serves as a registry of your application code, and its &amp;quot;resolver&amp;quot; paved the way for Ember to move from globals-based code to &lt;a href="http://jsmodules.io/"&gt;JavaScript modules&lt;/a&gt; by abstracting lookups (e.g. Ember asking for a controller named &amp;quot;users&amp;quot;) from the actual location of code.&lt;/p&gt;

&lt;p&gt;The good news is that this means that the internals of Ember always look up (and create) objects through the container. &lt;/p&gt;

&lt;p&gt;Unfortunately, we made a minor mistake in our original design. Currently, every application has only a single container. This assumption works fine when running your application in the browser, since you only load and run the application once per browser page load.&lt;/p&gt;

&lt;p&gt;This also works fine in tests, with the exception that we are doing more work than absolutely necessary between each test run. In essence, we conflated the &amp;quot;code registry&amp;quot; and &amp;quot;application state&amp;quot; responsibilities into the same container object. Between test runs, we throw away the container to reset application state, but by also throwing out the code registry, which doesn&amp;#39;t change between tests, we are throwing the baby out with the bath water.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/2014-12-22-inside-fastboot-the-road-to-server-side-rendering/old-school.png" alt="Architecture diagram showing state and code registry inside same Application object"&gt;&lt;/p&gt;

&lt;p&gt;When running on the server, however, we realized that a single Ember application needs to be able to continue serving requests even if a previous request is waiting for an async operation (such as fetching a model) to complete.&lt;/p&gt;

&lt;p&gt;This means that we needed to tweak our approach and allow applications to host multiple of what we call &amp;quot;sessions&amp;quot; at a time. Sessions allow us to separate the code registry (which doesn&amp;#39;t change once the app is booted) from the application state.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/2014-12-22-inside-fastboot-the-road-to-server-side-rendering/new-school.png" alt="Architecture diagram showing state extracted into Session objects"&gt;&lt;/p&gt;

&lt;p&gt;This approach also has a side-benefit for testing: it allows us to reduce the amount of work we need to do between each test.&lt;/p&gt;

&lt;p&gt;Both of these efforts (breaking out an environment and the design of the session) are incremental pieces that provide value on their own, and &lt;a href="https://github.com/emberjs/ember.js/pull/9981"&gt;have already landed on master&lt;/a&gt; thanks to the tireless work of &lt;a href="https://twitter.com/dgeb"&gt;Dan Gebhardt&lt;/a&gt;. Working with &lt;a href="https://www.linkedin.com"&gt;LinkedIn&lt;/a&gt; and &lt;a href="http://www.bustle.com"&gt;Bustle&lt;/a&gt; closely has helped us to work through the initial requirements, and identify steps that we could take that would help enterprising teams make progress while we take the next steps.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Next Steps&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In the coming weeks, we are going to dive head-first into HTMLbars, getting it ready for its new life running inside a Node.js environment. We&amp;#39;ll start by making sure that the &lt;a href="https://github.com/tildeio/htmlbars/blob/master/packages/morph/lib/dom-helper.js"&gt;&lt;code&gt;DOMHelper&lt;/code&gt;&lt;/a&gt; abstraction is used everywhere that interacts with the DOM, providing us a chokepoint to implement a fake DOM on the server that builds up strings of HTML instead of interacting with a real DOM.&lt;/p&gt;

&lt;p&gt;We plan on keeping you updated with more posts in the Inside FastBoot series as we continue to make progress, so please stay tuned for more!&lt;/p&gt;
</content>
  </entry>
</feed>
